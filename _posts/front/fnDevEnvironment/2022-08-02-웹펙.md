---
layout: single
title: "Webpack 의 이해"
# categories: Git
categories:
  - feDevEnvironment # HTML CSS JavaScript Server Algorithm Wecodes Programmers CS Github Blog
tag: [웹펙] #tag는 여러개 가능함
toc: true #table of content 기능!
toc_sticky: true
author_profile: true #blog 글안에서는 author_profile이 따라다니지 않도록 설정함
date: 2022-08-02T15:30:00+09:00
# sidebar:
# nav: "docs" #네비게이션에 있는 docs를 의미함
---
<style>
.crimson {
  color: crimson;
  font-weight: bold;
}

.mediumblue {
  color: mediumblue;
  font-weight: bold;
}

.forestgreen {
  color: forestgreen;
  font-weight: bold;
}

.black {
  color: black;
  font-weight: bold;
}
</style>

# Webpack 의 이해
(joshua1988) : [웹팩 핸드북](https://joshua1988.github.io/webpack-guide/guide.html)  
(MDN) : [JavaScript modules](https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Modules)  
(NAVER Hello world) : [JavaScript 표준을 위한 움직임: CommonJS 와 AMD](https://d2.naver.com/helloworld/12864)  
(김정환님 블로그) : [프론트엔드 개발환경의 이해: 웹팩(기본)](https://jeonghwan-kim.github.io/series/2019/12/10/frontend-dev-env-webpack-basic.html)  
(김정환님 블로그) : [프론트엔드 개발환경의 이해: 웹팩(심화)](https://jeonghwan-kim.github.io/series/2020/01/02/frontend-dev-env-webpack-intermediate.html)  
(GitHub README) : [webpack-dev-server](https://github.com/webpack/webpack-dev-server)  
(DaleSeo) : [웹팩 기본 설정법(Entry/ Output/ Loader/ Plugins)](https://www.daleseo.com/webpack-config/)  

Webpack 의 등장 배경을 이해하기 위해선 먼저 JavaScript module 시스템에 대하여 이해할 필요가 있다. <u>왜 Webpack 을 사용하는가</u>에 대한 답을 얻어보자.

# 🔴 웹팩이 필요한 이유
## 🟠 파일 단위의 자바스크립트 모듈 관리의 필요성
```html
<!-- index.html -->
<html>
  <head>
    <!-- ... -->
  </head>
  <body>
    <!-- ... -->
    <script src="./app.js"></script>
    <script src="./main.js"></script>
  </body>
</html>
```

```js
// app.js
var num = 10;
function getNum() {
  console.log(num);
}
```

```js
// main.js
var num = 20;
function getNum() {
  console.log(num);
}
```

위와 같이 <u>index.html</u> 에서는 <span class="forestgreen">app</span> 과 <span class="forestgreen">main</span> 이라는 자바스크립트 파일을 로딩하여 사용하고 있다. 그런데 아래의 코드와 같이 코드를 실행하면 어떤 문제가 생기게 될까?

```html
<!-- index.html -->
<html>
  <head>
    <!-- ... -->
  </head>
  <body>
    <!-- ... -->
    <script src="./app.js"></script>
    <script src="./main.js"></script>
    <script>
      getNum(); // 20
    </script>
  </body>
</html>
```

위의 코드에서 <u>getNum();</u> 의 결과로 <span class="forestgreen">20</span> 이라는 값이 할당되었다. 이는 app.js 에서 선언한 num 변수는 main.js 에서 다시 선언하고 20을 할당했기 때문이다.

이러한 문제점은 실제로 복잡한 애플리케이션을 개발할 때 발생하게 된다. 변수의 이름을 모두 기억하지 않는 이상은 <u>변수를 중복 선언</u>하여 의도치 않은 문제를 가져올 수 있다. 이와 같은 <span class="forestgreen">파일 단위로 변수를 관리하고자 하는 생각(자바스크립트 모듈화)</span>을 이전까지는 <u>AMD, Common.js 와 같은 라이브러리로 해결</u>해 왔다.

## 🟠 웹 개발 작업 자동화 도구
front-end 개발 업무를 할 때 가장 많이 반복되는 작업은 텍스트 편집기에서 코드를 수정하고 저장한 뒤 브라우저에서 새로 고침을 누르는 것이었다. 그래야 화면에 변경된 내용을 볼 수 있었다.

## 🟠 웹 애플리케이션의 빠른 로딩 속도와 높은 성능
일반적으로 특정 웹 사이트를 접근할 때 5초 이내로 웹 사이트가 표시되지 않으면 대부분의 사용자들은 해당 사이트를 벗어나거나 집중력을 잃게 된다.

그래서 웹 사이트의 로딩 속도를 높이기 위해 많은 노력들이 있었다. 그중 대표적인 것이 브라우저에서 서버로 요청하는 파일 숫자를 줄이는 것이다.

웹팩은 기본적으로 필요한 자원은 미리 로딩하는게 아니라 그때 그때 요청하자는 철학을 갖고 있다.

# 🔴 웹팩의 4가지 속성
- entry
- output
- loader
- plugin

## 🟠 Entry
`웹펙`은 기본적으로 여러 개의 <u>자바스크립트 모듈을 하나의 파일로 묶어내는 번들러</u>이다. 따라서 웹펙은 다른 모듈을 사용하고 있는 <span class="mediumblue">최상위 자바스크립트 파일이 어디에 있는지 알아야</span> 하며, 설정 파일에서 이를 <span class="crimson">Entry 속성</span>으로 명시하게 된다. 웹펙은 이 Entry 속성에 명시된 파일을 기준으로 의존성 트리를 만들어 하나의 번들 파일을 만들어 내게 된다. Entry 설정의 <span class="crimson">기본값은 ./src/index.js</span> 이다.

이와 같이 webpack.config.js의 entry를 가지고 기본값을 ./script.js로 변경할 수도 있다.

```js
// webpack.confing.js
module.exports = {
  entry: "./script.js",
};
```

```js
const message = document.createTextNode("Webpack Example");
document.body.appendChild(message);
```

위와 같이 설정을 마치고, 터미널에서 npx webpack 커맨드를 실행하면 웹팩이 script.js 파일을 읽어들여 <span class="crimson">main.js 파일</span>로 묶어낸다.

`entry` 는 웹팩에서 웹 자원을 변환하기 위해 필요한 <u>최초 진입점</u>이자 <span class="forestgreen">자바스크립트 파일 경로</span>이다.

```js
// webpack.config.js
module.exports = {
  entry: './src/index.js'
}
```

`entry 속성`에 지정된 파일에는 <u>웹 애플리케이션의 전반적인 구조와 내용</u>이 담겨져야 한다. 웹팩이 해당 파일을 가지고 <span class="forestgreen">웹 애플리케이션에서 사용되는 모듈들의 연관 관계를 이해하고 분석</span>하기 때문에 애플리케이션을 동작시킬 수 있는 내용들이 담겨야 한다.

아래의 코드는 해당 서비스가 싱글 페이지 애플리케이션이라고 가정하고 작성된 코드이다. 사용자의 <u>로그인 화면</u>, 로그인 후 진입하는 <u>메인 화면</u>, 그리고 <u>게시글을 작성하는 화면</u> 등 웹 서비스에 필요한 화면들이 <span class="mediumblue">모두 index.js 파일에서 불려지게</span> 된다.

```jsx
// index.js
import LoginView from './LoginView.js';
import HomeView from './HomeView.js';
import PostView from './PostView.js';

function initApp() {
  LoginView.init();
  HomeView.init();
  PostView.init();
}

initApp();
```

<img src="https://user-images.githubusercontent.com/87808288/194323365-8a79d064-66e0-4980-af26-56fd4be59068.png" width="60%">



`웹팩`은 <span class="mediumblue">src 디렉터리</span> 안의 <span class="crimson">index.js 파일</span>과 그 안에 <u>임포트 되어 있는 것들을 하나의 파일 번들로 묶은 후</u> <span class="forestgreen">public 디렉터리</span> 에 새로운 파일인 <span class="crimson">main.js 파일</span>로 떨궈 주게 된다. 이 과정을 흔히 `번들링`이라고 하게 된다.

이제 index.html 파일이 <u>우리가 작성한 원래 소스 파일이 아닌</u> <span class="mediumblue">웹팩이 만들어준 번들 파일을 참조하도록 수정</span>해야한다. 그리고 이때 index.html의 <span class="mediumblue">main.js</span> 경로는 <span class="mediumblue">절대 경로</span>로 지정해야한다.

```html
<!-- index.html -->
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>Demo</title>
  </head>
  <body>
    <div id="app"></div>
    <script src="/main.js"></script> <!-- '/' 절대경로로 지정! -->
  </body>
</html>
```

## 🟠 Output
output 속성은 웹팩을 돌리고 난 결과물의 파일 경로를 의미한다.

```js
// webpack.config.js
module.exports = {
  output: {
    filename: 'bundle.js'
  }
}
```

위의 코드와 같이 entry 속성과는 다르게 객체 형태로 옵션을 추가해야한다.

### 🟡 Output 속성 옵션
```js
// webpack.config.js
var path = require('path');

module.exports = {
  output: {
    filename: 'bundle.js',
    path: path.resolve(__dirname, './dist')
  }
}
```

위의 코드와 같이 최소한 `filename` 은 지정해야하며, `path 속성`을 함께 정의한다.

여기서 <u>filename 속성은 웹팩으로 빌드한 파일의 이름</u>을 의미하고, <u>path 속성은 해당 파일의 경로</u>를 의미힌다. 그리고 path 속성에서 사용된 <u>path.resolve()</u> 코드는 인자로 넘어온 경로들을 조합하여 유효한 파일 경로를 만들어주는 <span class="forestgreen">Node.js API</span> 이다. 이 API 가 하는 역할을 좀 더 쉽게 표현하자면 아래의 코드와 같다.

```js
output: './dist/bundle.js'
```

(Node.js) : [Node.js documentation](https://nodejs.org/api/path.html)

## 🟠 Loader
`로더`는 웹팩이 웹 애플리케이션을 해석할 때 <u>자바스크립트 파일이 아닌 웹 자원(HTML, CSS, Images, 폰트 등)을 변환할 수 있도록 도와주는 속성</u>이다. 엔트리나 아웃풋 속성과는 다르게 <span class="forestgreen">module</span> 이라는 이름을 사용한다.

```js
// webpack.config.js
module.exports = {
  module: {
    rules: []
  }
}
```

### 🟡 Loader 가 필요한 이유
웹팩으로 애플리케이션을 빌드할 때 아래와 같은 코드가 있다고 가정해보자.

```js
// app.js
import './common.css';

console.log('css loaded');
```

```css
/* common.css */
p {
  color: blue;
}
```

```js
// webpack.config.js
module.exports = {
  entry: './app.js',
  output: {
    filename: 'bundle.js'
  }
}
```

하지만 위의 코드를 웹팩으로 빌드하면 <span class="mediumblue">에러</span>가 발생하게 되는데, <u>app.js 파일에서 임포트한 common.css 파일을 해석하기 위해 적절한 로더를 추가해야한다</u>는 에러이다.

이를 해결하기 위해서 아래의 NPM 명령어로 CSS 로더를 설치하고 웹팩 설정 파일 설정을 바꾼다면 에러를 해결할 수 있다.

```bash
npm i css-loader -D
```

```js
// webpack.config.js
module.exports = {
  entry: './app.js',
  output: {
    filename: 'bundle.js'
  },
  module: {
    rules: [
      {
        test: /\.css$/,
        use: ['css-loader']
      }
    ]
  }
}
```

위의 <u>module 코드</u>를 살펴보면, <span class="forestgreen">rules</span> 배열에 객체 한 쌍을 추가했다. 그리고 이 객체에는 2개의 속성이 들어가 있는데 각각 아래의 역할을 한다. 결과적으로 위의 코드는 해당 프로젝트의 <u>모든 CSS 파일</u>에 대해서 <span class="mediumblue">CSS 로더를 적용</span>하겠다는 의미를 가진다.
- <span class="mediumblue">test</span>: 로더를 적용할 파일 유형(일반적으로 정규 표현식을 사용)
- <span class="mediumblue">use</span>: 해당 파일에 적용할 로더의 이름

로더를 여러 개 사용하는 경우에는 아래와 같이 rules 배열에 로더 옵션을 추가할 수 있다.

```jsx
module.exports = {
  module: {
    rules: [
      { test: /\.css$/, use: 'css-loader' },
      { test: /\.ts$/, use: 'ts-loader' },
      // ...
    ]
  }
}
```

# 🔴 historyApiFallback
## 🟠 History?
(Basemenks) : [Web History란 무엇인가](https://basemenks.tistory.com/269)
(MDN) : [History](https://developer.mozilla.org/ko/docs/Web/API/History)

<span class="crimson">History</span> 인터페이스는 <u>브라우저의 세션 기록</u>, 즉 현재 페이지를 불러온 탭 또는 프레임의 방문 기록을 조작할 수 있는 방법을 제공한다. 즉 세션 기록(페이지 방문 기록)에 대한 접근 방법과 메서드를 제공하는 것이다.

> 세션(session)이란?  
<span class="mediumblue">세션(session)</span>이란 웹 사이트의 여러 페이지에 걸쳐 사용되는 사용자 정보를 저장하는 방법을 의미한다. 사용자가 브라우저를 닫아 서버와의 연결을 끝내는 시점까지를 세션이라 한다. <span class="mediumblue">쿠키</span>는 <u>클라이언트 측의 컴퓨터에 모든 데이터를 저장</u>한다. 하지만 <span class="forestgreen">세션은 서비스가 돌아가는 서버 측에 데이터를 저장</span>하고, 세션의 키값만을 클라이언트 측에 남겨둔다. 브라우저는 필요할 때마다 이 키값을 이용하여 서버에 저장된 데이터를 사용하게 됩니다. 이러한 <u>세션은 보안에 취약한 쿠키를 보완해주는 역할</u>을 한다.

## 🟠 historyApiFallback: true
React Router에서 설정하지 않은 URL에 접속시 NotFoundPage로 이동하도록 미리 설정해주었다. router가 있는 App 컴포넌트의 코드는 아래와 같다.

```jsx
// App.jsx
import {
  Routes,
  Route,
  Link,
} from 'react-router-dom';

import HomePage from './HomePage';
import AboutPage from './AboutPage';
import NotFoundPage from './NotFoundPage';
import RestaurantsPage from './RestaurantsPage';
import RestaurantPage from './RestaurantPage';

export default function App() {
  return (
    <div>
      <header>
        <h1>
          <Link to="/">헤더 영역</Link>
        </h1>
      </header>
      <Routes>
        <Route path="/" element={<HomePage />} />
        <Route path="/about" element={<AboutPage />} />
        <Route path="/restaurants" element={<RestaurantsPage />} />
        <Route path="/restaurants/:id" element={<RestaurantPage />} />
        <Route path="*" element={<NotFoundPage />} />
      </Routes>
    </div>
  );
}
```

그런데 아래의 이미지와 같이 <u>설정되어 있지 않은 URL</u>을 입력하자 <span class="forestgreen">NotFoundPage로 가지 못하고 에러</span>가 발생했다. <u>기존의 MPA</u>의 방식에서는 URL이 바뀌면, <span class="mediumblue">브라우저는 서버에게 URL의 절대 경로에 있는 HTML 파일을 달라고 GET 요청</span>을 보낸다. 마찬가지로 아래의 "/restaurant"은 <span class="crimson">서버에 존재하지 않는 restaurant에 GET 요청</span>을 보냄으로 인하여 404 에러가 발생하게 된 것이다.  
<img src="https://user-images.githubusercontent.com/87808288/190910924-ebcbcb79-e5ae-4d42-8da6-aa30d2e25088.png" width="90%">

이러한 문제들을 아래와 같이 <u>webpack의 설정을 추가</u>하여 이를 해결할 수 있었다.

```jsx
// webpack.config.js
const path = require('path');

module.exports = {
  entry: path.resolve(__dirname, 'src/index.jsx'),
  module: {
    rules: [
      {
        test: /\.jsx?$/,
        exclude: /node_modules/,
        use: 'babel-loader',
      },
    ],
  },
  resolve: {
    extensions: ['.js', '.jsx'],
  },

  devServer: { // 이 부분을 추가
    historyApiFallback: {
      index: 'index.html',
    },
  },

  // devServer: {
  //   historyApiFallback: true,
  // },
};
```

<u>webpack의 devServer를 설정</u>하게 되면, <span class="forestgreen">URL의 해당 경로에 파일이 존재하지 않을때</span> <span class="mediumblue">index.html로 fallBack</span>하게 된다. 그렇게 404 error가 발생하지 않고 index.html에 script 되어있는 <span class="crimson">main.js</span>를 통해 라우터의 경로가 지정되어 있는 <span class="forestgreen">App 컴포넌트</span>에 내용에 따라 <u>"/restaurant"는 NotFoundPage 컴포넌트가 화면에 출력</u>되게 된다.

기본적으로 webpack은 webpack.config.js에서 설정을 따로 하지 않을 경우 <u>main.js라는 이름으로 public 디렉터리에 저장</u>된다. 그리고 <span class="mediumblue">index.js 파일과 그 안에 import 되어있는 것들</span>을 <span class="crimson">하나의 파일 번들로 묶은 후 main.js 파일로 구성</span>하게된다.

<!-- ① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨-->

<!-- ### 2. Link 넣기

```

유형 1: (설명어를 입력) : [gunhee's coding blog](https://gunhee-jeong.github.io/)
유형 2: (URL 자동연결) : <https://gunhee-jeong.github.io/>
유형 3: (동일 파일 내 '문단으로 이동') : [1. Header로 이동](###-1-header)

```

```bash
.next/static
        ├── AbmKMg9BFeVUuJ7lsQ1w8
        ├── chunks                 // 여러 페이지에서 공통으로 사용되는 번들 파일
        │       └──  pages         // 각 페이지의 번들 파일
        ├── runtime                // 웹팩과 next의 런타임과 관련된 번들 파일
        ├── css                    // 애플리케이션의 모든 페이지에 대한 글로벌 CSS 파일
        └── media                  // 정적으로 가져온 이미지 next/image가 여기에 해시 및 복사
        
```

<details>
<summary class="black">코드</summary>
<div markdown="1">

```jsx
// helloWorld!
const hello = 'hi';
```
</div>
</details>

1. 특수문자를 제거
2. 스페이스는 -로 바꾸고
3. 대문자는 소문자로!
   그래서 ### 1. Header -> #1-header

## Link: [google][https://www.google.com/]

### 3. 수평선

```

---

```

---

### 4. 라인 바꾸기

```

스페이스바를 2번 눌러주면 다음칸으로
이동할 수 있어요!

```

---

스페이스바를 2번 눌러주면
다음칸으로 이동할 수 있어요!

### 5. list 만들기

```

1. 1번
2. 2번
3. 3번

- 순서없는 list
  - 순서없는 list
    - 순서없는 list

```

1. 1번
2. 2번
3. 3번

- 순서없는 list
  - 순서없는 list
    - 순서없는 list

---

### 6. font 관련

```

**진하게** -> 볼드
_기울여서_ -> 이탤릭체
~~취소선~~ -> 취소선

<ul>밑줄넣기</ul> -> 밑줄
<span style="color:red">빨간 글씨</span> -> 글자색
이것이 `인라인` 입니다 -> 인라인 코드
```

**진하게** -> 볼드
_기울여서_ -> 이탤릭체
~~취소선~~ -> 취소선
<u>밑줄넣기</u> -> 밑줄
<span style="color:red">빨간 글씨</span>
이것이 `인라인` 입니다 -> 인라인 코드

---

### 7. 인용구문

```
> coding
>
> > JavaScript
> >
> > > 내가 프짱!
```

> coding
>
> > JavaScript
> >
> > > 내가 프짱!

---

### 8. 이미지 삽입

```
유형1: ('사이즈를 조절' -> HTML 태그 사용) : <img src="https://gunhee-jeong.github.io/assets/images/blogLogo.png" width="300" height="200">
유형2: (이미지 삽입 후 -> 링크 걸기)
[![이미지](https://gunhee-jeong.github.io/assets/images/blogLogo/blogLogo.png)](https://gunhee-jeong.github.io/)
```

유형1: ('사이즈를 조절' -> HTML 태그 사용) : <img src="https://gunhee-jeong.github.io/assets/images/blogLogo.png" width="300" height="200">
유형2: (이미지 삽입 후 -> 링크 걸기)
[![이미지](https://gunhee-jeong.github.io/assets/images/blogLogo.png)](https://gunhee-jeong.github.io/)

### 9. 표 만들기

```
||국어|영어|
| :--- | ---: | :--: |
|건희 | 100점 | 100점
|철수 | 100점 | 100점
```

|      |  국어 | 영어  |
| :--- | ----: | :---: |
| 건희 | 100점 | 100점 |
| 철수 | 100점 | 100점 |

> - header를 넣고 싶은 경우 ---을 사용하고 :을 이용하여 정렬에 사용함!

### 10. 토글 만들기

```
<details>
<summary>여기를 누르세요</summary>
<div markdown="1">
숨겨진 내용
</div>
</details>
```

<details>
<summary>여기를 누르세요</summary>
<div markdown="1">
숨겨진 내용
</div>
</details> -->
