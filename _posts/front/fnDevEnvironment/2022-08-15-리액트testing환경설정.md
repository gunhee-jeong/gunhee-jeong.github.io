---
layout: single
title: "리액트 testing 환경설정"
# categories: Git
categories:
  - feDevEnvironment # HTML CSS JavaScript Server Algorithm Wecode Programmers CS Github Blog
tag: [TDD, Jest] #tag는 여러개 가능함
toc: true #table of content 기능!
toc_sticky: true
author_profile: true #blog 글안에서는 author_profile이 따라다니지 않도록 설정함
date: 2022-08-15T16:00:00+09:00
# sidebar:
# nav: "docs" #네비게이션에 있는 docs를 의미함
---
<style>
.red {
  color: red;
  font-weight: bold;
}

.tomato {
  color: tomato;
  font-weight: bold;
}

.blue {
  color: blue;
  font-weight: bold;
}

.royalblue {
  color: royalblue;
  font-weight: bold;
}

.forestgreen {
  color: forestgreen;
  font-weight: bold;
}

.darkorange {
  color: darkorange;
  font-weight: bold;
}

</style>
우리가 <span class="blue">무언가를 수정했을 때 다른 컴포넌트들이 올바르게 동작하는지</span> 손으로 직접 테스트하는 것은 많이 시간이 소요된다.  
이 모든 것을 <span class="tomato">컴퓨터가 자동으로 아주 빠르게 확인</span>해주면 어떨까에서 시작한 것이 바로 <span class="red">TDD</span>이다.  

# 1장 설치
## 1. Jest
```bash
npm i -D jest babel-jest
```

```bash
npm i -D @types/jest
```

`@types/jest`는 <span class="blue">Jest의 타입 정의를 가지고 있는 모듈</span>이다.  
TypeScript에서 주로 사용되지만 이 모듈을 설치하면 <span class="royalblue">편집기 내에서 자동완성을 지원</span>하기 때문에 설치하는 것이 좋다.  

## 2. 파일 설정
### (1) eslintrc.js
```jsx
// eslintrc.js
module.exports = {
  env: {
    browser: true,
    es2021: true,
    jest: true, // 이 부분을 추가함
  },
  extends: [
    'plugin:react/recommended',
    'airbnb',
  ],
  parserOptions: {
    ecmaFeatures: {
      jsx: true,
    },
    ecmaVersion: 12,
    sourceType: 'module',
  },
  plugins: [
    'react',
  ],
  globals: {
    Atomics: 'readonly',
    SharedArrayBuffer: 'readonly',
    actor: 'readonly',
    Feature: 'readonly',
    Scenario: 'readonly',
    context: 'readonly',
  },
  rules: {
    indent: ['error', 2],
    'no-trailing-spaces': 'error',
    curly: 'error',
    'brace-style': 'error',
    'no-multi-spaces': 'error',
    'space-infix-ops': 'error',
    'space-unary-ops': 'error',
    'no-whitespace-before-property': 'error',
    'func-call-spacing': 'error',
    'space-before-blocks': 'error',
    'keyword-spacing': ['error', { before: true, after: true }],
    'comma-spacing': ['error', { before: false, after: true }],
    'comma-style': ['error', 'last'],
    'comma-dangle': ['error', 'always-multiline'],
    'space-in-parens': ['error', 'never'],
    'block-spacing': 'error',
    'array-bracket-spacing': ['error', 'never'],
    'object-curly-spacing': ['error', 'always'],
    'key-spacing': ['error', { mode: 'strict' }],
    'arrow-spacing': ['error', { before: true, after: true }],
    'jsx-a11y/label-has-associated-control': ['error', { assert: 'either' }],
    'linebreak-style': 'off',

    'react/prop-types': 'off',
    'react/react-in-jsx-scope': 'off',
  },
};
```

### (2) jest.setup.js
```jsx
// jest.setup.js
import '@testing-library/jest-dom';
```

### (3) jest.config.js
```jsx
// jest.config.js
module.exports = {
  setupFilesAfterEnv: [
    'jest-plugin-context/setup',
    './jest.setup',
  ],
  coverageThreshold: {
    global: {
      branches: 100,
      functions: 100,
      lines: 100,
      statements: 100,
    },
  },
};
```

## 3. test 실행 방법
```bash
npx jest
```

이렇게 위의 명령어를 실행하면 jest를 실행해 볼 수 있다.  
또한 jest를 그때그때 실행하는 방법이 아닌 자동으로 하기 위해서는 아래의 명령어를 사용할 수 있다.  

```bash
npx jest --watchAll
```

## 3. BDD 방법론
(테스트 자동화와 Mocha) : [JAVASCRPT.INFO](https://ko.javascript.info/testing-mocha#ref-1068)  

Behavior Driven Development라 불리는 방법론에 대해 알아보자.  
이 방법론은 <u>test</u>, <u>documentation</u>, <u>example</u>를 한데 모아놓은 개념이다.  
### (1) 예시: 거듭제곱 함수와 명세서
x를 n번 곱해주는 함수인 pow(x, n)을 구현하고 있다고 가정해보자.  
(사실 JS에는 거듭제곱 연산자, **가 이미 존재하지만 BDD에 관한 설명을 위해 함수로 만든다.)  

코드를 작성하기 전에 먼저 <span class="royalblue">코드가 무슨 일을 하는지</span> 이를 자연어로 표현해야한다.  
이때 만들어진 산출물을 BDD에선 <span class="royalblue">명세서(specification)</span> 또는 <span class="royalblue">스펙(spec)</span>이라고 부른다.  
명세서에는 아래와 같이 유스 케이스에 대한 자세한 설명과 테스트가 담겨있다.  

```jsx
describe("pow", function() {

  it("주어진 숫자의 n 제곱", function() {
    assert.equal(pow(2, 3), 8);
  });

});
```

`스펙`은 <span class="blue">세 가지 주요 구성 요소</span>로 이루어진다.  
⓵ <span class="forestgreen">describe</span>("title", function() { ... })  
<u>구현하고자 하는 기능에 대한 설명</u>이 들어간다.  

⓶ <span class="forestgreen">it</span>("유스 케이스 설명", function() { ... })  
<span class="tomato">it</span>의 <u>첫 번째 인수</u>엔 <span class="blue">특정 유스 케이스에 대한 설명</span>이 들어간다.  
이 설명은 <span class="blue">누구나 읽을 수 있고 이해할 수 있는 자연어로</span> 적게된다.  
두 번째 인수엔 유스 케이스 테스트 함수가 들어간다.  

⓷ <span class="forestgreen">assert.equal</span>(value1, value2)  
기능을 제대로 구현했다면 it 블록 내의 코드 <span class="darkorange">assert.equal(value1, value2)</span> 이 <u>에러 없이 실행</u>된다.  

### (2) 스펙 실행하기
#### [라이브러리 설명]
- Mocha: 핵심 테스트 프레임워크로, describe it과 같은 테스팅 함수와 테스트 실행 관련 주요 함수 제공
- Chai: 다양한 assertion을 제공해 주는 라이브러리(assert.equal)
- Sinon: 함수의 정보를 캐내는 데 사용하는 라이브러리로, 내장 함수 등을 모방한다.  

코드의 초안을 아래와 같이 작성할 수 있다.  

```jsx
// 코드
function pow(x, n) {
  return 8; // 속임수를 써봤습니다. :)
}
```

### (3) 스펙 개선하기
꼼수를 사용했기 때문에 pow(3,4)를 실행하면 바로 틀린 결과라고 나오게 된다.  
하지만 <u>테스트는 모두 통과하게</u> 된다.  
이러한 결과는 스펙이 불완전해서 그런 것이기에 <span class="blue">더 많은 유스 케이스를 추가해야</span>한다.  

pow(3, 4) = 81을 만족하는지 확인하는 테스트를 추가할 수 있다.  
스펙에 테스트를 추가하는 방법은 아래와 같이 두 가지가 있다.  

⓵ 기존 it 블록에 assert를 하나 더 추가

```jsx
describe("pow", function() {

  it("주어진 숫자의 n 제곱", function() {
    assert.equal(pow(2, 3), 8);
    assert.equal(pow(3, 4), 81);
  });

});
```

⓶ 테스트를 하나 더 추가(it 블록 하나 더 추가하기)

```jsx
describe("pow", function() {

  it("2를 세 번 곱하면 8입니다.", function() {
    assert.equal(pow(2, 3), 8);
  });

  it("3을 네 번 곱하면 81입니다.", function() {
    assert.equal(pow(3, 4), 81);
  });

});
```

<u>assert에서 에러가 발생</u>하면 <span class="royalblue">it 블록은 즉시 종료</span>된다.  
따라서 <span class="blue">기존 it 블록에 assert를 하나 더 추가</span>하면  
첫 번째 assert가 실패했을 때 <span class="tomato">두 번째 assert의 결과를 알 수 없게 된다</span>.  
때문에 두 번째 방법과 같이 <span class="red">it 블록을 추가하여 테스트할 경우 더 많은 정보를 얻을 수 있는 것</span>이다.  

추가로 테스트를 추가할 때 아래의 규칙도 따르는 것이 좋다.  
- <u>테스트 하나에선</u> <span class="blue">한 가지만 확인</span>하기  

테스트 하나에서 연관이 없는 사항 두 개를 점검하고 있다면 이것을 분리하는 것이 좋다.  

### (4) 코드 개선하기
두 번째 테스트에서도 통과할 수 있도록 코드를 개선해야 한다.  

```jsx
// 코드
function pow(x, n) {
  let result = 1;

  for (let i = 0; i < n; i++) {
    result *= x;
  }

  return result;
}
```

함수가 제대로 작동하는지 확인하기 위해 더 많은 값을 테스트하여야 한다.  
<u>수동으로 여러 개의 it 블록을 만드는 대신</u> <span class="royalblue">for 문을 사용하여 자동으로 it 블록을</span> 만들 수 있다.  

```jsx
describe("pow", function() {

  function makeTest(x) {
    let expected = x * x * x;
    it(`${x}을/를 세 번 곱하면 ${expected}입니다.`, function() {
      assert.equal(pow(x, 3), expected);
    });
  }

  for (let x = 1; x <= 5; x++) {
    makeTest(x);
  }
});
```

테스트 결과는 아래의 이미지와 같다.  

<img src="https://user-images.githubusercontent.com/87808288/184849615-7cb3d223-9c50-455f-bfbc-e2c6fd4979db.png" width="70%">  

### (5) 중첩 describe
아래의 코드에서 `헬퍼 함수 makeTest`와 `for 문`이 <span class="blue">중첩 describe 안에 함께 묶여있는 것</span>에 주목해야한다.  
<span class="tomato">makeTest는 오직 for 문에서만 사용</span>되고, 다른 데선 사용되지 않기 때문에 이렇게 묶어놓게 된다.  
아래 스펙에서 makeTest와 for문은 함께 어우러져 pow가 제대로 동작하는지 확인해주는 역할을 한다.  
이렇게 <u>중첩 describe를 사용</u>하면 <span class="blue">그룹을 만들 수 있게</span> 된다.  

```jsx
describe("pow", function() {

  describe("x를 세 번 곱합니다.", function() {

    function makeTest(x) {
      let expected = x * x * x;
      it(`${x}을/를 세 번 곱하면 ${expected}입니다.`, function() {
        assert.equal(pow(x, 3), expected);
      });
    }

    for (let x = 1; x <= 5; x++) {
      makeTest(x);
    }

  });

  // describe와 it을 사용해 이 아래에 더 많은 테스트를 추가할 수 있습니다.
});
```

`중첩 describe`는 새로운 테스트 <span class="blue">"하위 그룹(subgroup)"을 정의</span>할 때 사용된다.  
이렇게 새로 정의된 테스트 하위 그룹은 테스트 결과 보고서에 들여쓰기 된 상태로 출력된다.  
<img src="https://user-images.githubusercontent.com/87808288/184851849-db0251f9-54f3-4632-8938-4fd34c8e870b.png" width="70%">  

#### [before/after와 beforeEach/afterEach]
함수 before는 (전체) 테스트가 실행되기 전에 실행되고,  
함수 after는 (전체) 테스트가 실행된 후에 실행된다.  
함수 beforeEach는 매 it이 실행되기 전에 실행되고,  
함수 afterEach는 매 it이 실행된 후에 실행된다.  

```jsx
describe("test", function() {

  before(() => alert("테스트를 시작합니다 - 테스트가 시작되기 전"));
  after(() => alert("테스트를 종료합니다 - 테스트가 종료된 후"));

  beforeEach(() => alert("단일 테스트를 시작합니다 - 각 테스트 시작 전"));
  afterEach(() => alert("단일 테스트를 종료합니다 - 각 테스트 종료 후"));

  it('test 1', () => alert(1));
  it('test 2', () => alert(2));

});
```

실행 순서는 아래와 같다.  

```bash
테스트를 시작합니다 - 테스트가 시작되기 전          (before)
단일 테스트를 시작합니다 - 각 테스트 시작 전         (beforeEach)
1
단일 테스트를 종료합니다 - 각 테스트 종료 후         (afterEach)
단일 테스트를 시작합니다 - 각 테스트 시작 전         (beforeEach)
2
단일 테스트를 종료합니다 - 각 테스트 종료 후         (afterEach)
테스트를 종료합니다 - 테스트가 종료된 후            (after)
```
before/after와 beforeEach/afterEach는 대게 초기화의 용도로 사용하게 된다.  
카운터 변수를 0으로 만들거나  
테스트가 바뀔 때(또는 테스트 그룹이 바뀔 때)마다 해줘야 하는 작업이 있으면 이들을 이용할 수 있다.  

### (6) 스펙 확장하기
앞서 정의했듯이 함수 pow(x, n)의 매개변수 n은 양의 정수이어햐 했다.  

자바스크립트에선 수학 관련 연산을 수행하다 에러가 발생하면 NaN을 반환한다.  
함수 pow도 n이 조건에 맞지 않으면 NaN을 반환해야 한다.  

n이 조건에 맞지 않을 때 함수가 NaN을 반환하는지를 검사해주는 테스트를 추가하면 아래와 같다.  

```jsx
describe("pow", function() {

  // ...

  it("n이 음수일 때 결과는 NaN입니다.", function() {
    assert.isNaN(pow(2, -1));
  });

  it("n이 정수가 아닐 때 결과는 NaN입니다.", function() {
    assert.isNaN(pow(2, 1.5));
  });

});
```

<img src="https://user-images.githubusercontent.com/87808288/184854058-61d4492b-b276-45e9-8af4-0b155684fa50.png" width="70%">  

기존에 n이 음수이거나 정수가 아닌 경우를 생각하지 않고 구현했기에  
<span class="tomato">새롭게 추가한 테스트는 실패할 수 밖에 없다</span>.  
<span class="red">BDD의 핵심</span>은 바로 그것에 있다.  
<span class="royalblue">실패할 수 밖에 없는 테스트를 추가</span>하고, <span class="blue">테스트를 통과할 수 있게 코드를 개선</span>하는 것이다.  

> 다양한 assertion
위에서 사용한 assert.isNaN은 NaN인지 아닌지 확인한다.  
(Chai) : [assert](https://www.chaijs.com/api/assert/)  
Chai는 이 외에도 다양한 assertion을 지원한다.  
- assert.equal(value1, value2) – value1과 value2의 동등성을 확인합니다(value1 == value2).  
- assert.strictEqual(value1, value2) – value1과 value2의 일치성을 확인합니다(value1 === value2).  
- assert.notEqual, assert.notStrictEqual – 비 동등성, 비 일치성을 확인합니다.  
- assert.isTrue(value) – value가 true인지 확인합니다(value === true).  
- assert.isFalse(value) – value가 false인지 확인합니다(value === false).  

이제 새롭게 추가한 테스트를 통과하기 위해 pow 코드를 수정한다.  

```jsx
// code
function pow(x, n) {
  if (n < 0) return NaN;
  if (Math.round(n) != n) return NaN;

  let result = 1;

  for (let i = 0; i < n; i++) {
    result *= x;
  }

  return result;
}
```

<img src="https://user-images.githubusercontent.com/87808288/184856051-a627eb9a-43fa-47e2-abb0-0f7e9a01b2b1.png" width="70%">  
그러면 위의 이미지와 같이 에러 없이 테스트들을 통과하게 된다.  

# 3장 React testing library
리액트 테스팅 라이브러리는 사용자와 동일한 방식으로 DOM 쿼리를 사용할 수 있게 도와준다.  
실제 사용자가 앱을 사용하는 방식으로 테스트하여 우리의 앱이 올바르게 동작하는지 테스트할 수 있다.  

## 1. 설치
```bash
npm i -D @testing-library/react @testing-library/jest-dom
```

### (1) @testing-library/jest-dom
@testing-library/jest-dom은 jest의 matcher들을 확장하여 테스트의 의도를 명확하게 표현할 수 있다.  

### (2) fireEvent
테스팅에서 DOM 이벤트를 편리하게 발생시켜주는 메서드이다.  
click, change 등의 이벤트를 발생시킬 수 있다.  

### (3) Mocking
mocking은 일부 기능을 테스트할 때 의존 관계를 끊고 독립적으로 테스트할 수 있게 한다.  
`jest.fn()`을 통해서 <span class="blue">함수를 mocking</span> 할 수도 있다.  
Jest에서 제공하는 다양한 mocking 방법이 있다.  

<!-- ⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ -->

<!-- ### 2. Link 넣기

```

유형 1: (설명어를 입력) : [gunhee's coding blog](https://gunhee-jeong.github.io/)
유형 2: (URL 자동연결) : <https://gunhee-jeong.github.io/>
유형 3: (동일 파일 내 '문단으로 이동') : [1. Header로 이동](###-1-header)

```

유형 1: (설명어를 입력) : [gunhee's coding blog](https://gunhee-jeong.github.io/)
유형 2: (URL 자동연결) : <https://gunhee-jeong.github.io/>
유형 3: (동일 파일 내 '문단으로 이동') : [1. Header로 이동](#1-header)
유형 3의 방법

1. 특수문자를 제거
2. 스페이스는 -로 바꾸고
3. 대문자는 소문자로!
   그래서 ### 1. Header -> #1-header

## Link: [google][https://www.google.com/]

### 3. 수평선

```

---

```

---

### 4. 라인 바꾸기

```

스페이스바를 2번 눌러주면 다음칸으로
이동할 수 있어요!

```

---

스페이스바를 2번 눌러주면
다음칸으로 이동할 수 있어요!

### 5. list 만들기

```

1. 1번
2. 2번
3. 3번

- 순서없는 list
  - 순서없는 list
    - 순서없는 list

```

1. 1번
2. 2번
3. 3번

- 순서없는 list
  - 순서없는 list
    - 순서없는 list

---

### 6. font 관련

```

**진하게** -> 볼드
_기울여서_ -> 이탤릭체
~~취소선~~ -> 취소선

<ul>밑줄넣기</ul> -> 밑줄
<span style="color:red">빨간 글씨</span> -> 글자색
이것이 `인라인` 입니다 -> 인라인 코드
```

**진하게** -> 볼드
_기울여서_ -> 이탤릭체
~~취소선~~ -> 취소선
<u>밑줄넣기</u> -> 밑줄
<span style="color:red">빨간 글씨</span>
이것이 `인라인` 입니다 -> 인라인 코드

---

### 7. 인용구문

```
> coding
>
> > JavaScript
> >
> > > 내가 프짱!
```

> coding
>
> > JavaScript
> >
> > > 내가 프짱!

---

### 8. 이미지 삽입

```
유형1: ('사이즈를 조절' -> HTML 태그 사용) : <img src="https://gunhee-jeong.github.io/assets/images/blogLogo.png" width="300" height="200">
유형2: (이미지 삽입 후 -> 링크 걸기)
[![이미지](https://gunhee-jeong.github.io/assets/images/blogLogo/blogLogo.png)](https://gunhee-jeong.github.io/)
```

유형1: ('사이즈를 조절' -> HTML 태그 사용) : <img src="https://gunhee-jeong.github.io/assets/images/blogLogo.png" width="300" height="200">
유형2: (이미지 삽입 후 -> 링크 걸기)
[![이미지](https://gunhee-jeong.github.io/assets/images/blogLogo.png)](https://gunhee-jeong.github.io/)

### 9. 표 만들기

```
||국어|영어|
| :--- | ---: | :--: |
|건희 | 100점 | 100점
|철수 | 100점 | 100점
```

|      |  국어 | 영어  |
| :--- | ----: | :---: |
| 건희 | 100점 | 100점 |
| 철수 | 100점 | 100점 |

> - header를 넣고 싶은 경우 ---을 사용하고 :을 이용하여 정렬에 사용함!

### 10. 토글 만들기

```
<details>
<summary>여기를 누르세요</summary>
<div markdown="1">
숨겨진 내용
</div>
</details>
```

<details>
<summary>여기를 누르세요</summary>
<div markdown="1">
숨겨진 내용
</div>
</details> -->
