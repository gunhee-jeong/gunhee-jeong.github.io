---
layout: single
title: "리액트 testing 환경설정"
# categories: Git
categories:
  - feDevEnvironment # HTML CSS JavaScript Server Algorithm Wecode Programmers CS Github Blog
tag: [TDD, Jest] #tag는 여러개 가능함
toc: true #table of content 기능!
toc_sticky: true
author_profile: true #blog 글안에서는 author_profile이 따라다니지 않도록 설정함
date: 2022-08-15T16:00:00+09:00
# sidebar:
# nav: "docs" #네비게이션에 있는 docs를 의미함
---
<style>
.red {
  color: red;
  font-weight: bold;
}

.tomato {
  color: tomato;
  font-weight: bold;
}

.blue {
  color: blue;
  font-weight: bold;
}

.royalblue {
  color: royalblue;
  font-weight: bold;
}

.forestgreen {
  color: forestgreen;
  font-weight: bold;
}

.darkorange {
  color: darkorange;
  font-weight: bold;
}

</style>
우리가 <span class="blue">무언가를 수정했을 때 다른 컴포넌트들이 올바르게 동작하는지</span> 손으로 직접 테스트하는 것은 많이 시간이 소요된다.  
이 모든 것을 <span class="tomato">컴퓨터가 자동으로 아주 빠르게 확인</span>해주면 어떨까에서 시작한 것이 바로 <span class="red">TDD</span>이다.  

## 1. 설치
### (1) Jest 설치
```bash
npm i -D jest babel-jest
```

```bash
npm i -D @types/jest
```

`@types/jest`는 <span class="blue">Jest의 타입 정의를 가지고 있는 모듈</span>이다.  
TypeScript에서 주로 사용되지만 이 모듈을 설치하면 <span class="royalblue">편집기 내에서 자동완성을 지원</span>하기 때문에 설치하는 것이 좋다.  

### (2) 파일 설정
```jsx
// eslintrc.js
module.exports = {
  env: {
    browser: true,
    es2021: true,
    jest: true, // 이 부분을 추가함
  },
  extends: [
    'plugin:react/recommended',
    'airbnb',
  ],
  parserOptions: {
    ecmaFeatures: {
      jsx: true,
    },
    ecmaVersion: 12,
    sourceType: 'module',
  },
  plugins: [
    'react',
  ],
  globals: {
    Atomics: 'readonly',
    SharedArrayBuffer: 'readonly',
    actor: 'readonly',
    Feature: 'readonly',
    Scenario: 'readonly',
    context: 'readonly',
  },
  rules: {
    indent: ['error', 2],
    'no-trailing-spaces': 'error',
    curly: 'error',
    'brace-style': 'error',
    'no-multi-spaces': 'error',
    'space-infix-ops': 'error',
    'space-unary-ops': 'error',
    'no-whitespace-before-property': 'error',
    'func-call-spacing': 'error',
    'space-before-blocks': 'error',
    'keyword-spacing': ['error', { before: true, after: true }],
    'comma-spacing': ['error', { before: false, after: true }],
    'comma-style': ['error', 'last'],
    'comma-dangle': ['error', 'always-multiline'],
    'space-in-parens': ['error', 'never'],
    'block-spacing': 'error',
    'array-bracket-spacing': ['error', 'never'],
    'object-curly-spacing': ['error', 'always'],
    'key-spacing': ['error', { mode: 'strict' }],
    'arrow-spacing': ['error', { before: true, after: true }],
    'jsx-a11y/label-has-associated-control': ['error', { assert: 'either' }],
    'linebreak-style': 'off',

    'react/prop-types': 'off',
    'react/react-in-jsx-scope': 'off',
  },
};
```

```jsx
// jest.setup.js
import '@testing-library/jest-dom';
```

```jsx
// jest.config.js
module.exports = {
  setupFilesAfterEnv: [
    'jest-plugin-context/setup',
    './jest.setup',
  ],
  coverageThreshold: {
    global: {
      branches: 100,
      functions: 100,
      lines: 100,
      statements: 100,
    },
  },
};
```

### (3) 실행
```bash
npx jest
```

이렇게 위의 명령어를 실행하면 jest를 실행해 볼 수 있다.  
또한 jest를 그때그때 실행하는 방법이 아닌 자동으로 하기 위해서는 아래의 명령어를 사용할 수 있다.  

```bash
npx jest --watchAll
```

## 2. Assertion
<span class="red">단정문</span>이라고 부르는 `Assertion`은 우리가 <span class="blue">기대하는 값이 실제 값이랑 일치하는지 확인</span>하게 된다.  

```jsx
// simple.test.js
test('simple', () => { // 첫 번째 인자는 실행할 테스트의 이름이다.
  // assertion => A(actual)가 B(expect)여야 한다.
  expect(1 + 1).toBe(2);
});
```

## 3. Signature
모든 연산은 연산의 이름, 매개변수, 반환값을 명세한다. 이를 시그니처라고 한다.  

# 2장 TDD 테스트 주도 개발
<span class="red">테스트 주도 개발</span>은 <span class="tomato">테스트가 개발을 주도</span>하는 방법이다.  
테스트가 개발을 주도한다는 것은 <span class="blue">테스트가 코딩의 방향을 이끌어</span> 간다는 말이다.  
테스트가 실패하는 코드가 없으면 코딩을 하지 않고,  
코드상에 중복이 있으면 제거한다는 간단한 규칙을 지켜나가면 자연스레 아름다운 코드가 펼쳐진다.  

## 1. 왜 TDD를 해야 하는가
(테스트 자동화와 Mocha) : [JAVASCRPT.INFO](https://ko.javascript.info/testing-mocha#ref-1068)  

### (1) 테스트는 왜 해야 하는가?
함수 하나를 만들고 있다고 가정하고,  
개발 중엔 <u>콘솔 창 등을 사용</u>하여  
실제 실행 결과가 기대했던 결과와 같은지 비교하면서 원하는 기능이 잘 구현되고 있는지 확인하게 될 것이다.  
그런데 이렇게 <span class="blue">수동으로 "재실행"</span>한다는 것은 <span class="tomato">상당히 불완전</span>하다.  
그리고 코드를 수동으로 재실행하면서 테스트를 한다면 <span class="blue">무언가를 놓치기도 쉽다</span>.  

개발자는 무언가를 만들 때 머릿속에 <span class="blue">수많은 유스 케이스를 생각하며 코드를 작성</span>하는데  
코드를 변경할 때마다 <span class="red">모든 케이스를 생각하며 코드를 수정하는 것은 거의 불가능하다</span>고 할 수 있다.  
하나를 고치면 또 다른 문제가 튀어나오는 것이 바로 이러한 이유이다.  
<span class="red">테스팅 자동화</span>는 테스트 코드가 <span class="tomato">실제 동작에 관여하는 코드와 별개로 작성되었을 때 가능</span>하게 된다.  


## 2. 2가지 간단한 룰
1. 먼저 자동화된 테스트에서 실패하지 않는 한 새로운 코드를 작성하지 않는다.
2. 중복을 제거한다.  

<img src="https://user-images.githubusercontent.com/87808288/184624552-60cec687-4910-490f-bfdb-69d67eb9f62b.png" width="60%">  
TDD에서는 처음에는 통과하지 못할`(RED) 테스트`를 작성하고  
이 테스트를 통과하게끔`(Green) 코드`를 작성하고,  
결과 코드를 `최대한 깔끔하게 리팩터링` 하는 짧은 주기로 반복한다.  

### (1) RED
```jsx
// Item.test.jsx
test('add', () => {
  expect(add(1, 2)).toBe(3);
});
```

add 함수는 아직 <span class="tomato">구현된 코드가 없기에 당연히 테스트에서 실패</span>하게 된다.  
여기서 주의할 점은 <span class="blue">아직 add 함수를 선언하지 않은 점</span>이다.  
<span class="red">테스팅 프레임워크의 에러 메시지를 먼저 확인하는 게 가장 중요</span>하다.  

그러면 이제 아래의 에러 메시지를 만나게 된다.  

```bash
ReferenceError: add is not defined
```

이제 <span class="blue">add 함수를 선언할 때</span>이다.  
<span class="royalblue">절대 스텝을 건너 뛰고 진행하면 안된다</span>.  

```jsx
// Item.test.jsx
function add() {
}

test('add', () => {
  expect(add(1, 3)).toBe(4);
});
```

그러면 아래와 같이 실패하게 된다.  
<span class="royalblue">왜냐하면 add 함수에 내용이 존재하지 않기 때문</span>이다.  

```bash
expect(received).toBe(expected) // Object.is equality

Expected: 4
Received: undefined
```

### (2) Green
<span class="red">Green</span>에서 수단과 방법을 가리지 않고 <span class="blue">가장 빠르게 테스트를 통과시키는 방법</span>은 아래와 같다.  

```jsx
// Item.test.jsx
function add() {
  return 4;
}

test('add', () => {
  expect(add(1, 3)).toBe(4);
});
```

말도 안된다고 생각할 수 있지만 <span class="tomato">TDD에서는 이것은 올바른 방법</span>이다.  

### (3) Refactor
이제 중복을 몰아낼 차례이다.  

```jsx
// Item.test.jsx
function add() {
  return 1 + 3;
}
```

위의 코드에서는 입력값이 바뀔 때마다 return을 계속 수정해주어야 한다.  
이런 중복을 몰아내기 위해 아래와 같이 수정할 수 있다.  

```jsx
// Item.test.jsx
function add(x, y) {
  return x + y;
}
```

위의 코드와 같은 방법으로 중복을 몰아낼 수 있다.  
TDD에서 핵심은 Refactoring 단계이다.  
우리에겐 테스트 코드가 있으니 마음에 들 때까지 얼마든지 코드를 수정해도 문제가 생기지 않는다.  
이 부분에서 Kent Beck이 말한 TDD가 두려움을 조절하는 기술임을 확실하게 느낄 수 있다.  

## 3. BDD 방법론
(테스트 자동화와 Mocha) : [JAVASCRPT.INFO](https://ko.javascript.info/testing-mocha#ref-1068)  

Behavior Driven Development라 불리는 방법론에 대해 알아보자.  
이 방법론은 <u>test</u>, <u>documentation</u>, <u>example</u>를 한데 모아놓은 개념이다.  
### (1) 예시: 거듭제곱 함수와 명세서
x를 n번 곱해주는 함수인 pow(x, n)을 구현하고 있다고 가정해보자.  
(사실 JS에는 거듭제곱 연산자, **가 이미 존재하지만 BDD에 관한 설명을 위해 함수로 만든다.)  

코드를 작성하기 전에 먼저 <span class="royalblue">코드가 무슨 일을 하는지</span> 이를 자연어로 표현해야한다.  
이때 만들어진 산출물을 BDD에선 <span class="royalblue">명세서(specification)</span> 또는 <span class="royalblue">스펙(spec)</span>이라고 부른다.  
명세서에는 아래와 같이 유스 케이스에 대한 자세한 설명과 테스트가 담겨있다.  

```jsx
describe("pow", function() {

  it("주어진 숫자의 n 제곱", function() {
    assert.equal(pow(2, 3), 8);
  });

});
```

`스펙`은 <span class="blue">세 가지 주요 구성 요소</span>로 이루어진다.  
⓵ <span class="forestgreen">describe</span>("title", function() { ... })  
<u>구현하고자 하는 기능에 대한 설명</u>이 들어간다.  

⓶ <span class="forestgreen">it</span>("유스 케이스 설명", function() { ... })  
<span class="tomato">it</span>의 <u>첫 번째 인수</u>엔 <span class="blue">특정 유스 케이스에 대한 설명</span>이 들어간다.  
이 설명은 <span class="blue">누구나 읽을 수 있고 이해할 수 있는 자연어로</span> 적게된다.  
두 번째 인수엔 유스 케이스 테스트 함수가 들어간다.  

⓷ <span class="forestgreen">assert.equal</span>(value1, value2)  
기능을 제대로 구현했다면 it 블록 내의 코드 <span class="darkorange">assert.equal(value1, value2)</span> 이 <u>에러 없이 실행</u>된다.  

### (2) 스펙 실행하기
#### [라이브러리 설명]
- Mocha: 핵심 테스트 프레임워크로, describe it과 같은 테스팅 함수와 테스트 실행 관련 주요 함수 제공
- Chai: 다양한 assertion을 제공해 주는 라이브러리(assert.equal)
- Sinon: 함수의 정보를 캐내는 데 사용하는 라이브러리로, 내장 함수 등을 모방한다.  

코드의 초안을 아래와 같이 작성할 수 있다.  

```jsx
// 코드
function pow(x, n) {
  return 8; // 속임수를 써봤습니다. :)
}
```

### (3) 스펙 개선하기
꼼수를 사용했기 때문에 pow(3,4)를 실행하면 바로 틀린 결과라고 나오게 된다.  
하지만 <u>테스트는 모두 통과하게</u> 된다.  
이러한 결과는 스펙이 불완전해서 그런 것이기에 <span class="blue">더 많은 유스 케이스를 추가해야</span>한다.  

pow(3, 4) = 81을 만족하는지 확인하는 테스트를 추가할 수 있다.  
스펙에 테스트를 추가하는 방법은 아래와 같이 두 가지가 있다.  

⓵ 기존 it 블록에 assert를 하나 더 추가

```jsx
describe("pow", function() {

  it("주어진 숫자의 n 제곱", function() {
    assert.equal(pow(2, 3), 8);
    assert.equal(pow(3, 4), 81);
  });

});
```

⓶ 테스트를 하나 더 추가(it 블록 하나 더 추가하기)

```jsx
describe("pow", function() {

  it("2를 세 번 곱하면 8입니다.", function() {
    assert.equal(pow(2, 3), 8);
  });

  it("3을 네 번 곱하면 81입니다.", function() {
    assert.equal(pow(3, 4), 81);
  });

});
```

<u>assert에서 에러가 발생</u>하면 <span class="royalblue">it 블록은 즉시 종료</span>된다.  
따라서 <span class="blue">기존 it 블록에 assert를 하나 더 추가</span>하면  
첫 번째 assert가 실패했을 때 <span class="tomato">두 번째 assert의 결과를 알 수 없게 된다</span>.  
때문에 두 번째 방법과 같이 <span class="red">it 블록을 추가하여 테스트할 경우 더 많은 정보를 얻을 수 있는 것</span>이다.  

추가로 테스트를 추가할 때 아래의 규칙도 따르는 것이 좋다.  
- <u>테스트 하나에선</u> <span class="blue">한 가지만 확인</span>하기  

테스트 하나에서 연관이 없는 사항 두 개를 점검하고 있다면 이것을 분리하는 것이 좋다.  

### (4) 코드 개선하기
두 번째 테스트에서도 통과할 수 있도록 코드를 개선해야 한다.  

```jsx
// 코드
function pow(x, n) {
  let result = 1;

  for (let i = 0; i < n; i++) {
    result *= x;
  }

  return result;
}
```

함수가 제대로 작동하는지 확인하기 위해 더 많은 값을 테스트하여야 한다.  
<u>수동으로 여러 개의 it 블록을 만드는 대신</u> <span class="royalblue">for 문을 사용하여 자동으로 it 블록을</span> 만들 수 있다.  

```jsx
describe("pow", function() {

  function makeTest(x) {
    let expected = x * x * x;
    it(`${x}을/를 세 번 곱하면 ${expected}입니다.`, function() {
      assert.equal(pow(x, 3), expected);
    });
  }

  for (let x = 1; x <= 5; x++) {
    makeTest(x);
  }
});
```

테스트 결과는 아래의 이미지와 같다.  

<img src="https://user-images.githubusercontent.com/87808288/184849615-7cb3d223-9c50-455f-bfbc-e2c6fd4979db.png" width="70%">  

### (5) 중첩 describe
아래의 코드에서 `헬퍼 함수 makeTest`와 `for 문`이 <span class="blue">중첩 describe 안에 함께 묶여있는 것</span>에 주목해야한다.  
<span class="tomato">makeTest는 오직 for 문에서만 사용</span>되고, 다른 데선 사용되지 않기 때문에 이렇게 묶어놓게 된다.  
아래 스펙에서 makeTest와 for문은 함께 어우러져 pow가 제대로 동작하는지 확인해주는 역할을 한다.  
이렇게 <u>중첩 describe를 사용</u>하면 <span class="blue">그룹을 만들 수 있게</span> 된다.  

```jsx
describe("pow", function() {

  describe("x를 세 번 곱합니다.", function() {

    function makeTest(x) {
      let expected = x * x * x;
      it(`${x}을/를 세 번 곱하면 ${expected}입니다.`, function() {
        assert.equal(pow(x, 3), expected);
      });
    }

    for (let x = 1; x <= 5; x++) {
      makeTest(x);
    }

  });

  // describe와 it을 사용해 이 아래에 더 많은 테스트를 추가할 수 있습니다.
});
```

`중첩 describe`는 새로운 테스트 <span class="blue">"하위 그룹(subgroup)"을 정의</span>할 때 사용된다.  
이렇게 새로 정의된 테스트 하위 그룹은 테스트 결과 보고서에 들여쓰기 된 상태로 출력된다.  
<img src="https://user-images.githubusercontent.com/87808288/184851849-db0251f9-54f3-4632-8938-4fd34c8e870b.png" width="70%">  

#### [before/after와 beforeEach/afterEach]
함수 before는 (전체) 테스트가 실행되기 전에 실행되고,  
함수 after는 (전체) 테스트가 실행된 후에 실행된다.  
함수 beforeEach는 매 it이 실행되기 전에 실행되고,  
함수 afterEach는 매 it이 실행된 후에 실행된다.  

```jsx
describe("test", function() {

  before(() => alert("테스트를 시작합니다 - 테스트가 시작되기 전"));
  after(() => alert("테스트를 종료합니다 - 테스트가 종료된 후"));

  beforeEach(() => alert("단일 테스트를 시작합니다 - 각 테스트 시작 전"));
  afterEach(() => alert("단일 테스트를 종료합니다 - 각 테스트 종료 후"));

  it('test 1', () => alert(1));
  it('test 2', () => alert(2));

});
```

실행 순서는 아래와 같다.  

```bash
테스트를 시작합니다 - 테스트가 시작되기 전          (before)
단일 테스트를 시작합니다 - 각 테스트 시작 전         (beforeEach)
1
단일 테스트를 종료합니다 - 각 테스트 종료 후         (afterEach)
단일 테스트를 시작합니다 - 각 테스트 시작 전         (beforeEach)
2
단일 테스트를 종료합니다 - 각 테스트 종료 후         (afterEach)
테스트를 종료합니다 - 테스트가 종료된 후            (after)
```
before/after와 beforeEach/afterEach는 대게 초기화의 용도로 사용하게 된다.  
카운터 변수를 0으로 만들거나  
테스트가 바뀔 때(또는 테스트 그룹이 바뀔 때)마다 해줘야 하는 작업이 있으면 이들을 이용할 수 있다.  

### (6) 스펙 확장하기
앞서 정의했듯이 함수 pow(x, n)의 매개변수 n은 양의 정수이어햐 했다.  

자바스크립트에선 수학 관련 연산을 수행하다 에러가 발생하면 NaN을 반환한다.  
함수 pow도 n이 조건에 맞지 않으면 NaN을 반환해야 한다.  

n이 조건에 맞지 않을 때 함수가 NaN을 반환하는지를 검사해주는 테스트를 추가하면 아래와 같다.  

```jsx
describe("pow", function() {

  // ...

  it("n이 음수일 때 결과는 NaN입니다.", function() {
    assert.isNaN(pow(2, -1));
  });

  it("n이 정수가 아닐 때 결과는 NaN입니다.", function() {
    assert.isNaN(pow(2, 1.5));
  });

});
```

<img src="https://user-images.githubusercontent.com/87808288/184854058-61d4492b-b276-45e9-8af4-0b155684fa50.png" width="70%">  

기존에 n이 음수이거나 정수가 아닌 경우를 생각하지 않고 구현했기에  
<span class="tomato">새롭게 추가한 테스트는 실패할 수 밖에 없다</span>.  
<span class="red">BDD의 핵심</span>은 바로 그것에 있다.  
<span class="royalblue">실패할 수 밖에 없는 테스트를 추가</span>하고, <span class="blue">테스트를 통과할 수 있게 코드를 개선</span>하는 것이다.  

> 다양한 assertion
위에서 사용한 assert.isNaN은 NaN인지 아닌지 확인한다.  
(Chai) : [assert](https://www.chaijs.com/api/assert/)  
Chai는 이 외에도 다양한 assertion을 지원한다.  
- assert.equal(value1, value2) – value1과 value2의 동등성을 확인합니다(value1 == value2).  
- assert.strictEqual(value1, value2) – value1과 value2의 일치성을 확인합니다(value1 === value2).  
- assert.notEqual, assert.notStrictEqual – 비 동등성, 비 일치성을 확인합니다.  
- assert.isTrue(value) – value가 true인지 확인합니다(value === true).  
- assert.isFalse(value) – value가 false인지 확인합니다(value === false).  

이제 새롭게 추가한 테스트를 통과하기 위해 pow 코드를 수정한다.  

```jsx
// code
function pow(x, n) {
  if (n < 0) return NaN;
  if (Math.round(n) != n) return NaN;

  let result = 1;

  for (let i = 0; i < n; i++) {
    result *= x;
  }

  return result;
}
```

<img src="https://user-images.githubusercontent.com/87808288/184856051-a627eb9a-43fa-47e2-abb0-0f7e9a01b2b1.png" width="70%">  
그러면 위의 이미지와 같이 에러 없이 테스트들을 통과하게 된다.  

# 3장 React testing library
리액트 테스팅 라이브러리는 사용자와 동일한 방식으로 DOM 쿼리를 사용할 수 있게 도와준다.  
실제 사용자가 앱을 사용하는 방식으로 테스트하여 우리의 앱이 올바르게 동작하는지 테스트할 수 있다.  

## 1. 설치
```bash
npm i -D @testing-library/react @testing-library/jest-dom
```

### (1) @testing-library/jest-dom
@testing-library/jest-dom은 jest의 matcher들을 확장하여 테스트의 의도를 명확하게 표현할 수 있다.  

### (2) fireEvent
테스팅에서 DOM 이벤트를 편리하게 발생시켜주는 메서드이다.  
click, change 등의 이벤트를 발생시킬 수 있다.  

### (3) Mocking
mocking은 일부 기능을 테스트할 때 의존 관계를 끊고 독립적으로 테스트할 수 있게 한다.  
`jest.fn()`을 통해서 <span class="blue">함수를 mocking</span> 할 수도 있다.  
Jest에서 제공하는 다양한 mocking 방법이 있다.  

<!-- ⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ -->

<!-- ### 2. Link 넣기

```

유형 1: (설명어를 입력) : [gunhee's coding blog](https://gunhee-jeong.github.io/)
유형 2: (URL 자동연결) : <https://gunhee-jeong.github.io/>
유형 3: (동일 파일 내 '문단으로 이동') : [1. Header로 이동](###-1-header)

```

유형 1: (설명어를 입력) : [gunhee's coding blog](https://gunhee-jeong.github.io/)
유형 2: (URL 자동연결) : <https://gunhee-jeong.github.io/>
유형 3: (동일 파일 내 '문단으로 이동') : [1. Header로 이동](#1-header)
유형 3의 방법

1. 특수문자를 제거
2. 스페이스는 -로 바꾸고
3. 대문자는 소문자로!
   그래서 ### 1. Header -> #1-header

## Link: [google][https://www.google.com/]

### 3. 수평선

```

---

```

---

### 4. 라인 바꾸기

```

스페이스바를 2번 눌러주면 다음칸으로
이동할 수 있어요!

```

---

스페이스바를 2번 눌러주면
다음칸으로 이동할 수 있어요!

### 5. list 만들기

```

1. 1번
2. 2번
3. 3번

- 순서없는 list
  - 순서없는 list
    - 순서없는 list

```

1. 1번
2. 2번
3. 3번

- 순서없는 list
  - 순서없는 list
    - 순서없는 list

---

### 6. font 관련

```

**진하게** -> 볼드
_기울여서_ -> 이탤릭체
~~취소선~~ -> 취소선

<ul>밑줄넣기</ul> -> 밑줄
<span style="color:red">빨간 글씨</span> -> 글자색
이것이 `인라인` 입니다 -> 인라인 코드
```

**진하게** -> 볼드
_기울여서_ -> 이탤릭체
~~취소선~~ -> 취소선
<u>밑줄넣기</u> -> 밑줄
<span style="color:red">빨간 글씨</span>
이것이 `인라인` 입니다 -> 인라인 코드

---

### 7. 인용구문

```
> coding
>
> > JavaScript
> >
> > > 내가 프짱!
```

> coding
>
> > JavaScript
> >
> > > 내가 프짱!

---

### 8. 이미지 삽입

```
유형1: ('사이즈를 조절' -> HTML 태그 사용) : <img src="https://gunhee-jeong.github.io/assets/images/blogLogo.png" width="300" height="200">
유형2: (이미지 삽입 후 -> 링크 걸기)
[![이미지](https://gunhee-jeong.github.io/assets/images/blogLogo/blogLogo.png)](https://gunhee-jeong.github.io/)
```

유형1: ('사이즈를 조절' -> HTML 태그 사용) : <img src="https://gunhee-jeong.github.io/assets/images/blogLogo.png" width="300" height="200">
유형2: (이미지 삽입 후 -> 링크 걸기)
[![이미지](https://gunhee-jeong.github.io/assets/images/blogLogo.png)](https://gunhee-jeong.github.io/)

### 9. 표 만들기

```
||국어|영어|
| :--- | ---: | :--: |
|건희 | 100점 | 100점
|철수 | 100점 | 100점
```

|      |  국어 | 영어  |
| :--- | ----: | :---: |
| 건희 | 100점 | 100점 |
| 철수 | 100점 | 100점 |

> - header를 넣고 싶은 경우 ---을 사용하고 :을 이용하여 정렬에 사용함!

### 10. 토글 만들기

```
<details>
<summary>여기를 누르세요</summary>
<div markdown="1">
숨겨진 내용
</div>
</details>
```

<details>
<summary>여기를 누르세요</summary>
<div markdown="1">
숨겨진 내용
</div>
</details> -->
