---
layout: single
title: "모두의 네트워크 -> 6장 네트워크 계층 : 신뢰할 수 있는 데이터 전송하기"
# categories: Git
categories:
  - network # HTML CSS JavaScript Server Algorithm Wecode Programmers CS vsCode
tag: [모두의 네트워크] #tag는 여러개 가능함
toc: true #table of content 기능!
toc_sticky: true
author_profile: true #blog 글안에서는 author_profile이 따라다니지 않도록 설정함
date: 2022-05-06T22:10:00+09:00   
# sidebar:
# nav: "docs" #네비게이션에 있는 docs를 의미함
---  
# 23장 전송 계층의 역할  
## 1. 전송 계층의 두 가지 역할
다른 네트워크로 데이터를 전송하려면 라우터가 필요하고 -> 라우터의 라우팅 기능을 사용하여 전송할 수 있었다.  
하지만 라우팅 정보가 잘못되어있거나, 많은 라우터를 경유하는 도중에 라우터에 문제가 생기거나 하여서  
라우터의 라우팅 기능을 통해 데이터를 전송하여도 목적지에 도착하지 못하는 일이 발생한다.  

<u>물리 계층, 데이터 링크 계층, 네트워크 계층의 3계층</u>이 있으면 <span style="color:royalblue">목적지에 데이터를 보낼 수 있지만</span>,   
데이터가 손상되거나 유실되더라도 이들 계층에서는 할 수 있는 것이 없다.  

<img src="https://user-images.githubusercontent.com/87808288/177697434-340ab17c-33b2-4211-8b31-848ce44421cc.png" width="400">  
<span style="color:red">전송 계층</span>은 -> <span style="color:blue">목적지에 신뢰할 수 있는 데이터를 전달</span>하기 위해 필요하다.  
전송 계층에는 <span style="color:blue">오류를 점검하는 기능</span>이 있다. 오류가 발생하면 데이터를 재전송하도록 요청한다.  
그리고 전송된 데이터의 `목적지가 어떤 애플리케이션인지 식별하는 기능도` 하고 있다.  

## 2. 연결형 통신과 비연결형 통신
전송 계층의 특징을 간단히 설명하면 신뢰성/ 정확성과 효율성으로 구분할 수 있다.  
신뢰성/ 정확성은 -> 데이터를 목적지에 문제없이 전달하는 것이고, -> (연결형 통신)  
효율성은 -> 데이터를 빠르고 효율적으로 전달하는 것이다. -> (비연결형 통신)  
여기서 신뢰할 수 있고 정확한 데이터를 전달하는 통신을 연결형 통신이라고하고,  
효율적으로 데이터를 전달하는 통신을 비연결형 통신이라고 한다.  

<img src="https://user-images.githubusercontent.com/87808288/177697934-4acb8c4e-22fe-46bd-84b3-eea28c01650c.png" width="600">  
연결형 통신은 -> 상대편과 확인해 가면서 통신하는 방식  
비연결현 통신 -> 상대편을 확인하지 않고 일방적으로 데이터를 전송하는 방식이다.  
<span style="color:red">연결형 통신</span>은 `신뢰성/ 정확성`이 우선인 통신이라서 여러 번 확인하고 보내는 데 반해,  
<span style="color:red">비연결형 통신</span>은 신뢰성과 정확성보다는 `효율성`이 우선인 통신이므로 확인 절차 없이 일방적으로 보내게 된다.  

일반적으로 <span style="color:blue">신뢰성과 정확성이 보장되지 않는 통신</span>은 사용하고 싶지 않은 것이 보통이지만,  
동영상을 볼 때는 비연결형 통신을 사용하게 된다.  
동영상은 신뢰할 수 있고 정확한 데이터 전송보다 빠른 전송이 필요하기 때문이다.  
(동영상의 데이터가 늦게 도착하여 버퍼링이 발생하는 것보다, 데이터가 유실되더라도 원활하게 보는 것을 선호한다.)  

전송 계층의 <span style="color:red">연결형 통신</span> 프로토콜에는 `TCP`가 사용되고, <span style="color:red">비연결형 통신</span> 프로토콜에는 `UDP`가 사용된다.  

# 24장 TCP의 구조
## 1. TCP란?
<span style="color:red">TCP</span>는 `신뢰성`과 `정확성`을 우선으로 하는 <span style="color:blue">연결형 통신 프로토롤</span>이다.  
<img src="https://user-images.githubusercontent.com/87808288/177698421-79e16777-6873-4f24-8c78-bba52c101d7a.png" width="600">  

TCP로 `전송할 때` 붙이는 헤더를 <span style="color:red">TCP 헤더</span>라고하고, 이 <span style="color:blue">TCP 헤더가 붙은 데이터</span>를 <span style="color:red">세그먼트</span>라고 한다.  
<img src="https://user-images.githubusercontent.com/87808288/177698549-4bcb6a07-9f5c-4ed0-b4a9-273f213f433f.png" width="500">  

연결형 통신은 꼼꼼하게 상대방을 확인하면서 데이터를 전송하는데,  
그 데이터를 전송하기 전에 해야 하는 작업이 존재한다.  
데이터를 전송하려면 먼저 <span style="color:blue">연결(connectioin)</span>이라는 <u>가상의 독점 통신로</u>를 확보해야 한다.  

<img src="https://user-images.githubusercontent.com/87808288/177698890-d1a26569-48b1-4a25-8ce5-769103e097f1.png" width="500">  
TCP 헤더의 <span style="color:red">코드 비트</span> 부분 살펴보면 -> 코드 비트는 TCP 헤더의 107번째 비트부터 112번째 비트까지의 6비트로  
연결의 제어 정보가 기록되는 곳이다.  
코드 비트는 각 비트별로 역할이 있는데 -> 초깃값은 0이고 비트가 활성화되면 1이 된다.  
<span style="color:blue">연결을 확립</span>하려면 이 중 `SYN`과 `ACK`가 필요하다.  
SYN(씬)은 연결 요청, ACK(애크)는 확인 응답을 뜻한다.  

## 2. 3-way 핸드셰이크란?
연결은 아래와 같이 <span style="color:blue">SYN</span>과 <span style="color:blue">ACK</span>를 사용하여 확립할 수 있다.  
신뢰할 수 있는 연결을 하려면 데이터를 전송하기 전에 패킷을 교환하는데, 아래와 같이 세 번 확인한다.  
<img src="https://user-images.githubusercontent.com/87808288/177707181-3e8c3c86-ff58-4e02-9e36-9c00ad46cfbf.png" width="500">   

1. 통신을 하려면 컴퓨터 2에게 허가를 받아야 하므로, 먼저 컴퓨터 1에서 컴퓨터 2로 연결 확립 허가를 받기 위한 요청(SYN)을 보냄  
2. 컴퓨터 2는 컴퓨터 1이 보낸 요청을 받은 후에 허가한다는 응답을 회신하기 위해 연결 확립 응답(ACK)을 보냄  
동시에 컴퓨터 2도 컴퓨터 1에게 데이터 전송 허가를 받기 위해 연결 확립 요청(SYN)을 보냄  
3. 컴퓨터 2의 요청을 받은 컴퓨터 1은 컴퓨터 2로 허가한다는 응답으로 연결 확립 응답(ACK)을 보냄  

이때 -> 연결 확립을 위해 코드 비트의 SYN과 ACK가 1로 활성화된다.  
이처럼 데이터를 보내기 전에 <span style="color:blue">연결을 확립하기 위해 패킷 요청을 세 번 교환</span>하는 것을 <span style="color:red">3-way 핸드셰이크</span>라고 한다.  
'핸드셰이크'는 사람들이 상대방을 확인하고 악수를 하는 것처럼 데이터 통신에서도 확실하게 데이터가 전송되었는지  
확인하면서 이루어지는 통신 수단이다.  

데이터를 전송한 후에는 -> 이를 끊기 위한 요청을 교환해야 한다.  
<span style="color:blue">연결을 끊을 때</span>는 `FIN`과 `ACK`를 사용하는데, FIN은 연결 종료를 뜻한다.  
<img src="https://user-images.githubusercontent.com/87808288/167153493-6e61afa2-8434-4b94-a297-f4e1fb086e40.png" width="600">   

1. 컴퓨터 1에서 컴퓨터 2로 연결 종료 요청(FIN)을 보낸다.  
2. 컴퓨터 2에서 컴퓨터 1로 연결 종료 응답(ACK)을 반환한다.  
3. 또한 컴퓨터 2에서도 컴퓨터 1로 연결 종료 요청(FIN)을 보낸다.  
4. 컴퓨터 1에서 컴퓨터 2로 연결 종료 응답(ACK)을 반환한다.  

`연결을 확립`할 때는 <span style="color:red">SYN</span>을 사용하고, `연결을 종료`할 때는 <span style="color:red">FIN</span>을 사용하는 것이다.  
TCP는 신뢰성과 정확성을 중요하게 여기는 프로토콜이므로 상대방이 문제가 없는지 확실히 확인하게 된다.  

# 25장 일련번호와 확인 응답 번호의 구조
## 1. 일련번호와 확인 응답 번호란?
`3-way 핸드셰이크가 끝나고` 실제 데이터를 보내거나 상대방이 받을 때는 <span style="color:red">TCP 헤더의 일련번호</span>와  
<span style="color:red">확인 응답 번호</span>를 사용한다.  
<img src="https://user-images.githubusercontent.com/87808288/167234309-f0a5fcf3-fc1a-4ae7-8fb8-2b45f0cd8d24.png" width="500">  

TCP는 데이터를 분할해 보내는데 `일련번호`는 송신 측에서 수신 측에 '<span style="color:royalblue">이 데이터가 몇 번째 데이터인지</span>' 알려 주는 역할을 한다.  
전송된 데이터에 일련번호를 부여하여 수신자는 원래 데이터의 몇 번째 데이터를 받았는지 알 수 있다.  

확인 응답 번호는 수신 측이 몇 번째 데이터를 수신했는지 송신 측에 알려주는 역할을 한다.  
그래서 이 번호는 다음 번호의 데이터를 요청하는 데도 사용된다.  
예를 들어 10번 데이터를 수신하면 11번 데이터를 송신 측에 요청한다. -> 이것을 확인 응답이라고 한다.  

'3001'번은 지금 보내는 200바이트 데이터의 첫 번째 바이트의 번호고,  
확인 응답 번호는 다음에 보냈으면 하는 데이터의 첫 번째 바이트 번호가 되는 것이다.  
<img src="https://user-images.githubusercontent.com/87808288/177708762-52f48751-fe5f-4b28-868a-6612d884c019.png" width="500">   
위의 그림에서 데이터를 전송하기 전 단계에서 3-way 핸드셰이크 연결 수립이 이루어질 때 -> 이번 통신에 사용하는  
일련번호인 '3001'번과 확인 응답 번호인 '4001'번이 결정된다.  

1. 컴퓨터 1은 컴퓨터 2로 200바이트의 데이터를 전송한다.  
2. 컴퓨터 2는 200바이트를 수신하고 다음에 수신하고자 하는 데이터 번호를 확인 응답 번호로 넣는다.  
다음에 수신하고자 하는 데이터는 3001 + 200 = 3201이므로 3201번부터 보내 달라 요청한다.  
3. 컴퓨터 1은 컴퓨터 2로 3201번부터 200바이트의 데이터를 전송한다.  
4. 컴퓨터 2는 200바이트를 수신하고 다음에 수신하고자 하는 데이터의 번호를 확인 응답 번호에 넣는다.  
다음에 수신하고자 하는 데이터는 3201 + 200 = 3401이므로 3401번부터 보내 달라고 요청한다.  

여기에서 TCP의 특징이 나오는데  
데이터가 항상 올바르게 전달되는 것은 아니므로 -> 일련번호와 확인 응답 번호를 사용해서   
<span style="color:blue">데이터가 손상되거나 유실된 경우에 데이터를 재전송</span>하게 되어 있다. -> 이것을 <span style="color:red">재전송 제어</span>라고 한다.  

## 2. 윈도우 크기란?
데이터를 한 번 보낼 때마다 한 번 응답을 반환하는 방식은 효율이 높지 않다.  
그대신 매번 확인 응답을 기다리는 대신 세그먼트를 연속해서 보내고 난 다음에 확인 응답을 반환하면 효율이 높아진다.  
그리고 받은 `세그먼트를 일시적으로 보관하는 장소`가 있는데 -> 그 장소를 <span style="color:red">버퍼(buffer)</span>라고 한다.  
이 버퍼 덕분에 세그먼트를 연속해서 보내도 수신 측은 대응할 수 있고 확인 응답의 효율도 높아진다.  

하지만 수신 측이 세그먼트를 대량으로 받아서 처리하지 못하는 경우가 생기는데  
<span style="color:blue">수신 측은 대량으로 데이터가 전송되면 보관하지 못하고 넘쳐</span> 버린다. 이것을 <span style="color:red">오버플로(overFlow)</span>라고 한다.  
그래서 오버플로가 발생하지 않도록 `버퍼의 한계 크기를 알고 있어야` 한다.  
그것이 TCP 헤더의 <span style="color:red">윈도우 크기(window size)</span> 값에 해당한다.  
<img src="https://user-images.githubusercontent.com/87808288/177710376-82caf7b6-ac13-410b-88d0-94b4fce292c9.png" width="500">  

윈도우 크기는 <span style="color:blue">얼마나 많은 용량의 데이터를 저장해 둘 수 있는지</span>를 나타내는 것이다.  
즉, 확인 응답을 일일이 하지 않고 연속해서 송수신할 수 있는 데이터 크기이다.  
윈도우 크기의 초기값은 3-way 핸드셰이크를 할 때 판단한다.  
<img src="https://user-images.githubusercontent.com/87808288/177710628-bca962b1-f452-4bdf-95ec-d8460ced4575.png" width="500">  
위의 그림처럼 상대방 버퍼의 한계 값을 알았으면 -> 세그먼트(데이터)를 오버플로되지 않도록 보내면 되는 것이다.  
<img src="https://user-images.githubusercontent.com/87808288/167237807-69bc1925-f2b2-464c-ae20-1c1b39d533a4.png" width="500">  

확인 응답을 기다리지 않고 세그먼트(데이트)를 연속해서 보내면 아래와 같이 통신하게 된다.  
<img src="https://user-images.githubusercontent.com/87808288/167237842-9dff30cf-4c3d-4d35-87c5-8be97c0cec58.png" width="500">  
위의 그림처럼 수신 측이 윈도우 크기를 가지고 있다면 확인 응답을 받지 않고도 세그먼트(데이터)를  
연속적으로 전송할 수 있다.  

# 26장 포트 번호의 구조
## 1. 포트 번호란?
전송 계층에서는 -> 크게 2가지의 역할을 하고 있었는데  
첫 번째는 -> 연결 확립, 재전송 제어, 원도우 제어를 통해 TCP는 데이터를 정확하게 전달할 수 있었다.  
두 번째는 -> 전송된 데이터의 목적지가 어떤 애플리케이션(웹 브라우저나 메일 프로그램 등)인지 구분하는 역할이다.  

목적지가 어떤 애플리케이션인지 구분하지 못하면 사용자가 홈페이지를 보기 위해 웹 브라우저를 사용하는 데도  
메일 프로그램으로 데이터가 전송되는 일이 발생할 수 있다.  
<img src="https://user-images.githubusercontent.com/87808288/177711029-1d2f4bcb-0542-4e97-b508-5f8f6e635b6d.png" width="500">  
그래서 위의 그림에 표시된 TCP 헤더의 출발지 <span style="color:red">포트 번호</span>와 목적지 <span style="color:red">포트 번호</span>가 필요하다.  
TCP 헤더에 포트 번호가 있기 때문에 <span style="color:blue">애플리케이션을 구분할 수 있게 되는 것</span>이다.  

<u>포트번호는 <span style="color:red">0~65535번</span>을 사용</u>할 수 있는데,  
0~1023번 포트는 주로 프로토콜이 사용하도록 예약되어 있다.  
이러한 포트는 <span style="color:blue">잘 알려진 포트(well-known ports)</span>라고 한다.  
<span style="color:red">1024번</span>은 `예약되어 있지만 사용되지는 않는 포트`이고,  
1025번 이상은 랜덤 포트라고해서 클라이언트 측의 송신 포트로 사용된다.   

포트는 원룸 아파트를 비유로 들 수 있다.  
<img src="https://user-images.githubusercontent.com/87808288/167238391-5cf3c27a-6c63-4b90-84d6-e598c0e3bb5a.png" width="500">  
`애플리케이션`을 <u>아파트 주민 A씨, B씨</u>,  
`포트 번호`를 <u>각 방의 번호</u>로 바꿔서 생각하면 이해가 쉽다.  
A씨(애플리케이션)에게 짐(데이터)을 보내려면 방 번호(포트 번호)가 '22'번인 방에 보내면 되는 것이다.  
이처럼 동작하는 애플리케이션은 각각 포트 번호가 있어서 다른 애플리케이션과 서로 구분된다.  

컴퓨터 1의 웹 브라우저로 1025번 포트 번호가 할당되는데  
웹 브라우저로 접속할 때 웹 브라우저에는 임의의 포트가 <span style="color:blue">자동으로 할당</span>된다.  
<img src="https://user-images.githubusercontent.com/87808288/177712953-c6af727b-1d04-4bd5-9b82-f30edce0c977.png" width="600">  

# 27장 UDP의 구조
## 1. UDP란?
TCP는 신뢰할 수 있는 데이터를 상대방에게 전달하는 것을 목적으로 하였다.  
이번에 배우게 되는 <span style="color:red">UDP</span>는 <span style="color:red">비연결형 통신</span>이라서 데이터를 전송할 때 TCP 처럼 시간이 걸리는 확인 작업을 하지 않는다.  
UDP는 TCP와 달리 `효율성을 중요하게 생각`하는 프로토콜이므로  
TCP와 같은 신뢰성과 정확성을 요구하게 되면 효율이 떨어진다.  

UDP의 장점은 <span style="color:red">데이터를 효율적으로 빠르게</span> 보내는 것이므로 ->  
<u>스트리밍 방식으로 전송하는 동영상 서비스와 같은</u> 곳에서 사용하게 된다.  

## 2. UDP 헤더란?
UDP에서 아래의 그림과 같이 `UDP 헤더가 붙은 데이터`를 <span style="color:red">UDP 데이터그램</span>이라고 한다.  
<img src="https://user-images.githubusercontent.com/87808288/167271515-a3dd0c40-00a7-4cdf-97b7-b4cf1dd5e357.png" width="500">  
UDP 헤더는 <u>TCP 헤더와 비교하면</u> -> <span style="color:blue">간결하다고</span> 볼 수 있는데,  
이는 UDP 헤더의 경우 신뢰성과 정확성이 필요하지 않기 때문에 이정도의 정보만으로 충분하기 때문이다.  

아래의 그림에서 TCP의 경우는 번거롭게 여러 번 확인 응답을 보내면서 전송하지만,  
UDP는 효율성과 빠른 속도가 중요해서 상대방을 확인하지 않고 -> 연속해서 데이터를 보내게 된다.  
<img src="https://user-images.githubusercontent.com/87808288/167271605-d265f8af-80fd-44a2-b75c-1f5bef012611.png" width="500">  

또한 UDP를 사용하면 아래의 그림처럼, 같이 <span style="color:blue">랜에 있는 컴퓨터나 네트워크 장비에 데이터를 일괄로 보낼 수</span> 있다.  
이것을 <span style="color:red">브로드캐스트(broadcast)</span>라고 한다.  
<img src="https://user-images.githubusercontent.com/87808288/167271687-19f4c076-18e2-471a-9817-7d1ee048383c.png" width="500">  

<!-- <span style="color:royalblue"> -->

<!-- ### 2. Link 넣기

```

유형 1: (설명어를 입력) : [gunhee's coding blog](https://gunhee-jeong.github.io/)
유형 2: (URL 자동연결) : <https://gunhee-jeong.github.io/>
유형 3: (동일 파일 내 '문단으로 이동') : [1. Header로 이동](###-1-header)

```

유형 1: (설명어를 입력) : [gunhee's coding blog](https://gunhee-jeong.github.io/)
유형 2: (URL 자동연결) : <https://gunhee-jeong.github.io/>
유형 3: (동일 파일 내 '문단으로 이동') : [1. Header로 이동](#1-header)
유형 3의 방법

1. 특수문자를 제거
2. 스페이스는 -로 바꾸고
3. 대문자는 소문자로!
   그래서 ### 1. Header -> #1-header

## Link: [google][https://www.google.com/]

### 3. 수평선

```

---

```

---

### 4. 라인 바꾸기

```

스페이스바를 2번 눌러주면 다음칸으로
이동할 수 있어요!

```

---

스페이스바를 2번 눌러주면
다음칸으로 이동할 수 있어요!

### 5. list 만들기

```

1. 1번
2. 2번
3. 3번

- 순서없는 list
  - 순서없는 list
    - 순서없는 list

```

1. 1번
2. 2번
3. 3번

- 순서없는 list
  - 순서없는 list
    - 순서없는 list

---

### 6. font 관련

```

**진하게** -> 볼드
_기울여서_ -> 이탤릭체
~~취소선~~ -> 취소선

<ul>밑줄넣기</ul> -> 밑줄
<span style="color:red">빨간 글씨</span> -> 글자색
이것이 `인라인` 입니다 -> 인라인 코드
```

**진하게** -> 볼드
_기울여서_ -> 이탤릭체
~~취소선~~ -> 취소선
<u>밑줄넣기</u> -> 밑줄
<span style="color:red">빨간 글씨</span>
이것이 `인라인` 입니다 -> 인라인 코드

---

### 7. 인용구문

```
> coding
>
> > JavaScript
> >
> > > 내가 프짱!
```

> coding
>
> > JavaScript
> >
> > > 내가 프짱!

---

### 8. 이미지 삽입

```
유형1: ('사이즈를 조절' -> HTML 태그 사용) : <img src="https://gunhee-jeong.github.io/assets/images/blogLogo.png" width="300" height="200">
유형2: (이미지 삽입 후 -> 링크 걸기)
[![이미지](https://gunhee-jeong.github.io/assets/images/blogLogo/blogLogo.png)](https://gunhee-jeong.github.io/)
```

유형1: ('사이즈를 조절' -> HTML 태그 사용) : <img src="https://gunhee-jeong.github.io/assets/images/blogLogo.png" width="300" height="200">
유형2: (이미지 삽입 후 -> 링크 걸기)
[![이미지](https://gunhee-jeong.github.io/assets/images/blogLogo.png)](https://gunhee-jeong.github.io/)

### 9. 표 만들기

```
||국어|영어|
| :--- | ---: | :--: |
|건희 | 100점 | 100점
|철수 | 100점 | 100점
```

|      |  국어 | 영어  |
| :--- | ----: | :---: |
| 건희 | 100점 | 100점 |
| 철수 | 100점 | 100점 |

> - header를 넣고 싶은 경우 ---을 사용하고 :을 이용하여 정렬에 사용함!

### 10. 토글 만들기

```
<details>
<summary>여기를 누르세요</summary>
<div markdown="1">
숨겨진 내용
</div>
</details>
```

<details>
<summary>여기를 누르세요</summary>
<div markdown="1">
숨겨진 내용
</div>
</details> -->
