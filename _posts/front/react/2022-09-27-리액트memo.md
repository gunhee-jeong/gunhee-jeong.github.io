---
layout: single
title: "리액트 memo"
# categories: Git
categories:
  - React # HTML CSS JavaScript Server Algorithm Wecodes Programmers CS Github Blog
tag: [React.memo] #tag는 여러개 가능함
toc: true #table of content 기능!
toc_sticky: true
author_profile: true #blog 글안에서는 author_profile이 따라다니지 않도록 설정함
date: 2022-09-27T15:00:00+09:00
# sidebar:
# nav: "docs" #네비게이션에 있는 docs를 의미함
---
<style>
.crimson {
  color: crimson;
  font-weight: bold;
}

.mediumblue {
  color: mediumblue;
  font-weight: bold;
}

.forestgreen {
  color: forestgreen;
  font-weight: bold;
}

.black {
  color: black;
  font-weight: bold;
}
</style>

# 리액트 memo
(Dmitri Pavlntin) : [Use React.memo() wisely](https://dmitripavlutin.com/use-react-memo-wisely/)  
(TOAST UI) : [Use React.memo() 현명하게 사용하기](https://ui.toast.com/weekly-pick/ko_20190731)

> 메모이제이션  
> memoization 은 컴퓨터 프로그래밍이 동일한 계산을 반복해야 할 때, 이전에 계산한 값을 메모리에 저장함으로써 동일한 계산의 반복 수행을 제거하여 프로그램 실행 속도를 빠르게 하는 기술이다.

유저들은 <u>반응이 빠른 UI</u> 를 선호한다. 100ms 미만의 UI 응답 지연은 유저들이 즉시 느낄 수 있고, <span class="forestgreen">100ms 에서 300ms 가 지연되면 유저들은 상당한 지연으로</span> 느낀다.

# 🔴 React.memo()

UI 성능을 증가시키기 위해, React 는 고차 컴포넌트(Higher Order Component, HOC) <span class="crimson">React.memo()</span> 를 제공한다. 렌더링 결과를 메모이징함으로써, <u>불필요한 리렌더링을 건너뛴다</u>.

리액트는 먼저 컴포넌트를 렌더링한 후, <span class="mediumblue">이전 결과와 비교하여 DOM 업데이트를 결정</span>한다. 만약 렌더 결과가 이전과 다르면 리액트는 DOM 을 업데이트한다. 이전 결과와 다음 렌더링 결과의 비교는 빠르지만 이 과정을 좀 더 높일 수 있다.

컴포넌트가 React.memo()로 래핑될 때, 리액트는 컴포넌트를 렌더링하고 결과를 메모이징(Memoizing) 한다. 그리고 다음 렌더링이 일어날 때 props 가 같다면, 리액트는 메모이징된 내용을 재사용한다.

```jsx
export function Movie({ title, releaseDate }) {
  return (
    <div>
      <div>Movie title: {title}</div>
      <div>Release date: {releaseDate}</div>
    </div>
  );
}

export const MemoizedMovie = React.memo(Movie);
```

위의 코드를 살펴보면, <u>function Movie</u> 는 <span class="crimson">React.memo()</span> 로 래핑되어 있다. React.memo(Movie) 는 새로 메모이징된 컴포넌트인 MemoizedMovie 를 반환한다.

```jsx
// SignupForm.jsx
import { memo } from 'react';

export default memo(({ onClick }) => ((
  <form>
    <input
      name="first"
      type="text"
      placeholder="First Name"
    />
    <input
      name="last"
      type="text"
      placeholder="Last Name"
    />
    <input
      type="email"
      placeholder="Email"
    />
    <input
      type="password"
      placeholder="Password"
      autoComplete="off"
    />
    <button type="submit">Sign up</button>
    <p>Passwords must be longer than 7 chars and include numbers</p>
    <button
      type="button"
      onClick={onClick}
    >
      Log In
    </button>
  </form>
)));
```

<u>export const MemoizedMovie = React.memo(Movie);</u> 이런 식으로 <span class="forestgreen">Movie 라는 함수를 이미 선언해놓고 가져올 수도</span> 있지만, 위의 코드와 같이 `export default memo()` 를 <span class="mediumblue">사용함과 동시에 그 안에 화살표 함수를</span> 넣어줄 수 있다. <span class="forestgreen">함수는 일급 객체로 값으로 사용이 가능</span>하기 때문에 위의 코드와 같이 사용이 가능하다.

MemoizedMovie 의 렌더링 결과는 메모이징 되어있다. title 이나 releaseData 와 같은 <u>props 가 변경되지 않는다면</u> <span class="mediumblue">다음 렌더링 때 메모이징 된 내용을 그대로 사용</span>하게 된다. <span class="forestgreen">메모이징 한 결과를 재사용</span>함으로써, 리액트에서 <span class="mediumblue">리렌더링할 때 가상 DOM 에서 달라진 부분을 확인하지 않아 성능상의 이점</span>을 가지게 된다.

```jsx
// 첫 렌더이다. React는 MemoizedMovie 함수를 호출한다.
<MemoizedMovie
  movieTitle="Heat"
  releaseDate="December 15, 1995"
/>

// 다시 렌더링 할 때 React는 MemoizedMovie 함수를 호출하지 않는다.
// 리렌더링을 막는다.
<MemoizedMovie
  movieTitle="Heat"
  releaseDate="December 15, 1995"
/>
```

## 🟠 props 동등 비교 커스터마이징
React.memo() 는 props 혹은 props 의 객체를 비교할 때 <span class="forestgreen">얕은(shallow) 비교</span>를 한다.

비교 방식을 수정하고자 한다면 React.memo() <u>두 번째 매개변수</u>로 <span class="mediumblue">비교함수</span>를 만들어 넘겨주면 된다. `areEqual(prevProps, nextProps) 함수`는 prevProps 와 nextProps 가 같다면 true 를 반환할 것이다.

```jsx
React.memo(Component, [areEqual(prevProps, nextProps)]);
```

areEqual 함수의 동작을 살펴보자면 아래의 코드와 같다.

```jsx
function Movie({ title, releaseDate }) {
  return (
    <div>
      <div>Movie title: {title}</div>
      <div>Release date: {releaseDate}</div>
    </div>
  );
}

function moviePropsAreEqual(prevMovie, nextMovie) {
  return (
    prevMovie.title === nextMovie.title &&
    prevMovie.releaseDate === nextMovie.releaseDate
  );
}

const MemoizedMovie2 = React.memo(Movie, moviePropsAreEqual);
```

# 🔴 React.memo() 를 사용할 때
## 🟠 같은 props 로 렌더링이 자주 일어나는 컴포넌트
React.memo() 를 사용하기 가장 좋은 때는 함수형 컴포넌트가 <span class="crimson">같은 props 로 자주 렌더링 될 때</span>이다. 부모 컴포넌트에 의해 하위의 자식 컴포넌트가 같은 props 로 리렌더링될 떄가 있다. 위에서 살펴본 Movie 컴포넌트를 이용하여 다시 아래의 코드를 살펴보자.

```jsx
function MovieViewsRealtime({ title, releaseDate, views }) {
  return (
    <div>
      <Movie title={title} releaseDate={releaseDate} />
      Movie views: {views}
    </div>
  );
}
```

위의 `MovieViewsRealtime 컴포넌트`는 <u>Movie 컴포넌트의 부모 컴포넌트</u>로 <span class="forestgreen">실시간으로 업데이트되는 영화 조회수</span>를 나타낸다. 이 어플리케이션은 주기적(매초)으로 서버에 데이터를 폴링(Polling)해서 MovieViewsRealtime 컴포넌트의 views 를 업데이트하게 된다. 아래의 코드는 매초마다 렌더링될 때의 예시이다.

```jsx
// Initial render
<MovieViewsRealtime
  views={0}
  title="Forrest Gump"
  releaseDate="June 23, 1994"
/>

// After 1 second, views is 10
<MovieViewsRealtime
  views={10}
  title="Forrest Gump"
  releaseDate="June 23, 1994"
/>

// After 2 seconds, views is 25
<MovieViewsRealtime
  views={25}
  title="Forrest Gump"
  releaseDate="June 23, 1994"
/>

// etc
```

위의 코드에서 <u>views 가 새로운 숫자로 업데이트</u> 될 때마다 <span class="forestgreen">MovieViewsRealtime 컴포넌트 또한 리렌더링</span> 된다. 이때 <span class="mediumblue">Movie 컴포넌트 또한 title 이나 releaseData 가 같음에도 불구하고 리렌더링</span> 된다. 바로 <span class="crimson">이때가 Movie 컴포넌트에 메모이제이션을 적용</span>할 적절한 때이다. MovieViewsRealtime 컴포넌트에 메모이징된 컴포넌트인 MemoizedMovie 컴포넌트를 대신 사용해 성능을 개선할 수 있다. 코드는 아래와 같다.

```jsx
function MovieViewsRealtime({ title, releaseDate, views }) {
  return (
    <div>
      <MemoizedMovie title={title} releaseDate={releaseDate} />
      Movie views: {views}
    </div>
  );
}
```

위의 코드와 같이 title 이나 releaseDate 의 props 가 같다면, 리액트는 MemoizedMovie 컴포넌트를 리렌더링 하지 않을 것이다. 이렇게 MovieViewsRealtime 컴포넌트의 성능을 향상시킬 수 있게 된다.

# 🔴 React.memo() 를 사용하지 말아야 할 때
위에서 언급한 상황들이 아니라면 React.memo() 를 사용할 필요가 없을 가능성이 크다. 성능적인 이점을 얻지 못할 경우 메모이제이션을 사용하지 않는 것이 좋다.

그리고 기술적으로는 가능하지만 클래스 기반의 컴포넌트를 React.memo() 로 래핑하는 것은 적절하지 못하다. 클래스 기반의 컴포넌트에서 메모이제이션이 필요하다면 PureComponent 를 확장하여 사용하거나 shouldComponentUpdate() 메서드를 구현하는 것이 좋다.

# 🔴 React.memo() 와 콜백 함수
함수 객체는 일반 객체와 동일한 비교 원칙을 따른다. 함수 객체는 오직 자신에게만 동일하다.

```js
function sumFactory() {
  return (a, b) => a + b;
}

const sum1 = sumFactory();
const sum2 = sumFactory();

console.log(sum1 === sum2); // => false
console.log(sum1 === sum1); // => true
console.log(sum2 === sum2); // => true
```

위의 sumFactory() 는 팩토리 함수이다. 이 함수는 2가지 숫자를 더해주는 화살표 함수를 반환한다. <span class="forestgreen">함수 sum1</span> 과 <span class="forestgreen">sum2</span> 는 <u>sumFactory 에 의해서 생성된 함수</u>이다. 그러나 <span class="mediumblue">sum1 과 sum2 는 다른 함수 객체</span>이다.

`부모 컴포넌트`가 자식 컴포넌트의 <span class="mediumblue">콜백 함수를 정의</span>한다면, <span class="crimson">새 함수가 암시적으로 생성</span>될 수 있다.

아래의 코드에서 Logout 컴포넌트는 <u>콜백 prop 인 onLogout</u> 을 갖는다.

```jsx
function Logout({ username, onLogout }) {
  return <div onClick={onLogout}>Logout {username}</div>;
}

const MemoizedLogout = React.memo(Logout);
```

함수의 동등성이란 함정 때문에, 메모이제이션을 적용할 때는 콜백을 받는 컴포넌트 관리에 주의해야한다. 리렌더를 할 때 마다 <span class="forestgreen">부모 함수가 다른 콜백 함수의 인스턴스를 넘길 가능성</span>이 있다.

```jsx
function MyApp({ store, cookies }) {
  return (
    <div className="main">
      <header>
        <MemoizedLogout
          username={store.username}
          onLogout={() => cookies.clear()}
        />
      </header>
      {store.content}
    </div>
  );
}
```

위의 코드에서 <u>동일한 username 값이 전달</u>되더라도, `MemoizedLogout` 은 <span class="crimson">새로운 onLogout 콜백 때문에 리렌더링</span>을 하게 된다. 메모이제이션이 중단되게 되는 것이다.

이 문제를 해결하기 위해서는 <span class="mediumblue">onLogout 의 prop 값을 매번 동일한 콜백 인스턴스로 설정</span>해야한다. <span class="crimson">useCallback()</span> 을 이용해서 콜백 인스턴스를 보존할 수 있다. 코드는 아래와 같다.

(공식 문서) : [useCallback](https://reactjs.org/docs/hooks-reference.html#usecallback)

```jsx
const MemoizedLogout = React.memo(Logout);

function MyApp({ store, cookies }) {
  const onLogout = useCallback(() => {
    cookies.clear();
  }, []);
  return (
    <div className="main">
      <header>
        <MemoizedLogout 
          username={store.username} 
          onLogout={onLogout} 
        />
      </header>
      {store.content}
    </div>
  );
}
```

useCallback(() => { cookies.clear() }, []) 는 항상 같은 함수 인스턴스를 반환한다.

React.memo() 는 함수형 컴포넌트에서도 메모이제이션의 장점을 얻게 해주는 훌륭한 도구이다. 다만, 콜백 함수를 prop 으로 사용하는 컴포넌트에서 메모이징을 주의해야한다. 그리고 메모이제이션의 성능상 이점을 측정하기 위해 profiling 을 사용하는 것이 좋다.

(공식 문서) : [Optimizing Performance](https://reactjs.org/docs/optimizing-performance.html#profiling-components-with-the-chrome-performance-tab)

# 🔴 예제
Reviews 컴포넌트는 

<!-- ① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨-->

<!-- ### 2. Link 넣기

```

유형 1: (설명어를 입력) : [gunhee's coding blog](https://gunhee-jeong.github.io/)
유형 2: (URL 자동연결) : <https://gunhee-jeong.github.io/>
유형 3: (동일 파일 내 '문단으로 이동') : [1. Header로 이동](###-1-header)

```

```bash
.next/static
        ├── AbmKMg9BFeVUuJ7lsQ1w8
        ├── chunks                 // 여러 페이지에서 공통으로 사용되는 번들 파일
        │       └──  pages         // 각 페이지의 번들 파일
        ├── runtime                // 웹팩과 next의 런타임과 관련된 번들 파일
        ├── css                    // 애플리케이션의 모든 페이지에 대한 글로벌 CSS 파일
        └── media                  // 정적으로 가져온 이미지 next/image가 여기에 해시 및 복사
        
```

<details>
<summary class="black">코드</summary>
<div markdown="1">

```jsx
// helloWorld!
const hello = 'hi';
```
</div>
</details>

1. 특수문자를 제거
2. 스페이스는 -로 바꾸고
3. 대문자는 소문자로!
   그래서 ### 1. Header -> #1-header

## Link: [google][https://www.google.com/]

### 3. 수평선

```

---

```

---

### 4. 라인 바꾸기

```

스페이스바를 2번 눌러주면 다음칸으로
이동할 수 있어요!

```

---

스페이스바를 2번 눌러주면
다음칸으로 이동할 수 있어요!

### 5. list 만들기

```

1. 1번
2. 2번
3. 3번

- 순서없는 list
  - 순서없는 list
    - 순서없는 list

```

1. 1번
2. 2번
3. 3번

- 순서없는 list
  - 순서없는 list
    - 순서없는 list

---

### 6. font 관련

```

**진하게** -> 볼드
_기울여서_ -> 이탤릭체
~~취소선~~ -> 취소선

<ul>밑줄넣기</ul> -> 밑줄
<span style="color:red">빨간 글씨</span> -> 글자색
이것이 `인라인` 입니다 -> 인라인 코드
```

**진하게** -> 볼드
_기울여서_ -> 이탤릭체
~~취소선~~ -> 취소선
<u>밑줄넣기</u> -> 밑줄
<span style="color:red">빨간 글씨</span>
이것이 `인라인` 입니다 -> 인라인 코드

---

### 7. 인용구문

```
> coding
>
> > JavaScript
> >
> > > 내가 프짱!
```

> coding
>
> > JavaScript
> >
> > > 내가 프짱!

---

### 8. 이미지 삽입

```
유형1: ('사이즈를 조절' -> HTML 태그 사용) : <img src="https://gunhee-jeong.github.io/assets/images/blogLogo.png" width="300" height="200">
유형2: (이미지 삽입 후 -> 링크 걸기)
[![이미지](https://gunhee-jeong.github.io/assets/images/blogLogo/blogLogo.png)](https://gunhee-jeong.github.io/)
```

유형1: ('사이즈를 조절' -> HTML 태그 사용) : <img src="https://gunhee-jeong.github.io/assets/images/blogLogo.png" width="300" height="200">
유형2: (이미지 삽입 후 -> 링크 걸기)
[![이미지](https://gunhee-jeong.github.io/assets/images/blogLogo.png)](https://gunhee-jeong.github.io/)

### 9. 표 만들기

```
||국어|영어|
| :--- | ---: | :--: |
|건희 | 100점 | 100점
|철수 | 100점 | 100점
```

|      |  국어 | 영어  |
| :--- | ----: | :---: |
| 건희 | 100점 | 100점 |
| 철수 | 100점 | 100점 |

> - header를 넣고 싶은 경우 ---을 사용하고 :을 이용하여 정렬에 사용함!

### 10. 토글 만들기
 -->
