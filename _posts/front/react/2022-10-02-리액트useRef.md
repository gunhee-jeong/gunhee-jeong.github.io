---
layout: single
title: "리액트 useRef"
# categories: Git
categories:
  - React # HTML CSS JavaScript Server Algorithm Wecodes Programmers CS Github Blog
tag: [useRef] #tag는 여러개 가능함
toc: true #table of content 기능!
toc_sticky: true
author_profile: true #blog 글안에서는 author_profile이 따라다니지 않도록 설정함
date: 2022-10-01T01:30:00+09:00
# sidebar:
# nav: "docs" #네비게이션에 있는 docs를 의미함
---
<style>
.crimson {
  color: crimson;
  font-weight: bold;
}

.mediumblue {
  color: mediumblue;
  font-weight: bold;
}

.forestgreen {
  color: forestgreen;
  font-weight: bold;
}

.black {
  color: black;
  font-weight: bold;
}
</style>

```jsx
const ref = useRef(value);

{ current: value }

ref.current = 'hello';
ref.current = 'nice';
```

위의 코드와 같이 우리가 초기에 `useRef` 에 넣어준 value 는 <u>current 에 저장</u>된다. 또한 ref 는 언제나 수정이 가능하므로 언제든 바꾸어 줄 수 있다.

useRef 가 사용되는 경우는 크게 2가지로 볼 수 있다. 첫 번째로 useRef 는 useState 와 같이 하나의 값을 저장하는 <span class="crimson">저장공간</span>으로 사용된다. 기본적으로 <u>함수형 컴포넌트</u>는 <span class="forestgreen">state 의 변화로 리렌더링</span>이 진행되고 이로인해 <span class="mediumblue">컴포넌트 내부 변수의 선언</span>이 진행된다. 이때 `ref` 에 value 를 담았다면 리렌더링이 일어나더라도 변수의 선언이 일어나지 않고 이로인해 <span class="mediumblue">변수의 값이 유지</span>된다.

두 번째로 useRef 를 통해 <span class="crimson">DOM 요소에 접근</span>할 수 있다. ref 를 사용하면 input 요소에 접근하여 마우스로 클릭하지 않아도 focus 하여 바로 키보드로 입력값을 작성할 수 있게 할 수도 있다. 

아래의 코드에서 "Ref 올려" 버튼을 클릭해도 <u>화면의 Ref 의 숫자는 올라가지 않고</u> 있다. <span class="forestgreen">사실은 Ref 의 숫자는 올라간 것</span>이 맞지만 <span class="crimson">App 컴포넌트를 리렌더링 시키지 않기 때문</span>이다.

```jsx
import React, { useState, useRef } from 'react';

const App = () => {
  const [count, setCount] = useState(0);
  const countRef = useRef(0);

  console.log(countRef); // countRef.current

  console.log('🎨 렌더링...');

  const increaseCountState = () => {
    setCount(count + 1);
  };

  const increaseCountRef = () => {
    countRef.current = countRef.current + 1;
  };

  return (
    <div>
      <p>State: {count}</p>
      <p>Ref: {countRef.current}</p>
      <button onClick={increaseCountState}>State 올려</button>
      <button onClick={increaseCountRef}>Ref 올려</button>
    </div>
  );
};
```

<img src="https://user-images.githubusercontent.com/87808288/193435913-f85d0d42-af3b-43e9-b14c-8299694a83c8.png" width="30%">

그러다가 다시 <u>"State 올려" 버튼을 클릭</u>하면 위에서 <span class="forestgreen">눌렀던 "Ref 올려" 버튼의 수만큼</span>이 아래의 이미지와 같이 화면에 <span class="mediumblue">다시 리렌더링</span>된다.  
<img src="https://user-images.githubusercontent.com/87808288/193436016-d2eaca4d-884f-4133-a8c1-7b86d1f0f82c.png" width="30%">

그렇다면 이렇게 <u>useRef 를 사용하면서 얻는 장점</u>은 무엇일까 생각할 수 있다. 우리가 만든 웹에서 <span class="forestgreen">엄청나게 자주 바뀌는 state</span> 가 있다고 생각해보자. 그러면 이 state 가 바뀔 때마다 <span class="mediumblue">그만큼 엄청나게 많이 컴포넌트가 리렌더링</span>된다. 그러면 이로인해 <span class="crimson">성능상에 문제</span>가 발생할 수 있다. 이때 useState 가 아닌 `useRef` 를 사용하여 값을 담게 되면 <u>엄청나게 자주 값이 바뀌더라도</u> <span class="crimson">렌더링을 발생시키지 않게</span> 된다.

이제 <span class="forestgreen">일반 변수와 useRef 를 이용하여 만든 변수의 차이</span>를 살펴보자. 아래의 코드에는 <u>let 키워드의 변수 countVar</u> 와 <u>useRef 를 이용하여 만든 변수 countRef</u> 가 있다. "Ref 올려" 버튼과 "Var 올려" 버튼을 클릭해도 컴포넌트의 리렌더링이 발생하지 않으므로 화면의 변화는 없는 것을 볼 수 있다.

```jsx
import React, { useState, useRef } from 'react';

const App = () => {
  const [renderer, setRenderer] = useState(0);
  const countRef = useRef(0);
  let countVar = 0;

  const doRendering = () => {
    setRenderer(renderer + 1);
  };
  
  const increaseRef = () => {
    countRef.current = countRef.current + 1;
    console.log('ref: ', countRef.current);
  };

  const increaseVar = () => {
    countVar = countVar + 1;
    console.log('var: ', countVar);
  };

  return (
    <div>
      <p>Ref: {countRef.current}</p>
      <p>Var: {countVar}</p>
      <button onClick={doRendering}>렌더!</button>
      <button onClick={increaseRef}>Ref 올려</button>
      <button onClick={increaseVar}>Var 올려</button>
    </div>
  );
};
```

그러다가 <u>"렌더!" 버튼을 클릭</u>하면 아래의 이미지와 같이 화면이 리렌더링된다. <span class="forestgreen">Ref 의 경우는 클릭한 수 만큼이 화면에 렌더링</span>이 되었지만 <span class="mediumblue">Var 의 경우는 리렌더링이 되어도 반영되지 못한 것</span>을 알 수 있다.  
<img src="https://user-images.githubusercontent.com/87808288/193436453-cc553d7c-11ce-4f1f-84d6-80c61cbb89b1.png" width="30%">

이제 위의 경우와 같은 일이 발생하는 이유에 대해 설명해보자면, <u>countVar</u> 의 경우는 <span class="forestgreen">컴포넌트가 호출될 때마다 0으로 초기화</span>가 진행된다. 하지만 `countRef` 는 <span class="mediumblue">컴포넌트가 호출되어도 계속 값을 유지</span>한다. 왜냐하면 countRef 의 값은 컴포넌트의 전 생애주기를 통해 유지되기 때문이다. 결과적으로 <span class="crimson">useRef 는 변화는 감지하지만 리렌더링은 일으키지 않는다</span>.

useRef 를 사용하여 <u>특정 DOM 을 선택</u>하는 것도 가능하다. HTML 과 JS 를 사용할 때는 DOM 에 접근하기 위해서 getElementById 나 querySelector 등의 DOM selector 를 사용하게 된다. 리액트에서는 아래의 경우 등에 useRef 를 사용하게 된다.
- 특정 요소의 크기 및 위치를 알아내기 위해서
- 스크롤 바의 위치를 가져오거나 설정하기 위해서
- focus 를 설정하기 위해서
- Video.js 등 HTML5 비디오 관련 라이브러리를 사용하기 위해서
- D3, Chart.js 와 같은 그래프 관련 라이브러리를 사용하기 위해서

input 태그와 버튼이 있는 컴포넌트에서 우리가 버튼을 클릭하면 포커스가 버튼 부분에 남아있게 된다. 이때 버튼을 누르고 나면 input 태그에 포커스가 이동하게 할 때에도 useRef 를 사용하여 진행할 수 있다. 코드는 아래와 같다.

```jsx
import React, { useEffect, useRef } from 'react';

function TestRef() {
  const inputRef = useRef();

  useEffect(() => {
    console.log(inputRef); // {current: input}
    inputRef.current.focus();
  }, []);

  const login = () => {
    alert(`환영합니다 ${inputRef.current.value}`);
    inputRef.current.focus();
  };

  return (
    <div>
      <input ref={inputRef} type="text" placeholder="username" />
      <button type="button" onClick={login}>로그인</button>
    </div>
  );
}

export default TestRef;
```

<!-- ① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨-->

<!-- ### 2. Link 넣기

```

유형 1: (설명어를 입력) : [gunhee's coding blog](https://gunhee-jeong.github.io/)
유형 2: (URL 자동연결) : <https://gunhee-jeong.github.io/>
유형 3: (동일 파일 내 '문단으로 이동') : [1. Header로 이동](###-1-header)

```

```bash
.next/static
        ├── AbmKMg9BFeVUuJ7lsQ1w8
        ├── chunks                 // 여러 페이지에서 공통으로 사용되는 번들 파일
        │       └──  pages         // 각 페이지의 번들 파일
        ├── runtime                // 웹팩과 next의 런타임과 관련된 번들 파일
        ├── css                    // 애플리케이션의 모든 페이지에 대한 글로벌 CSS 파일
        └── media                  // 정적으로 가져온 이미지 next/image가 여기에 해시 및 복사
        
```

<details>
<summary class="black">코드</summary>
<div markdown="1">

```jsx
// helloWorld!
const hello = 'hi';
```
</div>
</details>

1. 특수문자를 제거
2. 스페이스는 -로 바꾸고
3. 대문자는 소문자로!
   그래서 ### 1. Header -> #1-header

## Link: [google][https://www.google.com/]

### 3. 수평선

```

---

```

---

### 4. 라인 바꾸기

```

스페이스바를 2번 눌러주면 다음칸으로
이동할 수 있어요!

```

---

스페이스바를 2번 눌러주면
다음칸으로 이동할 수 있어요!

### 5. list 만들기

```

1. 1번
2. 2번
3. 3번

- 순서없는 list
  - 순서없는 list
    - 순서없는 list

```

1. 1번
2. 2번
3. 3번

- 순서없는 list
  - 순서없는 list
    - 순서없는 list

---

### 6. font 관련

```

**진하게** -> 볼드
_기울여서_ -> 이탤릭체
~~취소선~~ -> 취소선

<ul>밑줄넣기</ul> -> 밑줄
<span style="color:red">빨간 글씨</span> -> 글자색
이것이 `인라인` 입니다 -> 인라인 코드
```

**진하게** -> 볼드
_기울여서_ -> 이탤릭체
~~취소선~~ -> 취소선
<u>밑줄넣기</u> -> 밑줄
<span style="color:red">빨간 글씨</span>
이것이 `인라인` 입니다 -> 인라인 코드

---

### 7. 인용구문

```
> coding
>
> > JavaScript
> >
> > > 내가 프짱!
```

> coding
>
> > JavaScript
> >
> > > 내가 프짱!

---

### 8. 이미지 삽입

```
유형1: ('사이즈를 조절' -> HTML 태그 사용) : <img src="https://gunhee-jeong.github.io/assets/images/blogLogo.png" width="300" height="200">
유형2: (이미지 삽입 후 -> 링크 걸기)
[![이미지](https://gunhee-jeong.github.io/assets/images/blogLogo/blogLogo.png)](https://gunhee-jeong.github.io/)
```

유형1: ('사이즈를 조절' -> HTML 태그 사용) : <img src="https://gunhee-jeong.github.io/assets/images/blogLogo.png" width="300" height="200">
유형2: (이미지 삽입 후 -> 링크 걸기)
[![이미지](https://gunhee-jeong.github.io/assets/images/blogLogo.png)](https://gunhee-jeong.github.io/)

### 9. 표 만들기

```
||국어|영어|
| :--- | ---: | :--: |
|건희 | 100점 | 100점
|철수 | 100점 | 100점
```

|      |  국어 | 영어  |
| :--- | ----: | :---: |
| 건희 | 100점 | 100점 |
| 철수 | 100점 | 100점 |

> - header를 넣고 싶은 경우 ---을 사용하고 :을 이용하여 정렬에 사용함!

### 10. 토글 만들기
 -->
