---
layout: single
title: "리덕스(Redux)"
# categories: Git
categories:
  - React # HTML CSS JavaScript Server Algorithm Wecode Programmers CS Github Blog
tag: [리액트 기초, Flux] #tag는 여러개 가능함
toc: true #table of content 기능!
toc_sticky: true
author_profile: true #blog 글안에서는 author_profile이 따라다니지 않도록 설정함
date: 2022-08-22T22:00:00+09:00
# sidebar:
# nav: "docs" #네비게이션에 있는 docs를 의미함
---
<style>
.crimson {
  color: crimson;
  font-weight: bold;
}

.mediumblue {
  color: mediumblue;
  font-weight: bold;
}

.teal {
  color: teal;
  font-weight: bold;
}

.forestgreen {
  color: foresgreen;
  font-weight: bold;
}
</style>

# 리덕스(Redux)
(Redux 공식문서) : [Redux](https://ko.redux.js.org/)

리덕스를 사용하기 위한 명령어는 아래와 같다.

```bash
npm i redux react-redux
```

<span class="crimson">리덕스</span> 자체는 리액트에 종속적이지 않다. 리덕스 자체는 <span class="mediumblue">상태를 관리하기 위한 라이브러리이</span>고 react-redux 라고 쓰면 react와 redux를 같이 사용할 수 있게 된다.

Redux로 상태 관리를 하는 이유와 그 이점은 아래와 같다.
- 상태 관리는 사실 리액트의 관심사가 아니다.
- App은 <span class="teal">상태가 어떻게 처리되는지 모르게</span> 한다.
- App은 <span class="mediumblue">View가 어떻게 그려지는지만 관심</span>을 갖게 한다.
- App은 상태 관리(store)와 View를 연결만 해준다.
- <u>App은 상태 관리 로직이 어떻게 구현됐는지는 모른다</u>.
- 상태 관리 로직 변경의 영향이 View로 전파되지 않는다.

<img src="https://user-images.githubusercontent.com/87808288/188293264-90b23e80-b56e-4506-b4b2-848e42e62f09.png" width="70%">  
`리덕스`는 <span class="mediumblue">Flux 아키텍처</span>의 구현체로 대형 MVC 애플리케이션에서 나타나는 데이터 간 의존성 이슈, 즉 <span class="crimson">연쇄적인 갱신이 뒤얽혀 데이터의 흐름을 예측할 수 없게</span> 만들었던 문제를 해결하기 위해서 고안되었다.

위의 대표적인 사례로는 2014년 컨퍼런스에서 소개된 `페이스북의 채팅 버그` 사례가 있다. <u>읽지 않은 메시지 상태를 나타내는 카운터</u>를 확인하고 사용자가 메시지를 확인해도 <span class="teal">어느새 숫자가 되살아나면서 사용자를 힘들게 한 버그</span>이다.(메시지를 확인해보아도 새로운 내용은 전혀없다.)

개발자가 버그를 수정해도 잠시 동안은 괜찮은 모습을 보이다가 계속해서 같은 버그가 보고되는 상황이 반복되었다. 그러면서 페이스북 팀은 <span class="teal">설계에 기반한 근복적인 문제</span>가 있다고 판단하게 된다. 그리고 해결책으로 애플리케이션의 데이터가 단방향으로 흐르는 방법을 고안하게 된다. 플럭스 아키텍처의 구현체인 <span class="crimson">리덕스</span>는 <span class="mediumblue">애플리케이션을 위한 상태 컨테이너</span>로써 <span class="crimson">단방향 데이터 흐름</span>을 활용하여 <span class="teal">시스템을 예측 가능하게 만들어서 시스템을 보완</span>하는 역할을 하게 된다.

리덕스를 사용하는 구조에서는 <u>전역 상태</u>를 <span class="mediumblue">전부 하나의 저장소(store) 안에 있는 객체 트리에 저장</span>하며, <u>상태를 변경하는 것</u>은 어떤 일이 일어날지를 서술하는 객체인 <span class="mediumblue">액션(action)</span>을 <span class="mediumblue">내보내는(dispatch)</span> 것이 유일한 방법이다. 그리고 액션이 전체 애플리케이션의 <u>상태를 어떻게 변경할지 명시</u>하기 위해서는 <span class="mediumblue">리듀서(reducer)</span>의 작성이 필요하다.

`리듀서`(reducer)는 <u>변화를 일이키는 함수로써</u> 전달받은 액션을 가지고 <span class="mediumblue">새로운 상태를 만들어 스토어에 전달</span>한다. 이 모든 설계는 데이터가 단방향으로 흐른다는 것을 전제하에 <span class="crimson">데이터의 일관성을 향상</span>시키고 <span class="crimson">버그 발생 원인을 쉽게 파악</span>할 수 있도록 해준다.

## 1장 3가지 원칙
(Redux 공식문서) : [Three Principles](https://redux.js.org/understanding/thinking-in-redux/three-principles)

- 전체 상태값을 하나의 객체에 저장한다.
- 상태값은 불변 객체다.
- 상태값은 순수 함수에 의해서만 변경되어야 한다.

## 2장 구조
### 1. Action
(Redux 공식문서) : [Redux Fundamentals. Part 2: Concepts and Data Flow](https://redux.js.org/tutorials/fundamentals/part-2-concepts-data-flow)

<span class="blue">상태값</span>은 <span class="red">오직 액션 객체에 의해서만 변경되어야</span> 한다.
- type: (string)
- payload(object): {taskTitle}

<span class="red">액션 객체</span>에는 `type`, `payload` 속성으로 구성되는데 <span class="tomato">type</span>은 <u>어떤 액션인지 구별할 수 있는 문자열 값</u>이며 <span class="tomato">payload</span> 안에는 <u>변경할 상태값(불변 객체)이 전달</u>된다. Redux에서 상태값을 수정하는 유일한 방법은 <span class="red">액션 객체와 함께 dispatch 메서드를 호출</span>하는 것이다.

### 2. Reducer
(Redux 공식문서) : [Redux Fundamentals. Part 3: State, Actions, and Reducers](https://redux.js.org/tutorials/fundamentals/part-3-state-actions-reducers)

리덕스에선 <span class="blue">기존 상태를 다른 상태로 변경하는 함수</span>를 `리듀서(reducer)`라고 한다. reducer의 구조는 아래와 같다.

```jsx
function reducer(state, action) {
  // ...

  return state;
}
```

<span class="red">reducer</span>는 <u>이전 상태값</u>과 <u>액션 객체</u>를 입력으로 받아서 새로운 상태값을 만드는 <span class="tomato">순수 함수</span>이다. 순수 함수는 부수 효과(함수 외부의 상태를 변경시키는 것)를 발생시키지 않아야 한다. 순수 함수는 같은 입력값에 대해 항상 같은 값을 반환한다.

<span class="tomato">순수 함수</span>는 동일한 인수가 전달되면 언제나 동일한 값을 반환하는 함수이다. 즉, 순수 함수는 어떤 외부 상태에도 의존하지 않고 <u>오직 매개변수를 통해 함수 내부로 전달된 인수에게만 의존해 값을 생성해 반환</u>한다. 순수 함수는 일반적으로 최소 하나 이상의 인수를 전달받는다. 인수를 전달받지 않는 순수 함수는 언제나 동일한 값을 반환하므로 결국 상수와 마찬가지다. 따라서 최소 하나 이상의 인수를 전달받지 않는 순수 함수는 그다지 의미가 없다. 또한 <span class="royalblue">순수 함수는 인수를 변경하지 않는 것이 기본</span>이다. 다시 말해, <span class="blue">순수 함수는 인수의 불변성을 유지</span>한다.

```jsx
// 예제 12-56 (모던자바스크립트 Deep Dive)
var count = 0; // 현재 카운트를 나타내는 상태

// 순수 함수 increase는 동일한 인수가 전달되면 언제나 동일한 값을 반환한다.
function increase(n) {
  return ++n;
}

// 순수 함수가 반환한 결과값을 변수에 재할당해서 상태를 변경
count = increase(count);
console.log(count); // 1

count = increase(count);
console.log(count); // 2
```

```jsx
// 예제 12-57 (모던자바스크립트 Deep Dive)
var count = 0; // 현재 카운트를 나타내는 상태: increase 함수에 의해 변화한다.

// 비순수 함수
function increase() {
  return ++count; // 외부 상태에 의존하며 외부 상태를 변경한다.
}

// 비순수 함수는 외부 상태(count)를 변경하므로 상태 변화를 추적하기 어려워진다.
increase();
console.log(count); // 1

increase();
console.log(count); // 2
```

### 3. Store
(Redux 공식문서) : [Redux Fundamentals. Part 4: Store](https://redux.js.org/tutorials/fundamentals/part-4-store)

store는 리덕스의 상태값을 갖는 객체이다. 액션의 발생은 store의 dispatch 메서드로 시작된다. 스토어는 액션이 발생하면 미들웨어 함수를 실행하고, reducer를 실행해서 상태값을 새로운 값으로 변경한다. 첫 번째 원칙에서 말한 애플리케이션의 전체 상태값을 저장하는 하나의 객체가 바로 store이다.

### 4. Provider
(React Redux) : [Provider](https://react-redux.js.org/api/provider)

React로 작성된 컴포넌트들을 Provider 안에 넣으면 하위 컴포넌트들이 Porvider를 통해 redux store에 접근이 가능해진다.

### 5. react-redux hook
(박성룡) : [Redux Hook 살펴보기](https://pks2974.medium.com/redux-hook-%EC%82%B4%ED%8E%B4%EB%B3%B4%EA%B8%B0-3b92b4d75466)

Hook 등장 이전에는 mapDispatchToProps, mapStateToProps 와 connet 라는 함수는 이용해서 상당히 많은 코드를 작성해야 했으나 Redux에서도 Hook을 제공하면서 상당히 깔끔한 코드를 작성할 수 있게 되었다. Redux Hook 중 가장 중요한 Hook은 <span class="crimson">useDispatch</span>와 <span class="crimson">useSelector</span>이다.

<!-- ⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ -->

<!-- ### 2. Link 넣기

```

유형 1: (설명어를 입력) : [gunhee's coding blog](https://gunhee-jeong.github.io/)
유형 2: (URL 자동연결) : <https://gunhee-jeong.github.io/>
유형 3: (동일 파일 내 '문단으로 이동') : [1. Header로 이동](###-1-header)

```

유형 1: (설명어를 입력) : [gunhee's coding blog](https://gunhee-jeong.github.io/)
유형 2: (URL 자동연결) : <https://gunhee-jeong.github.io/>
유형 3: (동일 파일 내 '문단으로 이동') : [1. Header로 이동](#1-header)
유형 3의 방법

1. 특수문자를 제거
2. 스페이스는 -로 바꾸고
3. 대문자는 소문자로!
   그래서 ### 1. Header -> #1-header

## Link: [google][https://www.google.com/]

### 3. 수평선

```

---

```

---

### 4. 라인 바꾸기

```

스페이스바를 2번 눌러주면 다음칸으로
이동할 수 있어요!

```

---

스페이스바를 2번 눌러주면
다음칸으로 이동할 수 있어요!

### 5. list 만들기

```

1. 1번
2. 2번
3. 3번

- 순서없는 list
  - 순서없는 list
    - 순서없는 list

```

1. 1번
2. 2번
3. 3번

- 순서없는 list
  - 순서없는 list
    - 순서없는 list

---

### 6. font 관련

```

**진하게** -> 볼드
_기울여서_ -> 이탤릭체
~~취소선~~ -> 취소선

<ul>밑줄넣기</ul> -> 밑줄
<span style="color:red">빨간 글씨</span> -> 글자색
이것이 `인라인` 입니다 -> 인라인 코드
```

**진하게** -> 볼드
_기울여서_ -> 이탤릭체
~~취소선~~ -> 취소선
<u>밑줄넣기</u> -> 밑줄
<span style="color:red">빨간 글씨</span>
이것이 `인라인` 입니다 -> 인라인 코드

---

### 7. 인용구문

```
> coding
>
> > JavaScript
> >
> > > 내가 프짱!
```

> coding
>
> > JavaScript
> >
> > > 내가 프짱!

---

### 8. 이미지 삽입

```
유형1: ('사이즈를 조절' -> HTML 태그 사용) : <img src="https://gunhee-jeong.github.io/assets/images/blogLogo.png" width="300" height="200">
유형2: (이미지 삽입 후 -> 링크 걸기)
[![이미지](https://gunhee-jeong.github.io/assets/images/blogLogo/blogLogo.png)](https://gunhee-jeong.github.io/)
```

유형1: ('사이즈를 조절' -> HTML 태그 사용) : <img src="https://gunhee-jeong.github.io/assets/images/blogLogo.png" width="300" height="200">
유형2: (이미지 삽입 후 -> 링크 걸기)
[![이미지](https://gunhee-jeong.github.io/assets/images/blogLogo.png)](https://gunhee-jeong.github.io/)

### 9. 표 만들기

```
||국어|영어|
| :--- | ---: | :--: |
|건희 | 100점 | 100점
|철수 | 100점 | 100점
```

|      |  국어 | 영어  |
| :--- | ----: | :---: |
| 건희 | 100점 | 100점 |
| 철수 | 100점 | 100점 |

> - header를 넣고 싶은 경우 ---을 사용하고 :을 이용하여 정렬에 사용함!

### 10. 토글 만들기

```
<details>
<summary>여기를 누르세요</summary>
<div markdown="1">
숨겨진 내용
</div>
</details>
```

<details>
<summary>여기를 누르세요</summary>
<div markdown="1">
숨겨진 내용
</div>
</details> -->
