---
layout: single
title: "리덕스(Redux)"
# categories: Git
categories:
  - React # HTML CSS JavaScript Server Algorithm Wecode Programmers CS Github Blog
tag: [리액트 기초, Flux] #tag는 여러개 가능함
toc: true #table of content 기능!
toc_sticky: true
author_profile: true #blog 글안에서는 author_profile이 따라다니지 않도록 설정함
date: 2022-08-22T22:00:00+09:00
# sidebar:
# nav: "docs" #네비게이션에 있는 docs를 의미함
---
<style>
.crimson {
  color: crimson;
  font-weight: bold;
}

.mediumblue {
  color: mediumblue;
  font-weight: bold;
}

.teal {
  color: teal;
  font-weight: bold;
}
</style>

# 리덕스(Redux)
(Redux 공식문서) : [Redux](https://ko.redux.js.org/)

리덕스를 사용하기 위한 명령어는 아래와 같다.

```bash
npm i redux react-redux
```

<span class="crimson">리덕스</span> 자체는 리액트에 종속적이지 않다. 리덕스 자체는 <span class="mediumblue">상태를 관리하기 위한 라이브러리이</span>고 react-redux 라고 쓰면 react와 redux를 같이 사용할 수 있게 된다.

Redux로 상태 관리를 하는 이유와 그 이점은 아래와 같다.
- 상태 관리는 사실 리액트의 관심사가 아니다.
- App은 <span class="teal">상태가 어떻게 처리되는지 모르게</span> 한다.
- App은 <span class="mediumblue">View가 어떻게 그려지는지만 관심</span>을 갖게 한다.
- App은 상태 관리(store)와 View를 연결만 해준다.
- <u>App은 상태 관리 로직이 어떻게 구현됐는지는 모른다</u>.
- 상태 관리 로직 변경의 영향이 View로 전파되지 않는다.

<img src="https://user-images.githubusercontent.com/87808288/188293264-90b23e80-b56e-4506-b4b2-848e42e62f09.png" width="70%">  
`리덕스`는 <span class="mediumblue">Flux 아키텍처</span>의 구현체로 대형 <span class="mediumblue">MVC 애플리케이션</span>에서 나타나는 데이터 간 의존성 이슈, 즉 <span class="crimson">연쇄적인 갱신이 뒤얽혀 데이터의 흐름을 예측할 수 없게</span> 만들었던 문제를 해결하기 위해서 고안되었다.

위의 대표적인 사례로는 2014년 컨퍼런스에서 소개된 `페이스북의 채팅 버그` 사례가 있다. <u>읽지 않은 메시지 상태를 나타내는 카운터</u>를 확인하고 사용자가 메시지를 확인해도 <span class="teal">어느새 숫자가 되살아나면서 사용자를 힘들게 한 버그</span>이다.(메시지를 확인해보아도 새로운 내용은 전혀없다.)

개발자가 버그를 수정해도 잠시 동안은 괜찮은 모습을 보이다가 계속해서 같은 버그가 보고되는 상황이 반복되었다. 그러면서 페이스북 팀은 <span class="teal">설계에 기반한 근복적인 문제</span>가 있다고 판단하게 된다. 그리고 해결책으로 애플리케이션의 데이터가 단방향으로 흐르는 방법을 고안하게 된다. 플럭스 아키텍처의 구현체인 <span class="crimson">리덕스</span>는 <span class="mediumblue">애플리케이션을 위한 상태 컨테이너</span>로써 <span class="crimson">단방향 데이터 흐름</span>을 활용하여 <span class="teal">시스템을 예측 가능하게 만들어서 시스템을 보완</span>하는 역할을 하게 된다.

리덕스를 사용하는 구조에서는 <u>전역 상태</u>를 <span class="mediumblue">전부 하나의 저장소(store) 안에 있는 객체 트리에 저장</span>하며, <u>상태를 변경하는 것</u>은 어떤 일이 일어날지를 서술하는 객체인 <span class="mediumblue">액션(action)</span>을 <span class="mediumblue">내보내는(dispatch)</span> 것이 유일한 방법이다. 그리고 액션이 전체 애플리케이션의 <u>상태를 어떻게 변경할지 명시</u>하기 위해서는 <span class="mediumblue">리듀서(reducer)</span>의 작성이 필요하다.

`리듀서`(reducer)는 <u>변화를 일이키는 함수로써</u> 전달받은 액션을 가지고 <span class="mediumblue">새로운 상태를 만들어 스토어에 전달</span>한다. 이 모든 설계는 데이터가 단방향으로 흐른다는 것을 전제하에 <span class="crimson">데이터의 일관성을 향상</span>시키고 <span class="crimson">버그 발생 원인을 쉽게 파악</span>할 수 있도록 해준다.

# 1장 3가지 원칙
(Redux 공식문서) : [Three Principles](https://redux.js.org/understanding/thinking-in-redux/three-principles)

## 1. 전체 상태값을 하나의 객체에 저장한다
애플리케이션의 `전역 상태`는 <u>단일 store</u> 내의 <span class="crimson">객체 트리</span>에 저장된다.

단일 상태 트리를 사용하면 애플리케이션을 더 쉽게 디버그하거나 검사할 수 있다. 또한 더 빠른 개발 주기를 위해 개발 중인 앱의 상태를 유지할 있다.

```jsx
console.log(store.getState())

/* Prints
{
  visibilityFilter: 'SHOW_ALL',
  todos: [
    {
      text: 'Consider using Redux',
      completed: true,
    },
    {
      text: 'Keep all state in a single tree',
      completed: false
    }
  ]
}
*/
```

## 2. 상태값은 불변 객체다
<u>상태를 변경하는 유일한 방법</u>은 <span class="teal">발생한 일을 발생한 일을 설명</span>하는 <span class="crimson">객체인 action</span>을 보내는 것이다.

이렇게 하면 views나 네트워크 콜백 모두 상태에 직접 사용하지 않는다. 대신 그들은 <span class="mediumblue">상태를 변화시키려는 의도를 표현</span>한다. 모든 변경 사항이 <u>중앙에서 집중</u>되고 <u>엄격한 순서로 발생</u>하기 때문에 조심해야 할 조건들이 사라지게 된다.

```jsx
store.dispatch({
  type: 'COMPLETE_TODO',
  index: 1
})

store.dispatch({
  type: 'SET_VISIBILITY_FILTER',
  filter: 'SHOW_COMPLETED'
})
```

## 3. 상태값은 순수 함수에 의해서만 변경되어야 한다
`리듀서`는 <span class="mediumblue">이전 상태와 동작을 취하고</span> <span class="crimson">다음 상태를 반환하는 순수한 함수</span>일 뿐이다. 이전 상태를 변경하는 대신 새 상태 객체를 반환해야 한다. 단일 리듀서로 시작할 수 있으며 앱이 커짐에 따라 상태 트리의 특정 부분을 관리하는 <u>더 작은 리듀서로 분할할 수</u> 있다.

```jsx
function visibilityFilter(state = 'SHOW_ALL', action) {
  switch (action.type) {
    case 'SET_VISIBILITY_FILTER':
      return action.filter
    default:
      return state
  }
}

function todos(state = [], action) {
  switch (action.type) {
    case 'ADD_TODO':
      return [
        ...state,
        {
          text: action.text,
          completed: false
        }
      ]
    case 'COMPLETE_TODO':
      return state.map((todo, index) => {
        if (index === action.index) {
          return Object.assign({}, todo, {
            completed: true
          })
        }
        return todo
      })
    default:
      return state
  }
}

import { combineReducers, createStore } from 'redux'
const reducer = combineReducers({ visibilityFilter, todos })
const store = createStore(reducer)
```

# 2장 구조
## 1. Action
<span class="teal">상태값</span>은 <span class="crimson">오직 액션 객체에 의해서만 변경되어야</span> 한다.
- type: (string)
- payload(object): {taskTitle}

액션 객체에는 `type`, `payload` 속성으로 구성되는데 <span class="mediumblue">type</span>은 <u>어떤 액션인지 구별할 수 있는 문자열 값</u>이며 <span class="mediumblue">payload</span> 안에는 <u>변경할 상태값(불변 객체)이 전달</u>된다. <span class="crimson">Redux에서 상태값을 수정하는 유일한 방법</span>은 <span class="mediumblue">액션 객체와 함께 dispatch 메서드를 호출</span>하는 것이다.

### (1) Concepts and Data Flow
(Redux 공식문서) : [Redux Fundamentals. Part 2: Concepts and Data Flow](https://redux.js.org/tutorials/fundamentals/part-2-concepts-data-flow)

<u>동일한 상태를 공유하고 사용</u>해야 하는 여러 구성 요소가 있는 경우, 특히 <span class="teal">해당 구성 요소가 애플리케이션의 다른 부분에</span> 있는 경우 <span class="mediumblue">단순성이 무너질 수</span> 있다.

이를 해결하는 한 가지 방법은 <u>컴포넌트에서 공유 상태를 추출</u>하여 컴포넌트 트리 <span class="teal">외부의 중앙 위치에 두는 것</span>이다. 이를 통해 컴포넌트 트리는 큰 view가 되고 모든 구성 요소는 트리의 위치에 관계없이 상태에 액세스하거나 작업을 트리거할 수 있다.

이것은 리덕스의 기본 아이디어이다. 애플리케이션의 전역 상태를 포함하는 중앙 집중식 단일 위치와 <span class="mediumblue">코드를 예측 가능하게</span> 만들기 위해 해당 상태를 업데이트할 때 따라야 할 특정 패턴이다.

### (2) Immutability
Mutable 하다는 것은 변경할 수 있음을 의미한다. 무언가가 불변이면 절대 변경할 수 없다. 자바스크립트 객체와 배열은 기본적으로 모두 변경이 가능하다. 객체를 생성하면 해당 필드의 내용을 변경할 수 있다. 배열을 만들면 내용도 변경할 수 있다.

```jsx
const obj = { a: 1, b: 2 }
// still the same object outside, but the contents have changed
obj.b = 3

const arr = ['a', 'b']
// In the same way, we can change the contents of this array
arr.push('c')
arr[1] = 'd'
```

<u>값을 변경할 수 없도록 업데이트하려면</u> 코드에서 기존 <span class="crimson">객체, 배역의 복사본</span>을 만든 다음 복사본을 수정해야한다.

자바스크립트의 배열, 객체의 <span class="mediumblue">스프레드 연산자</span>와 원래 배열을 변경하는 대신 배열의 새 복사본을 반환하는 배열 메서드를 사용하여 이 작업을 직접 수행할 수 있다.

<span class="crimson">리덕스는 모든 상태 업데이트가 불변적으로 수행</span>되기를 기대한다.

## 2. Reducer
(Redux 공식문서) : [Redux Fundamentals. Part 3: State, Actions, and Reducers](https://redux.js.org/tutorials/fundamentals/part-3-state-actions-reducers)

> "Reducer" 함수는 Array.reduce() 메서드에 전달하는 일종의 콜백 함수와 유사하기 때문에 여기서 이름을 가져왔다. - 리액트 리듀서 공식문서

리덕스에선 <span class="teal">기존 상태를 다른 상태로 변경하는 함수</span>를 `리듀서(reducer)`라고 한다. reducer의 구조는 아래와 같다.

```jsx
function reducer(state, action) {
  // ...

  return state;
}

// (state, action) => newState
```

<span class="crimson">reducer</span>는 <span class="mediumblue">이전 상태값</span>과 <span class="mediumblue">액션 객체</span>를 입력으로 받아서 <span class="mediumblue">새로운 상태값</span>을 만드는 <span class="teal">순수 함수</span>이다. 순수 함수는 부수 효과(함수 외부의 상태를 변경시키는 것)를 발생시키지 않아야 한다. 순수 함수는 같은 입력값에 대해 항상 같은 값을 반환한다.

<span class="crimson">순수 함수</span>는 동일한 인수가 전달되면 언제나 동일한 값을 반환하는 함수이다. 즉, 순수 함수는 어떤 외부 상태에도 의존하지 않고 <u>오직 매개변수를 통해 함수 내부로 전달된 인수에게만 의존해 값을 생성해 반환</u>한다. 순수 함수는 일반적으로 최소 하나 이상의 인수를 전달받는다. 인수를 전달받지 않는 순수 함수는 언제나 동일한 값을 반환하므로 결국 상수와 마찬가지다. 따라서 최소 하나 이상의 인수를 전달받지 않는 순수 함수는 그다지 의미가 없다. 또한 <span class="mediumblue">순수 함수는 인수를 변경하지 않는 것이 기본</span>이다. 다시 말해, <span class="teal">순수 함수는 인수의 불변성을 유지</span>한다.

```jsx
// 예제 12-56 (모던자바스크립트 Deep Dive)
var count = 0; // 현재 카운트를 나타내는 상태

// 순수 함수 increase는 동일한 인수가 전달되면 언제나 동일한 값을 반환한다.
function increase(n) {
  return ++n;
}

// 순수 함수가 반환한 결과값을 변수에 재할당해서 상태를 변경
count = increase(count);
console.log(count); // 1

count = increase(count);
console.log(count); // 2
```

```jsx
// 예제 12-57 (모던자바스크립트 Deep Dive)
var count = 0; // 현재 카운트를 나타내는 상태: increase 함수에 의해 변화한다.

// 비순수 함수
function increase() {
  return ++count; // 외부 상태에 의존하며 외부 상태를 변경한다.
}

// 비순수 함수는 외부 상태(count)를 변경하므로 상태 변화를 추적하기 어려워진다.
increase();
console.log(count); // 1

increase();
console.log(count); // 2
```

리듀서는 <span class="mediumblue">기존 상태를 수정할 수 없다</span>. 대신 <span class="teal">기존 상태를 복사</span>하고 복사된 값을 변경하여 변경할 수 없는 업데이트를 수행해야 한다.

## 3. Store
(Redux 공식문서) : [Redux Fundamentals. Part 4: Store](https://redux.js.org/tutorials/fundamentals/part-4-store)

`store`는 <span class="crimson">리덕스의 상태값을 갖는 객체</span>이다. 액션의 발생은 store의 dispatch 메서드로 시작된다. 스토어는 액션이 발생하면 미들웨어 함수를 실행하고, reducer를 실행해서 상태값을 새로운 값으로 변경한다. 첫 번째 원칙에서 말한 애플리케이션의 전체 상태값을 저장하는 하나의 객체가 바로 store이다.

아래의 Redux 애플리케이션의 <u>state</u>는 <span class="teal">store</span> 라는 객체에 있다. store는 reducer를 전달하여 생성되며 현재 상태 값을 반환하는 getState 라는 메서드가 있다.

```jsx
// store.js
import { configureStore } from '@reduxjs/toolkit'

const store = configureStore({ reducer: counterReducer })

console.log(store.getState())
// {value: 0}
```

### (1) store의 역할
리덕스 스토어는 앱을 구성하는 <u>state, actions 그리고 reducers</u>를 함께 제공한다. 그리고 `store`는 내부에 현재 <span class="crimson">애플리케이션 상태를 유지</span>한다. 리덕스에는 <span class="mediumblue">단일 store</span>만 있다는 점을 유의해야한다. <u>데이터 처리 로직을 분할</u>하려는 경우 별도의 저장소를 만드는 것이 아니라 리듀서를 사용하고 함께 결합할 수 있는 <span class="mediumblue">여러 리듀서를 만들어야</span> 한다.

<span class="mediumblue">store.getState()</span>를 통해 <span class="teal">현재 상태에 대한 액세스를 허용</span>한다.

<span class="mediumblue">store.dispatch()</span>를 통해 <span class="teal">상태를 업데이트</span>할 수 있다.

<span class="mediumblue">store.subscribe(listener)</span>를 통해 <span class="teal">리스너 콜백을 등록</span>한다. 그리고 store.subscribe(listener)에서 반환된 구독 취소 함수를 통해 수신기 등록 취소를 처리한다.

### (2) Inside a Redux Store
아래의 코드는 25줄 정도의 코드로, 리덕스 store를 축소시킨 코드이다.

```jsx
// midiReduxStoreExample.js
function createStore(reducer, preloadedState) {
  let state = preloadedState
  const listeners = []

  function getState() {
    return state
  }

  function subscribe(listener) {
    listeners.push(listener)
    return function unsubscribe() {
      const index = listeners.indexOf(listener)
      listeners.splice(index, 1)
    }
  }

  function dispatch(action) {
    state = reducer(state, action)
    listeners.forEach(listener => listener())
  }

  dispatch({ type: '@@redux/INIT' })

  return { dispatch, subscribe, getState }
}
```

`store`는 <span class="mediumblue">현재 상태 값</span>과 내부에 <span class="mediumblue">리듀서</span> 기능을 가지고 있다.

`getState`는 <span class="mediumblue">현재 상태 값을 반환</span>한다.

`subscribe`는 <u>리스너 콜백 배열을 유지</u>하고 <span class="teal">새 콜백을 제거하는 함수를 반환</span>한다.

`dispatch`는 <span class="mediumblue">리듀서를 호출</span>하고, <span class="teal">상태를 저장</span>하고, <span class="teal">리스너를 실행</span>한다.

### (3) Configuring store
리덕스 store는 스토어 enhancer라는 것을 사용하여 사용자 정의된다. 스토어 enhancer는 원래 리덕스 store를 둘러싸는 다른 레이어를 추가하는 createStore의 특별한 버전이다. 그러면 향상된 store는 원본 대신 자체 버전의 store의 dispatch, getState 및 구독 기능을 제공하여 store의 동작 방식을 변경할 수 있다.

### (4) Enhancer를 사용하여 store 만들기

### (5) Middleware
Enhancers는 dispatch, getState 및 subscribe와 같은 스토어의 메서드를 재정의하거나 대체할 수 있기 때문에 강력하다.

대부분의 경우, 우리는 dispatch가 어떻게 동작하는지를 커스텀화하기만 하면 된다. dispatch가 실행될 때 약간의 맞춤형 동작을 추가할 수 있는 방법이 있다면 좋을 것이다.

리덕스는 middleware라는 특수한 종류의 addon을 사용하여 dispatch 기능을 커스텀화 할 수 있다.

#### Using Middleware
store enhancer를 사용하여 redux store를 커스텀화 할 수 있는 것을 알고 있다. redux middleware는 실제로 apply middleware라고 불리는 redux에 내장된 특별한 store enhancer 위에 구현된다.

```jsx
// store.js
import { createStore, applyMiddleware } from 'redux'
import rootReducer from './reducer'
import { print1, print2, print3 } from './exampleAddons/middleware'

const middlewareEnhancer = applyMiddleware(print1, print2, print3)

// Pass enhancer as the second arg, since there's no preloadedState
const store = createStore(rootReducer, middlewareEnhancer)

export default store
```

middleware는 store의 dispatch method를 중심으로 파이프라인을 형성한다. 우리가 store.dispatch(action)을 호출할 때, 우리는 실제로 파이프라인에서 첫 번째 middleware를 호출하고 있다. 그 middleware는 action을 볼 때 원하는 모든 것을 할 수 있다.

## 4. Provider
(React Redux) : [Provider](https://react-redux.js.org/api/provider)

React로 작성된 컴포넌트들을 Provider 안에 넣으면 하위 컴포넌트들이 Porvider를 통해 redux store에 접근이 가능해진다.

## 5. react-redux hook
(박성룡) : [Redux Hook 살펴보기](https://pks2974.medium.com/redux-hook-%EC%82%B4%ED%8E%B4%EB%B3%B4%EA%B8%B0-3b92b4d75466)

Hook 등장 이전에는 mapDispatchToProps, mapStateToProps 와 connet 라는 함수는 이용해서 상당히 많은 코드를 작성해야 했으나 Redux에서도 Hook을 제공하면서 상당히 깔끔한 코드를 작성할 수 있게 되었다. Redux Hook 중 가장 중요한 Hook은 <span class="crimson">useDispatch</span>와 <span class="crimson">useSelector</span>이다.

<img src="https://user-images.githubusercontent.com/87808288/188298034-da0537d7-863d-4103-92df-e1b33743b791.gif" width="70%">  
UI가 처음 렌더링될 때, UI 컴포넌트는 리덕스 스토어의 상태에 접근하여 해당 상태를 렌더링한다. 이후 <u>UI에서 상태가 변경</u>되면, <span class="teal">앱은 디스패치를 실행해 액션을 일으킨다</span>. <u>새로운 액션을 받은 스토어</u>는 <span class="teal">리듀서를 실행</span>하고 리듀서를 통해 나온 값을 새로운 상태로 저장한다. 서브스크라이브된 UI는 상태 업데이트로 변경된 데이터를 새롭게 렌더링한다.

### (1) useDispatch
디스패치는 스토어의 내장 함수 중 하나이며, 액션 객체를 넘겨줘 상태를 업데이트 시켜주는 역할을 한다.

<!-- ⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ -->

<!-- ### 2. Link 넣기

```

유형 1: (설명어를 입력) : [gunhee's coding blog](https://gunhee-jeong.github.io/)
유형 2: (URL 자동연결) : <https://gunhee-jeong.github.io/>
유형 3: (동일 파일 내 '문단으로 이동') : [1. Header로 이동](###-1-header)

```

유형 1: (설명어를 입력) : [gunhee's coding blog](https://gunhee-jeong.github.io/)
유형 2: (URL 자동연결) : <https://gunhee-jeong.github.io/>
유형 3: (동일 파일 내 '문단으로 이동') : [1. Header로 이동](#1-header)
유형 3의 방법

1. 특수문자를 제거
2. 스페이스는 -로 바꾸고
3. 대문자는 소문자로!
   그래서 ### 1. Header -> #1-header

## Link: [google][https://www.google.com/]

### 3. 수평선

```

---

```

---

### 4. 라인 바꾸기

```

스페이스바를 2번 눌러주면 다음칸으로
이동할 수 있어요!

```

---

스페이스바를 2번 눌러주면
다음칸으로 이동할 수 있어요!

### 5. list 만들기

```

1. 1번
2. 2번
3. 3번

- 순서없는 list
  - 순서없는 list
    - 순서없는 list

```

1. 1번
2. 2번
3. 3번

- 순서없는 list
  - 순서없는 list
    - 순서없는 list

---

### 6. font 관련

```

**진하게** -> 볼드
_기울여서_ -> 이탤릭체
~~취소선~~ -> 취소선

<ul>밑줄넣기</ul> -> 밑줄
<span style="color:crimson">빨간 글씨</span> -> 글자색
이것이 `인라인` 입니다 -> 인라인 코드
```

**진하게** -> 볼드
_기울여서_ -> 이탤릭체
~~취소선~~ -> 취소선
<u>밑줄넣기</u> -> 밑줄
<span style="color:crimson">빨간 글씨</span>
이것이 `인라인` 입니다 -> 인라인 코드

---

### 7. 인용구문

```
> coding
>
> > JavaScript
> >
> > > 내가 프짱!
```

> coding
>
> > JavaScript
> >
> > > 내가 프짱!

---

### 8. 이미지 삽입

```
유형1: ('사이즈를 조절' -> HTML 태그 사용) : <img src="https://gunhee-jeong.github.io/assets/images/blogLogo.png" width="300" height="200">
유형2: (이미지 삽입 후 -> 링크 걸기)
[![이미지](https://gunhee-jeong.github.io/assets/images/blogLogo/blogLogo.png)](https://gunhee-jeong.github.io/)
```

유형1: ('사이즈를 조절' -> HTML 태그 사용) : <img src="https://gunhee-jeong.github.io/assets/images/blogLogo.png" width="300" height="200">
유형2: (이미지 삽입 후 -> 링크 걸기)
[![이미지](https://gunhee-jeong.github.io/assets/images/blogLogo.png)](https://gunhee-jeong.github.io/)

### 9. 표 만들기

```
||국어|영어|
| :--- | ---: | :--: |
|건희 | 100점 | 100점
|철수 | 100점 | 100점
```

|      |  국어 | 영어  |
| :--- | ----: | :---: |
| 건희 | 100점 | 100점 |
| 철수 | 100점 | 100점 |

> - header를 넣고 싶은 경우 ---을 사용하고 :을 이용하여 정렬에 사용함!

### 10. 토글 만들기

```
<details>
<summary>여기를 누르세요</summary>
<div markdown="1">
숨겨진 내용
</div>
</details>
```

<details>
<summary>여기를 누르세요</summary>
<div markdown="1">
숨겨진 내용
</div>
</details> -->
