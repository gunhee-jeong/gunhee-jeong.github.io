---
layout: single
title: "리액트 무한 스크롤"
# categories: Git
categories:
  - React # HTML CSS JavaScript Server Algorithm Wecodes Programmers CS Github Blog
tag: [Infinity Scroll] #tag는 여러개 가능함
toc: true #table of content 기능!
toc_sticky: true
author_profile: true #blog 글안에서는 author_profile이 따라다니지 않도록 설정함
date: 2022-10-01T19:30:00+09:00
# sidebar:
# nav: "docs" #네비게이션에 있는 docs를 의미함
---
<style>
.crimson {
  color: crimson;
  font-weight: bold;
}

.mediumblue {
  color: mediumblue;
  font-weight: bold;
}

.forestgreen {
  color: forestgreen;
  font-weight: bold;
}

.black {
  color: black;
  font-weight: bold;
}
</style>

# 리액트 무한 스크롤
<u>scrollTop 과 clientHeight 를 합친 값</u>이 <span class="crimson">scrollHeight 보다 크거나 같다면</span>, 스크롤이 페이지의 끝에 닿았다고 판단하여 페이지에 새로운 데이터를 load 하는 원리로 무한 스크롤을 구현하게 된다.

# 🔴 무한 스크롤을 기본 개념
## 🟠 scrollHeight
scrollHeight 는 요소의 스크롤 높이를 반환하는 HTML 속성이다.

scrollHeight 프로퍼티는 clientHeight 와 유사한데, <span class="mediumblue">스크롤바에 의해 감쳐진 영역도 포함</span>한다는 점에서 차이가 있다.

```html
<!DOCTYPE html>
<html>
<head>
<style>
#elem {
  height: 5000px;
  padding: 10px;
  background-color: yellow;
}
</style>
</head>
<body>

<p>Get the Height of the DIV by clicking the button</p>

<button onclick="change()">Click me</button>

<div id="elem">
  Anything is possible!!!
</div>

<script>
function change() {
  var elmnt = document.getElementById("elem");
  var txt = elmnt.scrollHeight;
  console.log(txt,"px");
}
</script>

</body>
</html>
```

<img src="https://user-images.githubusercontent.com/87808288/193407138-8440cec8-2deb-42b5-a624-c937cb938f65.png" width="70%">

위의 코드의 결과로 5020px 을 얻을 수 있다. height 는 padding 도 포함하므로 div(5000px) + 상단 및 하단의 padding(10px + 10px)으로 5020px 을 얻을 수 있다.

## 🟠 scrollTop
scrollTop 속성은 <u>스크롤된 픽셀 수</u>를 반환한다. 따라서 scrollTop 은 <span class="forestgreen">이미 스크롤되어서 보이지 않는 구간의 높이</span>라고 할 수 있다. 요소의 스크롤 높이는 CSS 속성에 할당된 높이와 패딩을 포함하지만 여백, 테두리 또는 스크롤바는 포함하지 않는다.

## 🟠 clientHeight
clientHeight 는 padding 은 포함하지만 테두리, 여백 및 수평 스크롤바를 제외한 height 이다.

<img src="https://user-images.githubusercontent.com/87808288/193407442-699d7b2a-60aa-473c-be88-60c68be117e9.png" width="60%">

## 🟠 scroll 이벤트의 감지
### 🟡 event listener
event listener 를 감지하는 event listener 를 등록하여 스크롤이 끝에 닿았을 경우 데이터를 가져오는 방식이다.

```jsx
const scroll = e => {
  if (document.body.offsetHeight < e.target.scrollTop + 200) {
    console.log('scroll 로 인한 이벤트 시작');
    dispatch(getDataFromApi(pageCount));
    dispatch(getPageData(pageCount));
  }
};

return ()
```

# 🔴 Intersection Observer API
<!-- (Yoon's devlog) : [Intersection Observer API의 사용법과 활용방법](https://velog.io/@yejinh/Intersection-Observer%EB%A1%9C-%EB%AC%B4%ED%95%9C-%EC%8A%A4%ED%81%AC%EB%A1%A4-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0) -->
(호두 아빠는 오늘도 코딩을 하지) : [used by Intersection Observer - 2](https://velog.io/@yunsungyang-omc/React-%EB%AC%B4%ED%95%9C-%EC%8A%A4%ED%81%AC%EB%A1%A4-%EA%B8%B0%EB%8A%A5-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0-used-by-Intersection-Observer-2)

Intersection Observer API 를 사용하여 <span class="forestgreen">타겟으로 삼은 요소를 관찰</span>해 <u>특정한 조건이 되면 데이터를 가져오는</u> 방식이다. Intersection Observer API 는 타겟 요소가 조상 요소 또는 최상위 document 의 viewport(브라우저에서는 보통 브라우저의 viewport) 의 교차영역에서 발생하는 변화를 비동기로 관찰하는 방법을 제공한다.

## 🟠 기존 scroll 이벤트의 문제
일반적으로 Intersection Observer API 를 사용하지 않으면 debounce 와 throttle 을 사용하여 스크롤 이벤트시 발생하는 불필요한 함수 호출을 컨트롤해야한다. 이것들을 사용하지 않고 스크롤 이벤트를 구현하면 위아래로 스크롤을 할 때마다 event listener 가 필요 이상으로 과다 호출되기 때문이다.

또한 스크롤 이벤트에서는 현재의 높이 값을 알기 위해 offsetTop 을 사용하는데, 정확한 값을 가져오기 위해 매번 layout 을 새로 그리게 되는 reflow 가 발생하게 된다. 이런 부분들을 보완하기 위해 Intersection Observer API 를 사용하는 것이 좋다.

### 🟡 사용 방법
```jsx
// 타겟 요소 관측 시, 실행될 콜백 함수
const callback = (entries, observer) => {
  console.log('콜백함수');
};

// Observer 선언
const observer = new IntersectionObserver(callback, options);

// 타겟 요소 관측 시작
observer.observe(TargetElement);

// 타겟 요소 관측 중단
observer.unobserve(TargetElement);

// 모든 요소 관측 중단
observer.disconnect();

// 관측 중인 모든 요소를 배열 형태로 반환
observer.takeRecords();
```

`callback` 은 관찰이 시작되는 시점에서 실행되는 함수로 <u>2개의 매개변수</u>를 가진다.
- entries: IntersectionObserverEntry 객체들을 배열로 반환
- observer: IntersectionObserver instance

option 는 관찰이 시작되는 상황에 대해 옵션을 설정할 수 있다. 아래의 option 코드는 default 값으로만 구성된 option 객체이다.

```jsx
const option = {
  root: null,
  rootMargin: 0px, 0px, 0px, 0px,
  threshold: 0,
}
```

위의 코드에서 root(viewport) 는 타겟 요소와 교차 영역을 정의하기 위해 사용하는 상위 요소 프로퍼티이다. 값을 넣지 않거나 null 일 경우에는 브라우저의 viewport 가 root 로 지정된다.

rootMargin 은 root 요소에 적용되는 margin 값을 정의하기 위한 프로퍼티로 지정한 값만큼 교차 영역이 계산되며 root 의 범위가 축소된다.

threshold 는 콜백 함수를 실행시키기 위한 root 영역과 타겟 요소와의 교차 영역 비율을 지정하는 프로퍼티이다. 0.0 ~ 1.0 사이의 값을 지정하게 되며, 값이 0이라면 타겟 요소가 교차 영역에 진입했을 때를 의미하고 0.5 라면 타겟 요소의 절반이 교차영역에 들어왔을 때, 1.0 이라면 완전히 교차 영역에 진입했을 때 콜백 함수가 실행된다.

### 🟡 코드 살펴보기
Intersection Observer API 를 사용하여 화면에 띄어준 콘텐츠 중에 맨 마지막 요소를 관측하여 콜백 함수를 실행하는 원리로 무한 스크롤을 구현하게 된다.

타겟이 관측되면 실행되는 콜백 함수 내에서 해당 요소에 대한 관측을 중지하고, 새로운 콘텐츠를 리스트에 추가하게 된다. 그리고 다시 마지막 콘텐츠에 대해 관측을 시작하게 된다. (list 요소의 가장 아래에 빈 div 요소를 생성하고, 그 요소에 ref 를 달아서 교차시점을 확인할 수 있다.)

#### 🟢 1. 관찰자를 생성한다
```jsx
const defaultOption = {
  root: null,
  threshold: 0.5,
  rootMargin: '0px'
};

const observer = new IntersectionObserver(checkIntersect, {
        ...defaultOption,
        ...option
      }
```

위의 코드에서 callback 함수 checkInteresct 는 target 을 주시하는 역할을 하고, 두 번째 매개변수로 defaultOption 이라는 객체값을 넘김으로 교차 공간에 대한 프로퍼티를 전달해주었다.

#### 🟢 2. 관찰대상 지정해주기
```jsx
return (
    <Wrap>
      <Nav>
        ...
      </Nav>
      <ul>
        ...
      </ul>
      {isLoaded && <p ref={setRef}>Loading...</p>}
    </Wrap>
```

#### 🟢 3. 관찰자 만들기
```jsx
const checkIntersect = useCallback(([entry], observer) => {
    if (entry.isIntersecting) {
      onIntersect(entry, observer);
    }
  }, []);
```

관찰 대상이 하나이므로 콜백 함수의 인자로 들어오는 [entry] 와 observer 를 매개변수로 전달해주었다. 그리고 entry 의 속성인 isIntersecting 을 이용해 조건을 검사하고, 조건에 해당하면 콜백 함수를 실행한다.(isIntersecting 은 관찰 대상의 교차 상태를 boolean 값으로 반환한다.)

이렇게 관찰자, 관찰 대상, 조건, 콜백 함수를 만들었지만, 관찰 대상은 새로운 데이터를 가져올 때마다 변해야 한다. 이를 위해 useEffect 를 사용할 수 있다.  
1. 스크롤을 내린다.
2. 관찰 대상을 만나고, 조건을 만족시킨다.
3. 새로운 데이터를 가져온다. 매개변수로 함께 boolean 값을 넘겨서 관찰 대상이 사라지도록 한다.
4. 새로운 데이터를 리스트에 추가한다. loading 이 다시 false 되었기 때문에 관찰 대상이 다시 렌더링된다.

위의 설명은 아래의 코드와 같다.

```jsx
  useEffect(() => {
    let observer; // (1)obeserver 변수를 선언해주고
    if (ref) { // (2) 관찰대상이 존재하는지 체크한다.
      observer = new IntersectionObserver(checkIntersect, { 
        ...defaultOption,
        ...option
      }); // (3) 관찰대상이 존재한다면 관찰자를 생성한다.
      observer.observe(ref); // (4) 관찰자에게 타겟을 지정한다.
    }
    return () => observer  && observer.disconnect(); // 의존성에 포함된 값이 바뀔때 관찰을 중지한다.
  }, [ref, option.root, option.threshold, option.rootMargin, checkIntersect]);
```

```jsx
import { useState, useEffect, useCallback } from 'react';
//  옵션 값을 지정한다.
const defaultOption = {
  root: null,
  threshold: 0.5,
  rootMargin: '0px'
};
//  커스텀 훅 부분
// 관찰 대상을 지정할 수 있도록 ref값을 useState 훅을 이용해 state로 관리해준다.
// 관찰자를 만들어준다.
const useIntersect = (onIntersect, option) => {
  const [ref, setRef] = useState(null);
  const checkIntersect = useCallback(([entry], observer) => {
    if (entry.isIntersecting) {
      onIntersect(entry, observer);
    }
  }, []);
// 관찰자가 언제 관찰하는지, 관찰을 종료하는지에 대해 로직을 구현해준다.
  useEffect(() => {
    let observer;
    if (ref) {
      observer = new IntersectionObserver(checkIntersect, {
        ...defaultOption,
        ...option
      });
      observer.observe(ref);
    }
    return () => observer  && observer.disconnect();
  }, [ref, option.root, option.threshold, option.rootMargin, checkIntersect]);
  return [ref, setRef];
}

export default useIntersect;
```

```jsx
import useIntersect from '../utils/useIntersect';

const Lists = () => {
  const dispatch = useDispatch();

  const { apiData, isLoaded, pageCount } = useSelector(state => ({
    apiData: state.apiData.data,
    isLoaded: state.apiData.isLoaded,
    pageCount: state.pageReducer.pageCount,
  }));

  const page = useRef(pageCount);

  useEffect(() => {
    dispatch(getDataFromApi(pageCount, true));
    dispatch(getPageData(page.current));
  }, []);

  const [_, setRef] = useIntersect(async(entry, observer) => {
    observer.unobserve(entry.target);
    await dispatch(getPageData(page.current++));
    await dispatch(getDataFromApi(page.current, true));
    observer.observe(entry.target);
  }, {});

  return (
    <Wrap>
      <Nav>
    	...
      </Nav>
      <ul>
        {apiData.map((item, idx) => {
          ...
        })}
      </ul>
      {isLoaded && <p ref={setRef}>Loading...</p>}
    </Wrap>
  );
};
```

<!-- ① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨-->

<!-- ### 2. Link 넣기

```

유형 1: (설명어를 입력) : [gunhee's coding blog](https://gunhee-jeong.github.io/)
유형 2: (URL 자동연결) : <https://gunhee-jeong.github.io/>
유형 3: (동일 파일 내 '문단으로 이동') : [1. Header로 이동](###-1-header)

```

```bash
.next/static
        ├── AbmKMg9BFeVUuJ7lsQ1w8
        ├── chunks                 // 여러 페이지에서 공통으로 사용되는 번들 파일
        │       └──  pages         // 각 페이지의 번들 파일
        ├── runtime                // 웹팩과 next의 런타임과 관련된 번들 파일
        ├── css                    // 애플리케이션의 모든 페이지에 대한 글로벌 CSS 파일
        └── media                  // 정적으로 가져온 이미지 next/image가 여기에 해시 및 복사
        
```

<details>
<summary class="black">코드</summary>
<div markdown="1">

```jsx
// helloWorld!
const hello = 'hi';
```
</div>
</details>

1. 특수문자를 제거
2. 스페이스는 -로 바꾸고
3. 대문자는 소문자로!
   그래서 ### 1. Header -> #1-header

## Link: [google][https://www.google.com/]

### 3. 수평선

```

---

```

---

### 4. 라인 바꾸기

```

스페이스바를 2번 눌러주면 다음칸으로
이동할 수 있어요!

```

---

스페이스바를 2번 눌러주면
다음칸으로 이동할 수 있어요!

### 5. list 만들기

```

1. 1번
2. 2번
3. 3번

- 순서없는 list
  - 순서없는 list
    - 순서없는 list

```

1. 1번
2. 2번
3. 3번

- 순서없는 list
  - 순서없는 list
    - 순서없는 list

---

### 6. font 관련

```

**진하게** -> 볼드
_기울여서_ -> 이탤릭체
~~취소선~~ -> 취소선

<ul>밑줄넣기</ul> -> 밑줄
<span style="color:red">빨간 글씨</span> -> 글자색
이것이 `인라인` 입니다 -> 인라인 코드
```

**진하게** -> 볼드
_기울여서_ -> 이탤릭체
~~취소선~~ -> 취소선
<u>밑줄넣기</u> -> 밑줄
<span style="color:red">빨간 글씨</span>
이것이 `인라인` 입니다 -> 인라인 코드

---

### 7. 인용구문

```
> coding
>
> > JavaScript
> >
> > > 내가 프짱!
```

> coding
>
> > JavaScript
> >
> > > 내가 프짱!

---

### 8. 이미지 삽입

```
유형1: ('사이즈를 조절' -> HTML 태그 사용) : <img src="https://gunhee-jeong.github.io/assets/images/blogLogo.png" width="300" height="200">
유형2: (이미지 삽입 후 -> 링크 걸기)
[![이미지](https://gunhee-jeong.github.io/assets/images/blogLogo/blogLogo.png)](https://gunhee-jeong.github.io/)
```

유형1: ('사이즈를 조절' -> HTML 태그 사용) : <img src="https://gunhee-jeong.github.io/assets/images/blogLogo.png" width="300" height="200">
유형2: (이미지 삽입 후 -> 링크 걸기)
[![이미지](https://gunhee-jeong.github.io/assets/images/blogLogo.png)](https://gunhee-jeong.github.io/)

### 9. 표 만들기

```
||국어|영어|
| :--- | ---: | :--: |
|건희 | 100점 | 100점
|철수 | 100점 | 100점
```

|      |  국어 | 영어  |
| :--- | ----: | :---: |
| 건희 | 100점 | 100점 |
| 철수 | 100점 | 100점 |

> - header를 넣고 싶은 경우 ---을 사용하고 :을 이용하여 정렬에 사용함!

### 10. 토글 만들기
 -->
