---
layout: single
title: "리액트 페이지네이션"
# categories: Git
categories:
  - React # HTML CSS JavaScript Server Algorithm Wecodes Programmers CS Github Blog
tag: [리액트 기초, pagination] #tag는 여러개 가능함
toc: true #table of content 기능!
toc_sticky: true
author_profile: true #blog 글안에서는 author_profile이 따라다니지 않도록 설정함
date: 2022-09-11T10:30:00+09:00
# sidebar:
# nav: "docs" #네비게이션에 있는 docs를 의미함
---
<style>
.crimson {
  color: crimson;
  font-weight: bold;
}

.mediumblue {
  color: mediumblue;
  font-weight: bold;
}

.teal {
  color: teal;
  font-weight: bold;
}
</style>

# 리액트 페이지네이션
(DaleSeo) : [React로 페이지네이션 UI 구현하기](https://www.daleseo.com/react-pagination/)

<span class="crimson">pagination</span>은 여러 개의 게시물을 보여주는 <u>웹사이트의 하단</u>에서 흔히 볼 수 있는 UI이다.  
<img src="https://user-images.githubusercontent.com/87808288/189508476-cec5b5d1-b251-4e8e-bbc9-f43923df81f2.png" width="70%">

<img src="https://user-images.githubusercontent.com/87808288/189508435-01ed6768-4920-4af2-9304-d72a6059adbd.png" width="70%">

back-end에서 가지고 있는 데이터는 무수히 많고, 그 데이터들을 <u>한 화면에 전부 보여줄 수 없는 경우</u>에 사용한다. 흔히 게시판의 "이전" 그리고 "다음" 페이지를 끊어서 보여주는 기능으로 이해할 수 있다.

## 전체 게시물 목록 구현하기
우선 페이지네이션이 없이 백엔드에서 보내주는 모든 게시물의 목록을 보여주는 리액트 컴포넌트를 만들어 보자. 이를 위해서는 우선 백엔드로부터 <u>데이터를 받아 보아야</u> 하는데 이를 위한 것이 바로 (<span class="teal">JSON placholder</span>) : <https://jsonplaceholder.typicode.com/> 이 사이트이다.

```jsx
// Posts.jsx
import { useState, useEffect } from "react";
import styled from "styled-components";
import Pagination from "./Pagination";

function Posts() {
  const [posts, setPosts] = useState([]);

  useEffect(() => {
    fetch("https://jsonplaceholder.typicode.com/posts")
      .then((res) => res.json())
      .then((data) => setPosts(data));
  }, []);

  return (
    <Layout>
      <header>
        <h1>게시물 목록</h1>
      </header>

      <main>
        {posts.map(({ id, title, body }) => (
          <article key={id}>
            <h3>
              {id}. {title}
            </h3>
            <p>{body}</p>
          </article>
        ))}
      </main>
    </Layout>
  );
}

const Layout = styled.div`
  display: flex;
  flex-direction: column;
  align-items: center;
  max-width: 800px;
  margin: 0 auto;
`;

export default Posts;
```

useEffect를 이용하여 JSON placeholder API를 비동기로 요청하고 응답받은 게시물 데이터를 <span class="teal">posts 상태</span>에 저장한다. 그 다음에는 <u>posts 상태를 순회하면서</u> 각 게시물의 아이디, 제목, 본문을 화면에 렌더링하게 되는 것이다.

## 페이지네이션 알고리즘
게시물을 여러 페이지에 나누어서 표시하기 위해선 <span class="teal">총 몇 개의 페이지가 필요한지</span>를 먼저 알아야 한다. 총 게시물의 수를 <span class="mediumblue">페이지 당 표시할 게시물의 수로 나누어</span> 이를 올림하면 몇 개의 페이지가 필요한지 미리 계산할 수 있다.

<u>총 37개의 게시물</u>이 존재하고 <span class="teal">페이지 당 10개의 게시물</span>을 표시하려면, <span class="mediumblue">37 / 10 = 3.7</span>이고 여기서 이를 올림하면 4개의 페이지가 필요함을 알 수 있게 된다. (1~3 페이지에서는 10개의 게시물이 있고, 마지막 4페이지에는 7개의 게시물이 표시)

이 다음으로는, 현재 페이지 번호를 기준으로 표시될 게시물의 범위 즉 해당 페이지의 첫 게시물의 위치(index)를 알아야 한다. 페이지 번호에서 1을 뺀 후 페이지 당 표시할 게시물의 수를 곱하면 첫 게시물의 위치를 계산할 수 있다.

- 1번 페이지의 첫 게시물의 위치(Index) -> (1 - 1) * 10 = 0
- 2번 페이지의 첫 게시물의 위치(Index) -> (2 - 1) * 10 = 10
- 3번 페이지의 첫 게시물의 위치(Index) -> (3 - 1) * 10 = 20
- 4번 페이지의 첫 게시물의 위치(Index) -> (4 - 1) * 10 = 30

## 현재 페이지에 해당하는 게시물만 보여주기
전체 게시물이 아니라 현재 페이지에 해당하는 게시물만 화면에 렌더링될 수 있도록 Posts 컴포넌트를 변경해보자.

자바스크립트 배열의 slice() 함수를 사용하여 첫 게시물부터 마지막 게시물까지만 루프를 돌도록 코드를 변경하였다.

```jsx
// Posts.jsx
import { useState, useEffect } from "react";
import styled from "styled-components";
import Pagination from "./Pagination";

function Posts() {
  const [posts, setPosts] = useState([]);
  const [limit, setLimit] = useState(10);
  const [page, setPage] = useState(1);
  const offset = (page - 1) * limit;

  useEffect(() => {
    fetch("https://jsonplaceholder.typicode.com/posts")
      .then((res) => res.json())
      .then((data) => setPosts(data));
  }, []);

  return (
    <Layout>
      <header>
        <h1>게시물 목록</h1>
      </header>

      <label>
        페이지 당 표시할 게시물 수:&nbsp;
        <select
          type="number"
          value={limit}
          onChange={({ target: { value } }) => setLimit(Number(value))}
        >
          <option value="10">10</option>
          <option value="12">12</option>
          <option value="20">20</option>
          <option value="50">50</option>
          <option value="100">100</option>
        </select>
      </label>

      <main>
        {posts.slice(offset, offset + limit).map(({ id, title, body }) => (
          <article key={id}>
            <h3>
              {id}. {title}
            </h3>
            <p>{body}</p>
          </article>
        ))}
      </main>
    </Layout>
  );
}

const Layout = styled.div`
  display: flex;
  flex-direction: column;
  align-items: center;
  max-width: 800px;
  margin: 0 auto;
`;

export default Posts;
```

## 페이지네이션 컴포넌트 구현
`Pagination 컴포넌트`는 이전 페이지나 다음 페이지 또는 특정 페이지로 이동할 수 있는 <u>버튼들로 구성</u>된다. Pagination 컴포넌트는 Posts 컴포넌트로부터 총 게시물 수(<span class="teal">total</span>), 페이지 당 게시물 수(<span class="teal">limit</span>), 현재 페이지 번호(<span class="teal">page</span>)를 prop로 받게 된다.

위에서 배운 페이지네이션 알고리즘을 이용하여 페이지의 개수(<span class="teal">numPages</span>)를 계산한 후 페이지의 개수만큼 순회하여 페이지 번호 버튼을 렌더링한다.

페이지 번호 버튼에 클릭 이벤트가 발생하면 prop로 넘어온 setPage() 함수를 호출하여 부모인 Posts 컴포넌트의 page 상태가 변경되도록 한다. 그러면 Posts 컴포넌트는 새로운 페이지 번호에 해당하는 게시물 범위를 계산하여 다시 화면을 렌더링하게 될 것이다.

```jsx
// Pagination.jsx
import styled from "styled-components";

function Pagination({ total, limit, page, setPage }) {
  const numPages = Math.ceil(total / limit);

  return (
    <>
      <Nav>
        <Button onClick={() => setPage(page - 1)} disabled={page === 1}>
          &lt;
        </Button>
        {Array(numPages)
          .fill()
          .map((_, i) => (
            <Button
              key={i + 1}
              onClick={() => setPage(i + 1)}
              aria-current={page === i + 1 ? "page" : null}
            >
              {i + 1}
            </Button>
          ))}
        <Button onClick={() => setPage(page + 1)} disabled={page === numPages}>
          &gt;
        </Button>
      </Nav>
    </>
  );
}

const Nav = styled.nav`
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 4px;
  margin: 16px;
`;

const Button = styled.button`
  border: none;
  border-radius: 8px;
  padding: 8px;
  margin: 0;
  background: black;
  color: white;
  font-size: 1rem;

  &:hover {
    background: tomato;
    cursor: pointer;
    transform: translateY(-2px);
  }

  &[disabled] {
    background: grey;
    cursor: revert;
    transform: revert;
  }

  &[aria-current] {
    background: deeppink;
    font-weight: bold;
    cursor: revert;
    transform: revert;
  }
`;

export default Pagination;
```

유저가 현재 어느 페이지에 있는지 알 수 있도록 <span class="teal">해당 페이지 버튼을 시각적으로 두드러지게 하는 것이 좋은데</span> 이때는 현재 페이지가 가리키는 버튼을 `aria-current 속성`으로 표기하는 것이 좋다. 이는 시각 장애로 인하여 브라우저 대신에 <span class="mediumblue">스크린리더를 사용하는 유저에게 도움</span>이 되기 때문이다. 그리고 이전 페이지 버튼은 첫번째 페이지에서, 다음 페이지는 마지막 페이지에서 클릭이 불가하도록 처리한다.

## 페이지네이션이 가능한 게시물 목록 완성
이제 마지막으로 Navigation 컴포넌트를 Posts 컴포넌트에 import 하면 페이지네이션이 가능한 게시물 목록이 완성된다.

```jsx
// Posts.jsx
import { useState, useEffect } from "react";
import styled from "styled-components";
import Pagination from "./Pagination";

function Posts() {
  const [posts, setPosts] = useState([]);
  const [limit, setLimit] = useState(10);
  const [page, setPage] = useState(1);
  const offset = (page - 1) * limit;

  useEffect(() => {
    fetch("https://jsonplaceholder.typicode.com/posts")
      .then((res) => res.json())
      .then((data) => setPosts(data));
  }, []);

  return (
    <Layout>
      <header>
        <h1>게시물 목록</h1>
      </header>

      <label>
        페이지 당 표시할 게시물 수:&nbsp;
        <select
          type="number"
          value={limit}
          onChange={({ target: { value } }) => setLimit(Number(value))}
        >
          <option value="10">10</option>
          <option value="12">12</option>
          <option value="20">20</option>
          <option value="50">50</option>
          <option value="100">100</option>
        </select>
      </label>

      <main>
        {posts.slice(offset, offset + limit).map(({ id, title, body }) => (
          <article key={id}>
            <h3>
              {id}. {title}
            </h3>
            <p>{body}</p>
          </article>
        ))}
      </main>

      <footer> // correction
        <Pagination
          total={posts.length}
          limit={limit}
          page={page}
          setPage={setPage}
        />
      </footer> // correction
    </Layout>
  );
}

const Layout = styled.div`
  display: flex;
  flex-direction: column;
  align-items: center;
  max-width: 800px;
  margin: 0 auto;
`;

export default Posts;
```

<!-- front-end에서는 <span class="mediumblue">현재의 위치(offset)</span>과 추가로 보여줄 <span class="mediumblue">컨텐츠의 수(Limit)</span>를 back-end에게 전달한다. back-end에서는 그에 해당하는 데이터를 끊어 보여주는 방식으로 구현하게 된다. -->

<!-- # Query Parameter(Query String)
localhost:8000/products<span class="crimson">?</span><u>limit=10&offset=5</u> 라는 주소가 있다면, API 뒷 부분에 붙어있는 `?`로 시작하는 텍스트가 바로 <span class="crimson">쿼리스트링</span>이다.

<span class="crimson">limit=10&offset=5</span>의 경우 "<span class="mediumblue">limit</span>이 <u>10</u>이면서 <span class="mediumblue">offset</span>이 <u>5</u>일 경우의 product 페이지를 보여달라"는 요청으로 해석된다. <span class="mediumblue">?기호</span>는 <span class="teal">쿼리스트링의 시작</span>을 알린다. url에서 ?기호는 유일무이하다.

<u>limit</u>는 한 페이지에 `보여줄 데이터의 수`를 나타낸다. <u>offset</u>은 `데이터가 시작하는 위치`(index)를 나타낸다. <span style="color:red">parameter=value</span>로 필요한 파라미터의 값을 작성한다. 파라미터가 여러 개일 경우 <u>&를 붙여서</u> 여러 개의 파라미터를 넘길 수 있다.

# useLocation().search
쿼리스트링을 이용한 <u>페이지 네이션</u> 기능 또한 <u>동적 라우팅</u> 기능과 크게 다르지 않다.

## 두 기능의 비교

##### 동적 라우팅

&nbsp; 1. 리스트 페이지에서 카드를 클릭한다.  
&nbsp; 2. url 이동을 한다. 이때, 카드의 고유한 id 값이 url에 포함된다.  
&nbsp; 3. 이동한 페이지에서, url에 담겨있는 id 값을 <span style="color:red">useParams</span> 훅을  
&nbsp; &nbsp; &nbsp; 이용해 가져온다.  
&nbsp; 4. 가져온 id 값을 이용하여 데이터를 요청한다.

##### 페이지네이션

&nbsp; 1. 리스트 페이지에서 페이지 이동 버튼을 클릭한다.  
&nbsp; 2. url 이동을 한다. 이때 url에는 각 버튼에 <u>해당하는 쿼리 스트링이 포함</u>된다.  
&nbsp; 3. 이동한 페이지에서, url에 담겨있는 쿼리스트링을 <span style="color:red">useLocation</span> 훅을  
&nbsp; &nbsp; &nbsp; 이용하여 가져온다.  
&nbsp; 4. 가져온 쿼리스트링을 이용하여 데이터를 요청한다.

`Path Parameter`에 대한 정보가 <span style="color:red">useParams</span> 훅이 반환한 객체에 담기듯이,  
`쿼리스트링`에 대한 정보는 <span style="color:red">useLocation</span> 훅이 반환한 객체의  
search 프로퍼티에 담긴다.

```java
// current url -> localhost:3000/products?offset=10&limit=10

function ProductList(b) {
  const location = useLocation();

  console.log(location.search) // ?offset=10&limit=10

  return (
      ...
  )
}
```

이를 통해 url에서 쿼리스트링 정보를 받아와서, 해당 정보를 통해 데이터를  
요청할 수 있다.

```java
fetch(`${API}${location.search}`)
  .then(res => res.json())
  .then(res => ...)
``` -->














<!-- ⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ -->

<!-- ### 2. Link 넣기

유형 1: (설명어를 입력) : [gunhee's coding blog](https://gunhee-jeong.github.io/)
유형 2: (URL 자동연결) : <https://gunhee-jeong.github.io/>
유형 3: (동일 파일 내 '문단으로 이동') : [1. Header로 이동](###-1-header)

1. 특수문자를 제거
2. 스페이스는 -로 바꾸고
3. 대문자는 소문자로!
   그래서 ### 1. Header -> #1-header

## Link: [google][https://www.google.com/]

### 3. 수평선

```

---

```

---

### 4. 라인 바꾸기

```

스페이스바를 2번 눌러주면 다음칸으로
이동할 수 있어요!

```

---

스페이스바를 2번 눌러주면
다음칸으로 이동할 수 있어요!

### 5. list 만들기

```

1. 1번
2. 2번
3. 3번

- 순서없는 list
  - 순서없는 list
    - 순서없는 list

```

1. 1번
2. 2번
3. 3번

- 순서없는 list
  - 순서없는 list
    - 순서없는 list

---

### 6. font 관련

```

**진하게** -> 볼드
_기울여서_ -> 이탤릭체
~~취소선~~ -> 취소선

<ul>밑줄넣기</ul> -> 밑줄
<span style="color:red">빨간 글씨</span> -> 글자색
이것이 `인라인` 입니다 -> 인라인 코드
```

**진하게** -> 볼드
_기울여서_ -> 이탤릭체
~~취소선~~ -> 취소선
<u>밑줄넣기</u> -> 밑줄
<span style="color:red">빨간 글씨</span>
이것이 `인라인` 입니다 -> 인라인 코드

---

### 7. 인용구문

```
> coding
>
> > JavaScript
> >
> > > 내가 프짱!
```

> coding
>
> > JavaScript
> >
> > > 내가 프짱!

---

### 8. 이미지 삽입

```
유형1: ('사이즈를 조절' -> HTML 태그 사용) : <img src="https://gunhee-jeong.github.io/assets/images/blogLogo.png" width="300" height="200">
유형2: (이미지 삽입 후 -> 링크 걸기)
[![이미지](https://gunhee-jeong.github.io/assets/images/blogLogo/blogLogo.png)](https://gunhee-jeong.github.io/)
```

유형1: ('사이즈를 조절' -> HTML 태그 사용) : <img src="https://gunhee-jeong.github.io/assets/images/blogLogo.png" width="300" height="200">
유형2: (이미지 삽입 후 -> 링크 걸기)
[![이미지](https://gunhee-jeong.github.io/assets/images/blogLogo.png)](https://gunhee-jeong.github.io/)

### 9. 표 만들기

```
||국어|영어|
| :--- | ---: | :--: |
|건희 | 100점 | 100점
|철수 | 100점 | 100점
```

|      |  국어 | 영어  |
| :--- | ----: | :---: |
| 건희 | 100점 | 100점 |
| 철수 | 100점 | 100점 |

> - header를 넣고 싶은 경우 ---을 사용하고 :을 이용하여 정렬에 사용함!

### 10. 토글 만들기

```
<details>
<summary>여기를 누르세요</summary>
<div markdown="1">
숨겨진 내용
</div>
</details>
```

<details>
<summary>여기를 누르세요</summary>
<div markdown="1">
숨겨진 내용
</div>
</details> -->
