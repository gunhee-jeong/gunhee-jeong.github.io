---
layout: single
title: "코드숨 4주차 학습: Redux"
# categories: Git
categories:
  - React # HTML CSS JavaScript Server Algorithm Wecode Programmers CS Github Blog
tag: [리액트 기초, 리덕스] #tag는 여러개 가능함
toc: true #table of content 기능!
toc_sticky: true
author_profile: true #blog 글안에서는 author_profile이 따라다니지 않도록 설정함
date: 2022-08-22T22:00:00+09:00
# sidebar:
# nav: "docs" #네비게이션에 있는 docs를 의미함
---
<style>
.crimson {
  color: crimson;
  font-weight: bold;
}

.darkorange {
  color: darkorange;
  font-weight: bold;
}

.olive {
  color: olive;
  font-weight: bold;
}

.royalblue {
  color: royalblue;
  font-weight: bold;
}

.forestgreen {
  color: foresgreen;
  font-weight: bold;
}
</style>

# 코드숨 4주차 학습: Redux
## 1장 기본적인 관심사 분리
기존의 <u>간단한 todo 리스트</u>를 만들 수 있는 App.jsx의 코드 전문이다. App 컴포넌트의 <span class="crimson">App 함수</span> 안에서 <span class="darkorange">상태 관리</span>를 하고, todo 리스트의 <span class="darkorange">전체 로직을 관리하는 handle 함수들</span>도 모두 App 함수 안에 가지고 있다.

### (1) 기존 App.js
```jsx
// App.jsx
import { useState } from 'react';

import Page from './Page';

export default function App() {
  const [state, setState] = useState({
    newId: 100,
    taskTitle: '',
    tasks: [],
  });

  const { newId, taskTitle, tasks } = state;

  function handleChangeTitle(event) {
    setState({
      ...state,
      taskTitle: event.target.value,
    });
  }

  function handleClickAddTask() {
    setState({
      ...state,
      newId: newId + 1,
      taskTitle: '',
      tasks: [...tasks, { id: newId, title: taskTitle }],
    });
  }

  function handleClickDeleteTask(id) {
    setState({
      ...state,
      tasks: tasks.filter((task) => task.id !== id),
    });
  }

  return (
    <Page
      taskTitle={taskTitle}
      onChangeTitle={handleChangeTitle}
      onClickAddTask={handleClickAddTask}
      tasks={tasks}
      onClickDeleteTask={handleClickDeleteTask}
    />
  );
}
```

### (2) 관심사를 분리한 App.js
리덕스를 적용함에 있어서 <u>우선 initialState</u>를 만들어 상태 관리를 할 수 있다. <span class="darkorange">App 함수가 상태를 알게 할 필요는 없다</span>. 또한 <span class="darkorange">App의 handle 함수들이 직접적인 로직을 알 필요도 없다</span>. 이러한 부분들의 <span class="crimson">관심사 분리</span>를 우선 진행할 수 있다. 그러면 아래와 같이 App.js를 작성할 수 있다.

아래와 같이 App 함수를 관리하게 되면, App 함수에서는 이제 초기 상태가 어떠한 값인지 그리고 할 일을 어떻게 추가하게 되는지 그리고 어떻게 삭제하는지 등을 알 수 없게 된 것이다. <span class="crimson">App은 그저 화면에 보이는 것에 집중</span>하게 된 것이다. 이렇게 <span class="olive">상태를 관리하는 부분</span>과 <span class="olive">화면에 그려주는 부분</span>이 완벽하게 분리가 되었다.

```jsx
// App.jsx
import { useState } from 'react';

import Page from './Page';

const initialState = {
  newId: 100,
  taskTitle: '',
  tasks: [
    { id: 1, title: '아무 것도 하지 않기 #1' },
    { id: 2, title: '아무 것도 하지 않기 #2' },
  ],
};

function updateTaskTitle(state, taskTitle) {
  return {
    ...state,
    taskTitle,
  };
}

function addTask(state) {
  const { newId, taskTitle, tasks } = state;

  return {
    ...state,
    newId: newId + 1,
    taskTitle: '',
    tasks: [...tasks, { id: newId, title: taskTitle }],
  };
}

function deleteTask(state, id) {
  const { tasks } = state;

  return {
    ...state,
    tasks: tasks.filter((task) => task.id !== id),
  };
}

export default function App() {
  const [state, setState] = useState(initialState);

  const { taskTitle, tasks } = state;

  function handleChangeTitle(event) {
    setState(updateTaskTitle(state, event.target.value));
  }

  function handleClickAddTask() {
    setState(addTask(state));
  }

  function handleClickDeleteTask(id) {
    setState(deleteTask(state, id));
  }

  return (
    <Page
      taskTitle={taskTitle}
      onChangeTitle={handleChangeTitle}
      onClickAddTask={handleClickAddTask}
      tasks={tasks}
      onClickDeleteTask={handleClickDeleteTask}
    />
  );
}
```

### (3) App에서 state 분리하기
App.js에서는 <u>useState를 사용하면서</u> App.js 내의 <span class="royalblue">handle 함수가 호출</span>되면서 <span class="olive">state를 콜백 함수의 인수로 전달하는 방식</span>을 사용했다. 하지만 <span class="crimson">리덕스</span>를 사용하게되면 이렇게 콜백 함수의 인수로 전달했던 <span class="darkorange">state를 App에서 더이상 사용하지 않을 수</span> 있다.

App 컴포넌트에서 자식 컴포넌트에게 <u>props로 전달해야하는 것 중에서 state와 관련된 것들이 있다면</u> `App.js`에 <span class="darkorange">useSelector</span>를 가져와서 <span class="olive">store의 state를 뽑아와 사용할 수</span> 있게 된다.

```jsx
// App.jsx
import { useDispatch, useSelector } from 'react-redux';

import Page from './Page';

// action creator
function updateTaskTitle(taskTitle) {
  return {
    type: 'updateTaskTitle',
    payload: {
      taskTitle,
    },
  };
}

function addTask() {
  return {
    type: 'addTask',
  };
}

function deleteTask(id) {
  return {
    type: 'deleteTask',
    payload: {
      id,
    },
  };
}

// function selector(state) {
//   return {
//     taskTitle: state.taskTitle,
//     tasks: state.tasks,
//   };
// }

export default function App() {
  // const { taskTitle, tasks } = useSelector(selector);
  const { taskTitle, tasks } = useSelector((state) => ({
    taskTitle: state.taskTitle,
    tasks: state.tasks,
  }));

  const dispatch = useDispatch();

  function handleChangeTitle(event) {
    dispatch(updateTaskTitle(event.target.value));
  }

  function handleClickAddTask() {
    dispatch(addTask());
  }

  function handleClickDeleteTask(id) {
    dispatch(deleteTask(id));
  }

  return (
    <Page
      taskTitle={taskTitle}
      onChangeTitle={handleChangeTitle}
      onClickAddTask={handleClickAddTask}
      tasks={tasks}
      onClickDeleteTask={handleClickDeleteTask}
    />
  );
}
```

```jsx
// store.js
import { legacy_createStore as createStore } from 'redux';

// Redux action
// type (string)
// payload => object => { taskTitle }

const initialState = {
  newId: 100,
  taskTitle: '',
  tasks: [
    { id: 1, title: '아무 것도 하지 않기 #1' },
    { id: 2, title: '아무 것도 하지 않기 #2' },
  ],
};

function reducer(state = initialState, action) {
  if (action.type === 'updateTaskTitle') {
    return {
      ...state,
      taskTitle: action.payload.taskTitle,
    };
  }

  if (action.type === 'addTask') {
    const { newId, taskTitle, tasks } = state;

    return {
      ...state,
      newId: newId + 1,
      taskTitle: '',
      tasks: [...tasks, { id: newId, title: taskTitle }],
    };
  }
  if (action.type === 'deleteTask') {
    const { tasks } = state;

    return {
      ...state,
      tasks: tasks.filter((task) => task.id !== action.payload.id),
    };
  }

  return state;
}

const store = createStore(reducer);

export default store;
```

그리고 App.js에서 <u>action creator들을 따로 분리</u>시켜 주면 아래와 같은 파일들로 분리시킬 수 있다.

```jsx
// index.jsx
import ReactDOM from 'react-dom';

import { Provider } from 'react-redux';

import App from './App';

import store from './store';

ReactDOM.render(
  (
    <Provider store={store}>
      <App />
    </Provider>
  ),
  document.getElementById('app'),
);
```

```jsx
// App.jsx
import { useDispatch, useSelector } from 'react-redux';

import Page from './Page';

import {
  updateTaskTitle,
  addTask,
  deleteTask,
} from './actions';

export default function App() {
  const { taskTitle, tasks } = useSelector((state) => ({
    taskTitle: state.taskTitle,
    tasks: state.tasks,
  }));

  const dispatch = useDispatch();

  function handleChangeTitle(event) {
    dispatch(updateTaskTitle(event.target.value));
  }

  function handleClickAddTask() {
    dispatch(addTask());
  }

  function handleClickDeleteTask(id) {
    dispatch(deleteTask(id));
  }

  return (
    <Page
      taskTitle={taskTitle}
      onChangeTitle={handleChangeTitle}
      onClickAddTask={handleClickAddTask}
      tasks={tasks}
      onClickDeleteTask={handleClickDeleteTask}
    />
  );
}
```

```jsx
// actions.js
// action creator
export function updateTaskTitle(taskTitle) {
  return {
    type: 'updateTaskTitle',
    payload: {
      taskTitle,
    },
  };
}

export function addTask() {
  return {
    type: 'addTask',
  };
}

export function deleteTask(id) {
  return {
    type: 'deleteTask',
    payload: {
      id,
    },
  };
}
```

```jsx
// store.js
import { legacy_createStore as createStore } from 'redux';

// Redux action
// type (string)
// payload => object => { taskTitle }

const initialState = {
  newId: 100,
  taskTitle: '',
  tasks: [],
};

function reducer(state = initialState, action) {
  if (action.type === 'updateTaskTitle') {
    return {
      ...state,
      taskTitle: action.payload.taskTitle,
    };
  }

  if (action.type === 'addTask') {
    const { newId, taskTitle, tasks } = state;

    return {
      ...state,
      newId: newId + 1,
      taskTitle: '',
      tasks: [...tasks, { id: newId, title: taskTitle }],
    };
  }
  if (action.type === 'deleteTask') {
    const { tasks } = state;

    return {
      ...state,
      tasks: tasks.filter((task) => task.id !== action.payload.id),
    };
  }

  return state;
}

const store = createStore(reducer);

export default store;
```

이렇게 기본적으로 action creator들을 따로 분리시키고 store.js 안에 reducer 함수를 작성해주었다. 아래는 이렇게 완성한 `App 컴포넌트의 test 코드`이다.

```jsx
// App.test.jsx
import { render } from '@testing-library/react';

import { useSelector } from 'react-redux';

import App from './App';

jest.mock('react-redux');

test('App', () => {
  useSelector.mockImplementation((selector) => selector({
    tasks: [
      { id: 1, title: '아무 것도 하지 않기 #1' },
      { id: 2, title: '아무 것도 하지 않기 #2' },
    ],
  }));

  const { getByText } = render((
    <App />
  ));

  expect(getByText(/추가/)).not.toBeNull();
});
```

## 2장 reducer
<u>store.js에 있는 reducer 함수를 따로</u> reducer.js 파일로 옮기고 store.js에서는 reducer를 import하여 사용할 수 있다.

reducer.test.js 파일을 만들어 reducer 함수를 테스트할 수 있는데, <u>기존의 App.jsx 코드</u>를 살펴보면 <span class="royalblue">input 값이 없더라도 추가를 누르면 추가가가 되는 오류</span>가 있었다. 이때문에 reducer의 테스트 코드에서 이를 검증할 수 있도록 테스트 코드를 작성하였고 그로인한 TDD의 red 상황을 해결하기 위해 <span class="olive">reducer 함수의 로직(reducer.js)이 추가</span>되었다.

### (1) reducer.js
```jsx
// reducer.js
// Redux action
// type (string)
// payload => object => { taskTitle }

const initialState = {
  newId: 100,
  taskTitle: '',
  tasks: [],
};

export default function reducer(state = initialState, action) {
  if (action.type === 'updateTaskTitle') {
    return {
      ...state,
      taskTitle: action.payload.taskTitle,
    };
  }

  if (action.type === 'addTask') {
    const { newId, taskTitle, tasks } = state;

    if (!taskTitle) {
      return state;
    }

    return {
      ...state,
      newId: newId + 1,
      taskTitle: '',
      tasks: [...tasks, { id: newId, title: taskTitle }],
    };
  }

  if (action.type === 'deleteTask') {
    const { tasks } = state;

    return {
      ...state,
      tasks: tasks.filter((task) => task.id !== action.payload.id),
    };
  }

  return state;
}
```

위의 코드에서 input 값이 없다면 추가가 되지 않게 하기 위해서 아래의 코드가 추가되었다.

```jsx
if (action.type === 'addTask') {
  const { newId, taskTitle, tasks } = state;

  if (!taskTitle) {
    return state;
  }

  return {
    ...state,
    newId: newId + 1,
    taskTitle: '',
    tasks: [...tasks, { id: newId, title: taskTitle }],
  };
}
```

### (2) reducer.test.js
```jsx
// reducer.test.js
import reducer from './reducer';

import {
  updateTaskTitle,
  addTask,
  deleteTask,
} from './actions';

describe('reducer', () => {
  describe('updateTaskTitle', () => {
    it('changes task title', () => {
      const state = reducer({
        taskTitle: '',
      }, updateTaskTitle('New Title'));

      expect(state.taskTitle).toBe('New Title');
    });
  });

  describe('addTask', () => {
    context('with task title', () => {
      it('appends a new task into tasks', () => {
        const state = reducer({ // 이 부분이 반복
          newId: 100,
          taskTitle: 'New Title',
          tasks: [],
        }, addTask());

        expect(state.tasks).toHaveLength(1);
        expect(state.tasks[0].id).not.toBeUndefined();
        expect(state.tasks[0].title).toBe('New Title');
      });

      it('clears task title', () => {
        const state = reducer({ // 이 부분이 반복
          newId: 100,
          taskTitle: 'New Title',
          tasks: [],
        }, addTask());

        expect(state.taskTitle).toBe('');
      });
    });

    context('without task title', () => {
      it('doesn`t work', () => {
        const state = reducer({ // 이 부분이 반복
          newId: 100,
          taskTitle: '',
          tasks: [],
        }, addTask());

        expect(state.tasks).toHaveLength(0);
      });
    });
  });
});
```

위의 reducer 테스트 코드에서 주석으로 기재된 부분이 <span class="olive">반복</span>되고 있다. 이것을 <span class="darkorange">함수를 만들어 재사용</span>할 수 있는 부분이다. 

```jsx
// reducer.test.js
import reducer from './reducer';

import {
  updateTaskTitle,
  addTask,
  deleteTask,
} from './actions';

describe('reducer', () => {
  describe('updateTaskTitle', () => {
    it('changes task title', () => {
      const state = reducer({
        taskTitle: '',
      }, updateTaskTitle('New Title'));

      expect(state.taskTitle).toBe('New Title');
    });
  });

  describe('addTask', () => {
    function reducerAddTask(taskTitle) { // 반복되는 부분을 이렇게 함수로 만듦
      return reducer({
        newId: 100,
        taskTitle,
        tasks: [],
      }, addTask());
    }

    context('with task title', () => {
      it('appends a new task into tasks', () => {
        const state = reducerAddTask('New Title'); // reducerAddTask 함수를 호출하여 사용

        expect(state.tasks).toHaveLength(1);
        expect(state.tasks[0].id).not.toBeUndefined();
        expect(state.tasks[0].title).toBe('New Title');
      });

      it('clears task title', () => {
        const state = reducerAddTask('New Title'); // reducerAddTask 함수를 호출하여 사용

        expect(state.taskTitle).toBe('');
      });
    });

    context('without task title', () => {
      it('doesn`t work', () => {
        const state = reducerAddTask(''); // reducerAddTask 함수를 호출하여 사용

        expect(state.tasks).toHaveLength(0);
      });
    });
  });

  describe('deleteTask', () => {
    context('with existed task ID', () => {
      it('remove the task from tasks', () => {
        const state = reducer({
          tasks: [
            { id: 1, title: 'Task' },
          ],
        }, deleteTask(1));

        expect(state.tasks).toHaveLength(0);
      });
    });

    context('without existed task ID', () => {
      it('doesn`t work', () => {
        const state = reducer({
          tasks: [
            { id: 1, title: 'Task' },
          ],
        }, deleteTask(100));

        expect(state.tasks).toHaveLength(1);
      });
    });
  });
});
```

## 3장 컴포넌트의 구조 변경
App 컴포넌트는 컨테이너 컴포넌트이고 이것을 제외한 컴포넌트가 프레젠테이셔널 컴포넌트였다.

ListContainer 컴포넌트는 list 정보를 가지고 있는 컨테이너 컴포넌트가 된다.

<!-- ⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ -->

<!-- ### 2. Link 넣기

```

유형 1: (설명어를 입력) : [gunhee's coding blog](https://gunhee-jeong.github.io/)
유형 2: (URL 자동연결) : <https://gunhee-jeong.github.io/>
유형 3: (동일 파일 내 '문단으로 이동') : [1. Header로 이동](###-1-header)

```

유형 1: (설명어를 입력) : [gunhee's coding blog](https://gunhee-jeong.github.io/)
유형 2: (URL 자동연결) : <https://gunhee-jeong.github.io/>
유형 3: (동일 파일 내 '문단으로 이동') : [1. Header로 이동](#1-header)
유형 3의 방법

1. 특수문자를 제거
2. 스페이스는 -로 바꾸고
3. 대문자는 소문자로!
   그래서 ### 1. Header -> #1-header

## Link: [google][https://www.google.com/]

### 3. 수평선

```

---

```

---

### 4. 라인 바꾸기

```

스페이스바를 2번 눌러주면 다음칸으로
이동할 수 있어요!

```

---

스페이스바를 2번 눌러주면
다음칸으로 이동할 수 있어요!

### 5. list 만들기

```

1. 1번
2. 2번
3. 3번

- 순서없는 list
  - 순서없는 list
    - 순서없는 list

```

1. 1번
2. 2번
3. 3번

- 순서없는 list
  - 순서없는 list
    - 순서없는 list

---

### 6. font 관련

```

**진하게** -> 볼드
_기울여서_ -> 이탤릭체
~~취소선~~ -> 취소선

<ul>밑줄넣기</ul> -> 밑줄
<span style="color:red">빨간 글씨</span> -> 글자색
이것이 `인라인` 입니다 -> 인라인 코드
```

**진하게** -> 볼드
_기울여서_ -> 이탤릭체
~~취소선~~ -> 취소선
<u>밑줄넣기</u> -> 밑줄
<span style="color:red">빨간 글씨</span>
이것이 `인라인` 입니다 -> 인라인 코드

---

### 7. 인용구문

```
> coding
>
> > JavaScript
> >
> > > 내가 프짱!
```

> coding
>
> > JavaScript
> >
> > > 내가 프짱!

---

### 8. 이미지 삽입

```
유형1: ('사이즈를 조절' -> HTML 태그 사용) : <img src="https://gunhee-jeong.github.io/assets/images/blogLogo.png" width="300" height="200">
유형2: (이미지 삽입 후 -> 링크 걸기)
[![이미지](https://gunhee-jeong.github.io/assets/images/blogLogo/blogLogo.png)](https://gunhee-jeong.github.io/)
```

유형1: ('사이즈를 조절' -> HTML 태그 사용) : <img src="https://gunhee-jeong.github.io/assets/images/blogLogo.png" width="300" height="200">
유형2: (이미지 삽입 후 -> 링크 걸기)
[![이미지](https://gunhee-jeong.github.io/assets/images/blogLogo.png)](https://gunhee-jeong.github.io/)

### 9. 표 만들기

```
||국어|영어|
| :--- | ---: | :--: |
|건희 | 100점 | 100점
|철수 | 100점 | 100점
```

|      |  국어 | 영어  |
| :--- | ----: | :---: |
| 건희 | 100점 | 100점 |
| 철수 | 100점 | 100점 |

> - header를 넣고 싶은 경우 ---을 사용하고 :을 이용하여 정렬에 사용함!

### 10. 토글 만들기

```
<details>
<summary>여기를 누르세요</summary>
<div markdown="1">
숨겨진 내용
</div>
</details>
```

<details>
<summary>여기를 누르세요</summary>
<div markdown="1">
숨겨진 내용
</div>
</details> -->
