---
layout: single
title: "리덕스 툴킷(Toolkit)"
# categories: Git
categories:
  - React # HTML CSS JavaScript Server Algorithm Wecodes Programmers CS Github Blog
tag: [리액트 기초] #tag는 여러개 가능함
toc: true #table of content 기능!
toc_sticky: true
author_profile: true #blog 글안에서는 author_profile이 따라다니지 않도록 설정함
date: 2022-10-09T17:30:00+09:00
# sidebar:
# nav: "docs" #네비게이션에 있는 docs를 의미함
---
<style>
.crimson {
  color: crimson;
  font-weight: bold;
}

.mediumblue {
  color: mediumblue;
  font-weight: bold;
}

.forestgreen {
  color: forestgreen;
  font-weight: bold;
}

.black {
  color: black;
  font-weight: bold;
}
</style>

# 리덕스 툴킷(Toolkit)
(화해 블로그) : [리덕스 툴킷은 정말 천덕꾸러기일까?](http://blog.hwahae.co.kr/all/tech/tech-tech/6946/)  
(공식 문서) : [Redux Toolkit](https://redux-toolkit.js.org/)

`리덕스 툴킷`. 줄여서 `RTK`는 리덕스를 더 쉽게 사용하기 위해 만들어진 존재이다. 이름 그대로 <u>리덕스를 위한 도구 모음(키트)</u>인 것이다.

완벽할 것 같은 리덕스에도 이슈가 몇가지 있는데 대표적인 것이 아래의 내용들이다.
- 리덕스 스토어 환경 설정이 복잡하다.
- 리덕스를 유용하게 사용하려면 많은 패키지를 추가해야 한다.
- 리덕스는 보일러 플레이트, 즉 어떤 일을 하기 위해 꼭 작성해야 하는 (상용구) 코드를 많이 요구한다.

공식문서에서는 RTK는 <span class="teal">리덕스 로직을 작성하는 표준방식이 되기 위한 의도</span>로 만들어졌다고 한다. 핵심은 <span class="mediumblue">기존 리덕스의 복잡함을 낮추고 사용성을 높이는 것</span>이다. 리액트가 CRA(Create React App)을 통해서 개발 접근성을 높였듯이 RKT도 복잡한 리덕스 설정 과정을 포함해서 추상화를 시도한다.

```bash
# 설치 방법
npm install @reduxjs/toolkit
```

slice.js 라는 폴더를 만듦

```jsx
const slice = createSlice({

});

const { actions, reducer } = slice;

// 위의 코드를 아래와 같이 한 번에 작성 가능하다.

import { createSlice } from '@reduxjs/toolkit';

const { actions, reducer } = createSlice({

});

export {
  actions,
  reducer,
};
```

# 🔴 createSlice
기존에는 리덕스를 구현하기 위해서 아래의 파일들을 필요로 했다.

```bash
🗂 src
    ├── store.js
    ├── actions.js             
    └── reducer.js
```

createSlice 는 initial state, reducer 함수의 객체 및 slice name 을 받아 reducers 및 state 에 해당하는 action creators 및 action type 을 자동으로 생성해주는 함수이다.

<details>
<summary class="black">클릭시 App.jsx 전체 코드</summary>
<div markdown="1">

```jsx
// App.jsx
import {
  Routes,
  Route,
  Link,
} from 'react-router-dom';

import { useDispatch } from 'react-redux';

import HomePage from './HomePage';
import AboutPage from './AboutPage';
import NotFoundPage from './NotFoundPage';
import RestaurantsPage from './RestaurantsPage';
import RestaurantPage from './RestaurantPage';
import LoginPage from './LoginPage';

import { setAccessToken } from './actions';

import { loadItem } from './services/storage';

export default function App() {
  const dispatch = useDispatch();

  // TODO: localStorage 에서 accessToken 가져오기
  const accessToken = loadItem('accessToken');
  if (accessToken) {
    dispatch(setAccessToken(accessToken));
  }

  return (
    <div>
      <header>
        <h1>
          <Link to="/">헤더 영역</Link>
        </h1>
      </header>
      <Routes>
        <Route path="/" element={<HomePage />} />
        <Route path="/about" element={<AboutPage />} />
        <Route path="/login" element={<LoginPage />} />
        <Route path="/restaurants" element={<RestaurantsPage />} />
        <Route path="/restaurants/:id" element={<RestaurantPage />} />
        <Route path="*" element={<NotFoundPage />} />
      </Routes>
    </div>
  );
}
```
</div>
</details>

```jsx
// App.jsx
// ......
import { setAccessToken } from './actions';

import { loadItem } from './services/storage';

export default function App() {
  const dispatch = useDispatch();

  // TODO: localStorage 에서 accessToken 가져오기
  const accessToken = loadItem('accessToken');
  if (accessToken) {
    dispatch(setAccessToken(accessToken));
  }

    return (
    <div>
      <header>
        <h1>
          <Link to="/">헤더 영역</Link>
        </h1>
      </header>
      <Routes>
        <Route path="/" element={<HomePage />} />
        <Route path="/about" element={<AboutPage />} />
        <Route path="/login" element={<LoginPage />} />
        <Route path="/restaurants" element={<RestaurantsPage />} />
        <Route path="/restaurants/:id" element={<RestaurantPage />} />
        <Route path="*" element={<NotFoundPage />} />
      </Routes>
    </div>
  );
}
```

위의 App.jsx 코드에서 localStorage 에 accessToken 이 있다면 이를 accessToken 이라는 변수에 담고, 이를 <u>dispatch(setAccessToken(accessToken));</u> 를 통해 <span class="mediumblue">리듀서에 액션 객체를 전달</span>하게 된다.

<details>
<summary class="black">클릭시 actions.js 전체 코드</summary>
<div markdown="1">

```jsx
// actions.js
import {
  fetchRegions,
  fetchCategories,
  fetchRestaurants,
  fetchRestaurant,
  postLogin,
  postReview,
} from './services/api';

import { saveItem } from './services/storage';

export function setRegions(regions) {
  return {
    type: 'setRegions',
    payload: { regions },
  };
}

export function setCategories(categories) {
  return {
    type: 'setCategories',
    payload: { categories },
  };
}

export function setRestaurants(restaurants) {
  return {
    type: 'setRestaurants',
    payload: { restaurants },
  };
}

export function setRestaurant(restaurant) {
  return {
    type: 'setRestaurant',
    payload: { restaurant },
  };
}

export function selectRegion(regionId) {
  return {
    type: 'selectRegion',
    payload: { regionId },
  };
}

export function selectCategory(categoryId) {
  return {
    type: 'selectCategory',
    payload: { categoryId },
  };
}

export function loadInitialData() {
  return async (dispatch) => {
    const regions = await fetchRegions();
    dispatch(setRegions(regions));

    const categories = await fetchCategories();
    dispatch(setCategories(categories));
  };
}

export function loadRestaurants() {
  return async (dispatch, getState) => {
    const {
      selectedRegion: region,
      selectedCategory: category,
    } = getState();

    if (!region || !category) { return; }

    const restaurants = await fetchRestaurants({
      regionName: region.name,
      categoryId: category.id,
    });

    dispatch(setRestaurants(restaurants));
  };
}

export function loadRestaurant({ restaurantId }) {
  return async (dispatch) => {
    dispatch(setRestaurant({ reviews: [] }));

    const restaurant = await fetchRestaurant({ restaurantId });

    dispatch(setRestaurant(restaurant));
  };
}

export function changeLoginField({ name, value }) {
  return {
    type: 'changeLoginField',
    payload: { name, value },
  };
}

export function setAccessToken(accessToken) {
  return {
    type: 'setAccessToken',
    payload: { accessToken },
  };
}

export function requestLogin() {
  return async (dispatch, getState) => {
    const { loginFields: { email, password } } = getState();
    try {
      const accessToken = await postLogin({ email, password });
      // TODO: 로그인 성공하면 -> localStorage 에 저장
      saveItem('accessToken', accessToken);

      dispatch(setAccessToken(accessToken));
    } catch (e) {
      console.error(e);
    }
  };
}

export function logout() {
  return {
    type: 'logout',
  };
}

export function changeReviewField({ name, value }) {
  return {
    type: 'changeReviewField',
    payload: { name, value },
  };
}

export function clearReviewFields() {
  return {
    type: 'clearReviewFields',
  };
}

export function setReviews(reviews) {
  return {
    type: 'setReviews',
    payload: { reviews },
  };
}

export function loadReview({ restaurantId }) {
  return async (dispatch) => {
    const restaurant = await fetchRestaurant({ restaurantId });

    dispatch(setReviews(restaurant.reviews));
  };
}

export function sendReview({ restaurantId }) {
  return async (dispatch, getState) => {
    const {
      accessToken, reviewFields: { score, description },
    } = getState();

    // 1. 먼저 지운다.

    await postReview({
      accessToken, restaurantId, score, description,
    });

    // 2. 완료가 되면 지운다.

    await dispatch(loadReview({ restaurantId }));
    dispatch(clearReviewFields());

    // 3. 업데이트가 끝나면 지운다.
  };
}
```
</div>
</details>

```jsx
// actions.js
import {
  fetchRegions,
  fetchCategories,
  fetchRestaurants,
  fetchRestaurant,
  postLogin,
  postReview,
} from './services/api';
// ......
export function setAccessToken(accessToken) {
  return {
    type: 'setAccessToken',
    payload: { accessToken },
  };
}
// ......
```

위의 actions.js 의 코드에서 볼 수 있듯이 <u>setAccessToken 함수</u>를 실행하면 <span class="forestgreen">type 과 payload 가 프로퍼티 키로 존재하는 액션 객체</span>를 반환하여 이를 리듀서에 전달하게 된다.

<details>
<summary class="black">클릭시 reducer.js 전체 코드</summary>
<div markdown="1">

```jsx
// reducer.js
import { equal } from './utils';

const initialReviewFields = {
  score: '',
  description: '',
};

const initialState = {
  regions: [],
  categories: [],
  restaurants: [],
  restaurant: {
    reviews: [],
  },
  selectedRegion: null,
  selectedCategory: null,
  loginFields: {
    email: '',
    password: '',
  },
  accessToken: '',
  reviewFields: {
    ...initialReviewFields,
  },
};

const reducers = {
  setRegions(state, { payload: { regions } }) {
    return {
      ...state,
      regions,
    };
  },

  setCategories(state, { payload: { categories } }) {
    return {
      ...state,
      categories,
    };
  },

  setRestaurants(state, { payload: { restaurants } }) {
    return {
      ...state,
      restaurants,
    };
  },

  setRestaurant(state, { payload: { restaurant } }) {
    return {
      ...state,
      restaurant: {
        ...restaurant,
        reviews: [...restaurant.reviews].sort((a, b) => b.id - a.id),
      },
    };
  },

  selectRegion(state, { payload: { regionId } }) {
    const { regions } = state;
    return {
      ...state,
      selectedRegion: regions.find(equal('id', regionId)),
    };
  },

  selectCategory(state, { payload: { categoryId } }) {
    const { categories } = state;
    return {
      ...state,
      selectedCategory: categories.find(equal('id', categoryId)),
    };
  },

  changeLoginField(state, { payload: { name, value } }) {
    return {
      ...state,
      loginFields: {
        ...state.loginFields,
        [name]: value,
      },
    };
  },

  setAccessToken(state, { payload: { accessToken } }) {
    return {
      ...state,
      accessToken,
    };
  },

  logout(state) {
    return {
      ...state,
      accessToken: '',
    };
  },

  changeReviewField(state, { payload: { name, value } }) {
    return {
      ...state,
      reviewFields: {
        ...state.reviewFields,
        [name]: value,
      },
    };
  },

  clearReviewFields(state) {
    return {
      ...state,
      reviewFields: {
        ...initialReviewFields,
      },
    };
  },

  setReviews(state, { payload: { reviews } }) {
    const { restaurant } = state;

    return {
      ...state,
      restaurant: {
        ...restaurant,
        reviews: [...reviews].sort((a, b) => b.id - a.id),
      },
    };
  },
};

function defaultReducer(state) {
  return state;
}

export default function reducer(state = initialState, action = {}) {
  return (reducers[action.type] || defaultReducer)(state, action);
}
```
</div>
</details>

```jsx
// reducer.js
import { equal } from './utils';

const initialReviewFields = {
  score: '',
  description: '',
};

const initialState = {
  regions: [],
  categories: [],
  restaurants: [],
  restaurant: {
    reviews: [],
  },
  selectedRegion: null,
  selectedCategory: null,
  loginFields: {
    email: '',
    password: '',
  },
  accessToken: '',
  reviewFields: {
    ...initialReviewFields,
  },
};
// ......
const reducers = {
  // ......
  setAccessToken(state, { payload: { accessToken } }) {
    return {
      ...state,
      accessToken,
    };
  },
  // ......
};

function defaultReducer(state) {
  return state;
}

export default function reducer(state = initialState, action = {}) {
  return (reducers[action.type] || defaultReducer)(state, action);
}
```

function reducer 가 실행되면 <u>액션 객체</u>가 <span class="forestgreen">action 이라는 매개변수에</span> 담기게 된다. 그래서 reducers 의 프로퍼티 키와 action.type 이 일치하면 <span class="mediumblue">reducers 의 메서드가 실행</span>되고 아니면 defaultReducer 함수가 실행된다. 그렇게 function reducer 의 반환값으로, state 가 업데이트된다.

이제 createSlice 를 사용하여 이러한 파일 구조를 단축할 수 있다.

# 🔴 configureStore
(공식 문서) : [Included Default Middleware](https://redux-toolkit.js.org/api/getDefaultMiddleware#included-default-middleware)

`configureStore`는 리덕스 코어 라이브러리의 표준 함수인 createStore를 추상화한 것이다. 더 나은 개발 환경을 위해 기존 리덕스의 번거로운 기본 설정 과정을 자동화한다.

```jsx
// store.js
import { configureStore } from '@reduxjs/toolkit'

import rootReducer from './reducers'

const store = configureStore({ reducer: rootReducer })
```

위처럼 선언하면 기본 미들웨어로 redux-thunk를 추가하고 개발 환경에서 리덕스 개발자 도구를 활성화해준다.

아래의 예제는 configureStore를 사용한 전체적인 구성을 담고 있다.

```jsx
import logger from 'redux-logger'
import { reduxBatch } from '@manaflair/redux-batch'

import todosReducer from './todos/todosReducer'
import visibilityReducer from './visibility/visibilityReducer'

const rootReducer = {
  todos: todosReducer,
  visibility: visibilityReducer,
}

const preloadedState = {
  todos: [
    {
      text: 'Eat food',
      completed: true,
    },
    {
      text: 'Exercise',
      completed: false,
    },
  ],
  visibilityFilter: 'SHOW_COMPLETED',
}

const store = configureStore({
  reducer,
  middleware: (getDefaultMiddleware) => getDefaultMiddleware().concat(logger),
  devTools: process.env.NODE_ENV !== 'production',
  preloadedState,
  enhancers: [reduxBatch],
})
```

<span class="crimson">configureStore 함수</span>는 reducer, middleware, devTools, preloadedState, enhancers 정보를 전달한다. 

리듀서에는 단일 함수를 전달하여 스토어의 루트 리듀서로 바로 사용할 수 있다. 또한 슬라이스 리듀서들로 구성된 객체를 전달하여 루트 리듀서를 생성하도록 할 수 있다. 이런 경우에는 내부적으로 기존 리덕스 combineReducers 함수를 사용해서 자동적으로 병합하여 루트 리듀서를 생성한다.

middleware는 기본적으로는 리덕스 미들웨어를 담는 배열이다. 사용할 모든 미들웨어를 배열에 담아서 명시적으로 작성할 수 있다. 그렇지 않으면 getDefaultMiddleware를 호출하게 된다. 사용자 정의, 커스텀 미들웨어를 추가하며서 동시에 리덕스 기본 미들웨어를 사용할 때 유용한 방법이다.

devTools는 불리언 값으로 리덕스 개발자 도구를 끄거나 켠다.

preloadedState는 스토어의 초기값을 설정할 수 있다.

enhancers는 기본적으로는 배열이지만 콜백 함수로 정의하기도 한다. 예를 들어 아래와 같이 작성하면 개발자가 원하는 store enhancer를 미들웨어가 적용되는 순서보다 앞서서 추가할 수 있다.

```jsx
const store = configureStore({
  ...
  enhancers: (defaultEnhancers) => [reduxBatch, ...defaultEnhancers],
})

// [reduxBatch, applyMiddleware, devToolsExtension]
```




<!-- ① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨-->

<!-- ### 2. Link 넣기

```

유형 1: (설명어를 입력) : [gunhee's coding blog](https://gunhee-jeong.github.io/)
유형 2: (URL 자동연결) : <https://gunhee-jeong.github.io/>
유형 3: (동일 파일 내 '문단으로 이동') : [1. Header로 이동](###-1-header)

```

```bash
.next/static
        ├── AbmKMg9BFeVUuJ7lsQ1w8
        ├── chunks                 // 여러 페이지에서 공통으로 사용되는 번들 파일
        │       └──  pages         // 각 페이지의 번들 파일
        ├── runtime                // 웹팩과 next의 런타임과 관련된 번들 파일
        ├── css                    // 애플리케이션의 모든 페이지에 대한 글로벌 CSS 파일
        └── media                  // 정적으로 가져온 이미지 next/image가 여기에 해시 및 복사
        
```

<details>
<summary class="black">클릭시 코드</summary>
<div markdown="1">

```jsx
// helloWorld!
const hello = 'hi';
```
</div>
</details>

1. 특수문자를 제거
2. 스페이스는 -로 바꾸고
3. 대문자는 소문자로!
   그래서 ### 1. Header -> #1-header

## Link: [google][https://www.google.com/]

### 3. 수평선

```

---

```

---

### 4. 라인 바꾸기

```

스페이스바를 2번 눌러주면 다음칸으로
이동할 수 있어요!

```

---

스페이스바를 2번 눌러주면
다음칸으로 이동할 수 있어요!

### 5. list 만들기

```

1. 1번
2. 2번
3. 3번

- 순서없는 list
  - 순서없는 list
    - 순서없는 list

```

1. 1번
2. 2번
3. 3번

- 순서없는 list
  - 순서없는 list
    - 순서없는 list

---

### 6. font 관련

```

**진하게** -> 볼드
_기울여서_ -> 이탤릭체
~~취소선~~ -> 취소선

<ul>밑줄넣기</ul> -> 밑줄
<span style="color:red">빨간 글씨</span> -> 글자색
이것이 `인라인` 입니다 -> 인라인 코드
```

**진하게** -> 볼드
_기울여서_ -> 이탤릭체
~~취소선~~ -> 취소선
<u>밑줄넣기</u> -> 밑줄
<span style="color:red">빨간 글씨</span>
이것이 `인라인` 입니다 -> 인라인 코드

---

### 7. 인용구문

```
> coding
>
> > JavaScript
> >
> > > 내가 프짱!
```

> coding
>
> > JavaScript
> >
> > > 내가 프짱!

---

### 8. 이미지 삽입

```
유형1: ('사이즈를 조절' -> HTML 태그 사용) : <img src="https://gunhee-jeong.github.io/assets/images/blogLogo.png" width="300" height="200">
유형2: (이미지 삽입 후 -> 링크 걸기)
[![이미지](https://gunhee-jeong.github.io/assets/images/blogLogo/blogLogo.png)](https://gunhee-jeong.github.io/)
```

유형1: ('사이즈를 조절' -> HTML 태그 사용) : <img src="https://gunhee-jeong.github.io/assets/images/blogLogo.png" width="300" height="200">
유형2: (이미지 삽입 후 -> 링크 걸기)
[![이미지](https://gunhee-jeong.github.io/assets/images/blogLogo.png)](https://gunhee-jeong.github.io/)

### 9. 표 만들기

```
||국어|영어|
| :--- | ---: | :--: |
|건희 | 100점 | 100점
|철수 | 100점 | 100점
```

|      |  국어 | 영어  |
| :--- | ----: | :---: |
| 건희 | 100점 | 100점 |
| 철수 | 100점 | 100점 |

> - header를 넣고 싶은 경우 ---을 사용하고 :을 이용하여 정렬에 사용함!

### 10. 토글 만들기

```
<details>
<summary>여기를 누르세요</summary>
<div markdown="1">
숨겨진 내용
</div>
</details>
```

<details>
<summary>여기를 누르세요</summary>
<div markdown="1">
숨겨진 내용
</div>
</details> -->
