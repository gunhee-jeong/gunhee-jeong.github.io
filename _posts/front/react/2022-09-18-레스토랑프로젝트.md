---
layout: single
title: "레스토랑 프로젝트"
# categories: Git
categories:
  - React # HTML CSS JavaScript Server Algorithm Wecodes Programmers CS Github Blog
tag: [코드숨] #tag는 여러개 가능함
toc: true #table of content 기능!
toc_sticky: true
author_profile: true #blog 글안에서는 author_profile이 따라다니지 않도록 설정함
date: 2022-09-18T09:30:00+09:00
# sidebar:
# nav: "docs" #네비게이션에 있는 docs를 의미함
---
<style>
.crimson {
  color: crimson;
  font-weight: bold;
}

.mediumblue {
  color: mediumblue;
  font-weight: bold;
}

.forestgreen {
  color: forestgreen;
  font-weight: bold;
}
</style>

# 코드숨 레스토랑 프로젝트
# 🔴 파일 구조
① __ mocks __
- react-redux.js

② fixtures

③ public

④ src

# 🔴 기본적인 컴포넌트의 구조
## 🟠 App 컴포넌트
```jsx
// App.jsx
import {
  Routes,
  Route,
  Link,
} from 'react-router-dom';

import HomePage from './HomePage';
import AboutPage from './AboutPage';
import NotFoundPage from './NotFoundPage';
import RestaurantsPage from './RestaurantsPage';
import RestaurantPage from './RestaurantPage';

export default function App() {
  return (
    <div>
      <header>
        <h1>
          <Link to="/">헤더 영역</Link>
        </h1>
      </header>
      <Routes>
        <Route path="/" element={<HomePage />} />
        <Route path="/about" element={<AboutPage />} />
        <Route path="/restaurants" element={<RestaurantsPage />} />
        <Route path="/restaurants/:id" element={<RestaurantPage />} />
        <Route path="*" element={<NotFoundPage />} />
      </Routes>
    </div>
  );
}
```

## 🟠 HomePage 컴포넌트
<img src="https://user-images.githubusercontent.com/87808288/190881020-fb2855cf-9619-4cfe-99ff-81f7c97f4e3e.png" width="30%">

위의 이미지는 <u>첫 홈화면</u>을 보여주고 있다. <span class="forestgreen">"About"을 클릭하면 "/about"</span>으로 라우팅을 하여 AboutPage 컴포넌트를 렌더링하고, <span class="forestgreen">"Restaurants"를 클릭하면 "/restaurants"</span>으로 라우팅하여 RestaurantsPage 컴포넌트를 렌더링하게 된다. HomePage 컴포넌트의 코드는 아래와 같다.

```jsx
// HomePage.jsx
import { Link } from 'react-router-dom';

export default function HomePage() {
  return (
    <div>
      <h2>Home</h2>
      <ul>
        <li><Link to="/about">About</Link></li>
        <li><Link to="/restaurants">Restaurants</Link></li>
      </ul>
    </div>
  );
}
```

## 🟠 RestaurantsPage 컴포넌트
```jsx
// RestaurantsPage.jsx
import { useEffect } from 'react';

import { useNavigate } from 'react-router-dom';

import { useDispatch } from 'react-redux';

import RegionsContainer from './RegionsContainer';
import CategoriesContainer from './CategoriesContainer';
import RestaurantsContainer from './RestaurantsContainer';

import {
  loadInitialData,
} from './actions';

export default function RestaurantsPage() {
  const navigate = useNavigate();

  const dispatch = useDispatch();

  useEffect(() => {
    dispatch(loadInitialData());
  }, []);

  function handleClickRestaurants(restaurant) {
    const url = `/restaurants/${restaurant.id}`;
    navigate(url);
  }

  return (
    <div>
      <RegionsContainer />
      <CategoriesContainer />
      <RestaurantsContainer onClickRestaurant={handleClickRestaurants} />
    </div>
  );
}
```

<img src="https://user-images.githubusercontent.com/87808288/190881141-aa6e141e-4692-47ac-8325-9083ba32cfa6.png" width="30%">
<img src="https://user-images.githubusercontent.com/87808288/190881226-7413a184-fd55-47fd-81d8-94e7ebb5133d.png" width="27%">

위의 이미지는 "Restaurants"를 클릭시 <span class="mediumblue">RestaurantsPage 컴포넌트</span>가 랜더링된 모습이다.

RestaurantsPage 컴포넌트는 <u>지역(RegionsContainer)</u>, <u>카테고리(CategoriesContainer)</u>, <u>레스토랑(RestaurantsContainer)</u> 3개의 컴포넌트로 구성되어 있다.
- RestaurantsPage -> RegionsContainer, CategoriesContainer, RestaurantsContainer

또한 `RestaurantsPage` 는 '<span class="crimson">react-redux</span>'를 알고있고 '<span class="crimson">react-router-dom</span>'을 알고 있는 컴포넌트이다.
- RestaurantsPage 에서 초기 랜더링 시 'react-redux'의 useDispatch를 사용하여 RegionsContainer와 CategoriesContainer에서 사용할 data를 store에 전달한다.
- RestaurantsPage 에서 'react-router-dom'의 useNavigate를 사용하여 RestaurantsContainer 에서 클릭 이벤트가 발생시 data를 함수로 받아 URL을 변경하게 된다.

`RestaurantsPage 컴포넌트`는 랜더링되면 <u>처음에 한 번 fetch</u>가 이루어지면서 서버와 통신하여 <span class="crimson">dispatch를 통해 store에 해당 데이터를 업데이트</span>한다. 그렇게 지역과 카테고리에서 사용할 데이터가 store에 저장되어있고 <span class="forestgreen">RegionsContainer</span>와 <span class="forestgreen">CategoriesContainer</span>는 <span class="mediumblue">useSelector</span>를 사용하여 store에 저장된 데이터를 위의 첫 번째 이미지에서 보이는 것과 같이 화면을 랜더링한다.

### 🟡 RegionsContainer
```jsx
// RegionsContainer
import { useDispatch, useSelector } from 'react-redux';

import {
  selectRegion,
  loadRestaurants,
} from './actions';

import { get } from './utils';

export default function RegionsContainer() {
  const dispatch = useDispatch(() => dispatch);

  const regions = useSelector(get('regions'));
  const selectedRegion = useSelector(get('selectedRegion'));

  function handleClick(regionId) {
    dispatch(selectRegion(regionId));
    dispatch(loadRestaurants());
  }

  return (
    <ul>
      {regions.map((region) => (
        <li key={region.id}>
          <button
            type="button"
            onClick={() => handleClick(region.id)}
          >
            {region.name}
            {selectedRegion
              && region.id === selectedRegion.id ? '(V)' : null}
          </button>
        </li>
      ))}
    </ul>
  );
}
```

기본적으로 ResetaurantsPage 안에 위치한 RegionsContainer 와 <u>CategoriesContainer</u> 는 <u>RestaurantsPage</u> 에서 아래의 코드와 같이 초기 랜더링 시 store에 전달된 data를 사용해야 하기 때문에 'react-redux'의 <span class="mediumblue">useSelector</span> 를 사용한다.

```jsx
// RestaurantsPage.jsx
useEffect(() => {
  dispatch(loadInitialData());
}, []);
```

또한 "지역" 과 "카테고리"의 버튼들 중 어떤 버튼을 선택했는지 이를 알고 저장해야 RestaurantsContainer 에서 레스토랑 목록을 data로 받을 수 있다. 그렇기 때문에 <u>RegionsContainer</u> 와 <u>CategoriesContainer</u> 에서는 'react-redux' 의 <span class="mediumblue">useDispatch</span> 또한 사용하게 된다. 버튼에 onClick 이벤트로 함수에는 선택된 버튼의 id를 전달하고 다시 이를 dispatch 를 사용하여 store 를 갱신한다. RegionsContainer 의 코드는 아래와 같다.

```jsx
// RegionsContainer.jsx
import { useDispatch, useSelector } from 'react-redux';

import {
  selectRegion,
  loadRestaurants,
} from './actions';

import { get } from './utils';

export default function RegionsContainer() {
  const dispatch = useDispatch(() => dispatch);

  const regions = useSelector(get('regions'));
  const selectedRegion = useSelector(get('selectedRegion'));

  function handleClick(regionId) {
    dispatch(selectRegion(regionId));
    dispatch(loadRestaurants());
  }

  return (
    <ul>
      {regions.map((region) => (
        <li key={region.id}>
          <button
            type="button"
            onClick={() => handleClick(region.id)}
          >
            {region.name}
            {selectedRegion
              && region.id === selectedRegion.id ? '(V)' : null}
          </button>
        </li>
      ))}
    </ul>
  );
}
```

<u>버튼의 onClick 이벤트</u>로 인해 실행되는 함수를 아래에서 다시 한 번 살펴보자.

```jsx
// RegionsContainer.jsx
function handleClick(regionId) {
  dispatch(selectRegion(regionId));
  dispatch(loadRestaurants());
}
```

<u>선택된 버튼의 지역을 저장</u>해야하기 때문에 actions의 <span class="forestgreen">action creater(selectRegion) 에게 regionId 를 인자로 전달</span>한다. 그리고 밑에는 dipatch가 한 번 더 호출되는데 loadRestaurants 함수는 아래의 코드와 같다.

```jsx
// actions.js
export function loadRestaurants() {
  return async (dispatch, getState) => {
    const {
      selectedRegion: region,
      selectedCategory: category,
    } = getState();

    if (!region || !category) { return; }

    const restaurants = await fetchRestaurants({
      regionName: region.name,
      categoryId: category.id,
    });

    dispatch(setRestaurants(restaurants));
  };
}
```

RegionsContainer 에서 호출된 `loadRestaurants 함수`는 <span class="mediumblue">함수를 반환</span>한다. <u>기본적으로 dispatch를 호출하면 그 인자로 액션 객체를</u> 넣었지만 loadRestaurants 은 함수를 반환한다. <span class="crimson">리덕스 미들웨어</span>는 dispatch 된 액션이 <u><span class="mediumblue">리듀서</span>에 도달하기 전에 중간 영역에서 사용자의 목적에 맞게 <span class="forestgreen">특정 조건이 충족될 때에 액션이 실행</span>되도록</u> 한다.

<span class="forestgreen">지역</span>과 <span class="forestgreen">카테고리</span>를 클릭하여 <u>해당 정보에 맞는 레스토랑을 랜더링하기 위해서는</u> 어떤 지역을 클릭했고 어떤 카테고리를 클릭했는지 알아야한다. 그래서 `RegionsContainer`와 `CategoriesContainer`에 <u>click 이벤트</u>를 설정하여, 클릭시 선택한 data의 <span class="mediumblue">id값을 dispatch로 전달</span>하여 <span class="crimson">store를 갱신</span>한다. 또한 클릭 마다 선택한 지역이나 카테고리가 변경되기 때문에 그에 맞게 RestaurantsContainer의 내용이 변경될 수 있도록 <span class="mediumblue">dispatch에 함수를 반환하는 loadRestaurants라는 함수</span>를 실행시켜 변경된 내용을 새로 <span class="crimson">fetch 받아 store를 갱신</span>할 수 있도록 한다. 그러면 ReataurantsContainer에서는 useSelecter를 사용하여 store에 저장된 restaurants를 사용하여 위의 두 번째 이미지와 같이 restaurants 목록을 화면에 랜더링하게 된다.

### 🟡 RestaurantsContainer 컴포넌트
<img src="https://user-images.githubusercontent.com/87808288/190881226-7413a184-fd55-47fd-81d8-94e7ebb5133d.png" width="27%"><img src="https://user-images.githubusercontent.com/87808288/190957580-40c02a13-b811-42d9-a313-b313126ae771.png" width="40%">

`RestaurantsContainer` 의 영역은 위의 첫 번째 사진에서 <u>식당의 목록이 나오는 부분</u>에 해당한다. 그리고 <span class="forestgreen">양천주가를 클릭</span>하면 '/restaurant/1' 에 해당하는 <span class="mediumblue">RestaurantPage 컴포넌트가 랜더링</span>되게 된다. RestaurantsContainer 의 코드는 아래와 같다.

```jsx
// RestaurantsContainer.jsx
import { useDispatch, useSelector } from 'react-redux';

import { get } from './utils';

export default function RestaurantsContainer({ onClickRestaurant }) {
  const dispatch = useDispatch(() => dispatch);

  const restaurants = useSelector(get('restaurants'));

  function handleClick(restaurant) {
    return (event) => {
      event.preventDefault();
      onClickRestaurant(restaurant);
    };
  }

  return (
    <ul>
      {restaurants.map((restaurant) => (
        <li key={restaurant.id}>
          <a
            href="/restaurants/1"
            onClick={handleClick(restaurant)}
          >
            {restaurant.name}
          </a>
        </li>
      ))}
    </ul>
  );
}
```

RestaurantsContainer 에서는 레스토랑 목록 중 하나를 클릭하면 <u>onClick 이벤트</u>가 발생하며 <span class="crimson">handleClick 함수가 반환한 함수가 실행</span>된다. <span class="forestgreen">preventDefault</span> 를 하는 것은 클릭시 a 태그가 href 를 제출하는데 이 부분은 가독성을 위한 부분이며 기능적으로는 구현되지 않아야 하는 부분이므로 preventDefault 를 사용하여 막아준다. 그리고 RestaurantsContainer 의 <u>상위 컴포넌트인 RestaurantsPage</u> 에서 props 로 <span class="forestgreen">전달받은 onClickRestaurant 함수를 호출</span>하며 인자로 restaurant 객체를 넣어주게 된다. 아래의 코드는 RestaurantsPage의 코드이다.

```jsx
// RestaurantsPage.jsx
export default function RestaurantsPage() {
  const navigate = useNavigate();

  const dispatch = useDispatch();

  useEffect(() => {
    dispatch(loadInitialData());
  }, []);

  function handleClickRestaurants(restaurant) {
    // TODO: 이동?
    const url = `/restaurants/${restaurant.id}`;
    navigate(url);
  }

  return (
    <div>
      <RegionsContainer />
      <CategoriesContainer />
      <RestaurantsContainer onClickRestaurant={handleClickRestaurants} />
    </div>
  );
}
```

위의 코드에서 ReataurantsContainer 에서 handleClickRestaurant 함수를 호출하며 전해준 <span class="forestgreen">restaurant 객체에서 id 를</span> 꺼내어 <u>URL 의 pathname을 새롭게 만들어</u> 이를 <span class="mediumblue">navigate 에 넣어 호출</span>하게 된다. 이렇게 URL이 바뀌면서 <u>RestaurantPage 컴포넌트를 새롭게 랜더링</u>하게 된다. 이렇게 `RestaurantsContainer` 에서는 <u>'react-router-dom' 의 존재를 알지 못하며</u> <span class="crimson">의존성을 갖지 않게</span> 된다.

## 🟠 RestaurantPage 컴포넌트
RestaurantPage -> RestaurantContainer -> RestaurantDetail, ReviewForm

RestaurantsContainer 에서 레스토랑(이름)을 클릭하여, 상세 페이지인 `RestaurantPage` 가 랜더링 되었다. 코드는 아래와 같다.

```jsx
// ResetaurantPage.jsx
import { useParams } from 'react-router-dom';

import RestaurantContainer from './RestaurantContainer';

export default function RestaurantPage({ params }) {
  const { id } = params || useParams();

  return (
    <RestaurantContainer restaurantId={id} />
  );
}
```

RestaurantPage 에서는 <u>'react-router-dom' 만을 알고</u> 있고, <span class="mediumblue">useParams</span> 를 사용하여 id 값을 변수에 담아 <u>ReestaurantContainer 에 props 로 전달</u>한다.

### 🟡 RestaurantContainer 컴포넌트
아래는 RestaurantContainer 의 코드이다. RestaurantContainer 는 <u>'react-router-dom' 을 알지 못한다</u>. 하지만 RestaurantContainer 의 상위 컴포넌트인 <span class="forestgreen">RestaurantPage 에서 props 로 전달한 id 값</span>을 가지고 <span class="crimson">dispatch 에 loadRestaurant</span> 함수를 호출하여 fetch 를 이용해 store를 갱신한다.

```jsx
// RestaurantContainer.jsx
import { useEffect } from 'react';

import { useDispatch, useSelector } from 'react-redux';

import {
  loadRestaurant,
} from './actions';

import { get } from './utils';

import RestaurantDetail from './RestaurantDetail';

export default function RestaurantContainer({ restaurantId }) {
  const dispatch = useDispatch();

  useEffect(() => {
    dispatch(loadRestaurant({ restaurantId }));
  }, []);

  const restaurant = useSelector(get('restaurant'));

  if (!restaurant) {
    return (
      <p>Loading......</p>
    );
  }

  return (
    <RestaurantDetail restaurant={restaurant} />
  );
}
```

아래의 코드는 loadRestaurant 함수가 선언된 코드이다.

```jsx
// actions.js
export function loadRestaurant({ restaurantId }) {
  return async (dispatch) => {
    dispatch(setRestaurant(null));

    const restaurant = await fetchRestaurant({ restaurantId });

    dispatch(setRestaurant(restaurant));
  };
}
```

<span class="mediumblue">RORO 패턴</span>으로 선언된 함수 `loadRestaurant` 는 <span class="forestgreen">함수를 반환하는 함수</span>로, <u>dispatch(setRestaurant(null));</u> 를 사용하여 기존의 값이 화면에 랜더링되지 않도록 <span class="crimson">로딩 처리</span>를 진행하고 <u>fetchRestaurant 함수를 호출</u>하면서 <span class="forestgreen">인자로 { restaurantId: 1 } 객체를</span> 보내어 RORO 패턴으로 fetch 함수를 호출한다. fetchRestaurant 가 선언된 코드는 아래와 같다.

```jsx
// /src/services/api.js

export async function fetchRestaurant({ restaurantId }) {
  const url = 'https://eatgo-customer-api.ahastudio.com'
  + `/restaurants/${restaurantId}`;
  const response = await fetch(url);
  const data = await response.json();
  return data;
}
```

사용자가 RestaurantsContainer 에서 레스토랑(이름)을 클릭하면 RestaurantPage 가 랜더링되고 그 안의 <u>RestaurantContainer 가 랜더링까지 몇 초의 로딩이 지연</u>될 수 있다. `RestaurantContainer` 가 id 값을 가지고 <span class="mediumblue">fetch 를 받으면서 store를 갱신</span>시키고 <span class="forestgreen">useSelector 로 restaurant data 를 가져오는 사이에 로딩이 필요</span>하므로 그 처리를 하기 위해 아래의 코드가 필요하다.

```jsx
// RestaurantContainer.jsx

const restaurant = useSelector(get('restaurant'));

  if (!restaurant) {
    return (
      <p>Loading......</p>
    );
  }

  return (
    <RestaurantDetail restaurant={restaurant} />
  );
}
```

useSelector 로 받아온 <u>restaurant 이 null</u> 일 경우 <span class="forestgreen">조건문이 true</span> 가 되어 "Loading......" 이 화면에 랜더링되었다가 fetch 를 통해 값을 반환받고 이를 dispatch 로 전달하여 store 를 갱신하면 조건문이 false 로 통과하여 RestaurantDetail 컴포넌트를 랜더링하게 된다.

#### 🟢 RestaurantDetail 컴포넌트
RestaurantPage -> RestaurantContainer -> `RestaurantDetail`

RestaurantDetail 컴포넌트는 <u>랜더링만을 관심사로</u> 가지는 컴포넌트이다. RestaurantContainer 컴포넌트에서 <u>dispatch(loadRestaurant({ restaurantId }));</u>를 통해서 fetch를 발생시켜 새롭게 <span class="mediumblue">저장한 data</span>(레스토랑 세부정보)를 RestaurantDetail로 <span class="forestgreen">props를 통해 전달</span>한다. 그리고 그 data의 대략적인 내용은 아래의 이미지와 같다.  
<img src="https://user-images.githubusercontent.com/87808288/190889775-c4802e2c-6a6f-48f0-a0b7-e4f8b2d51352.png" width="30%">

```jsx
// RestaurantDetail.jsx
import MenuItems from './MenuItems';

export default function RestaurantDetail({ restaurant }) {
  const { name, address, menuItems } = restaurant;

  return (
    <div>
      <h2>{name}</h2>
      <p>
        주소:
        {' '}
        {address}
      </p>
      <p>{JSON.stringify(menuItems)}</p>
      <p>{menuItems}</p> // 에러 발생
      <h3>메뉴</h3>
      <MenuItems menuItems={menuItems} />
    </div>
  );
}
```

위의 코드를 살펴보면 `RestaurantDetail`에서는 <u>RestaurantContainer에서 내려준 restaurant</u> data를 이용해 화면을 랜더링해주고 있다. 그런데 여기서 menuItems를 확인하기 위해 이를 그대로 사용하면 <span class="forestgreen">에러가 발생</span>한다. 그 이유는 <span class="crimson">menuItems가 배열</span>이기 때문이다. 그 때문에 <u>배열의 data를 우선 확인</u>하고자 할 때에는 <span class="mediumblue">JSON.stringify</span> 메서드를 사용하여 그 데이터를 바로 출력하여 확인할 수 있다.  
<img src="https://user-images.githubusercontent.com/87808288/190890105-f540f149-1469-4d58-86ec-671fc6074929.png" width="40%">

# 🔴 로그인
## 🟠 LoginPage
LoginPage -> LoginFormContainer -> LoginForm

### 🟡 LoginFormContainer
`LoginFormContainer` 는 <u>'react-redux' 를 알고</u> 있다. <span class="forestgreen">LoginForm 에서 submit 버튼을 클릭</span>하면, <u>LoginFormContainer 의 handleSubmit 함수</u>가 실행된다. 그러면 <span class="mediumblue">actions 의 requestLogin 함수가 실행</span>된다. LoginFormContainer 의 코드는 아래와 같다.

```jsx
// LoginFormContainer.jsx
import { useDispatch, useSelector } from 'react-redux';

import {
  requestLogin,
  changeLoginField,
} from './actions';

import { get } from './utils';

import LoginForm from './LoginForm';

export default function LogindFormContainer() {
  const dispatch = useDispatch();

  const { email, password } = useSelector(get('loginFields'));
  const accessToken = useSelector(get('accessToken'));

  function handleChange({ name, value }) {
    dispatch(changeLoginField(({ name, value })));
  }

  function handleSubmit() {
    dispatch(requestLogin());
  }

  return (
    <>
      <LoginForm
        fields={ { email, password } }
        onChange={handleChange}
        onSubmit={handleSubmit}
      />
      <p>{accessToken}</p>
    </>
  );
}
```

requestLogin 함수가 있는 actions 의 코드는 아래와 같다.

<span class="crimson">requestLogin 함수</span>는 <u>postLogin 을 통해 accessToken 을 받아와 저장</u>하고, 이것을 다시 localStorage 로 보내 저장하게 된다. requestLogin 에서는 <span class="mediumblue">localStorage</span> 와 <span class="mediumblue">store</span> 에 모두 accessToken 을 받아와 저장하게 된다.d

```jsx
// actions.js
export function requestLogin() {
  return async (dispatch, getState) => {
    const { loginFields: { email, password } } = getState();
    try {
      const accessToken = await postLogin({ email, password });
      // TODO: 로그인 성공하면 -> localStorage 에 저장
      localStorage.setItem('accessToken', accessToken);

      dispatch(setAccessToken(accessToken));
    } catch (e) {
      console.error(e);
    }
  };
}
```



<!-- ① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨-->

<!-- ### 2. Link 넣기

```

유형 1: (설명어를 입력) : [gunhee's coding blog](https://gunhee-jeong.github.io/)
유형 2: (URL 자동연결) : <https://gunhee-jeong.github.io/>
유형 3: (동일 파일 내 '문단으로 이동') : [1. Header로 이동](###-1-header)

```

유형 1: (설명어를 입력) : [gunhee's coding blog](https://gunhee-jeong.github.io/)
유형 2: (URL 자동연결) : <https://gunhee-jeong.github.io/>
유형 3: (동일 파일 내 '문단으로 이동') : [1. Header로 이동](#1-header)
유형 3의 방법

1. 특수문자를 제거
2. 스페이스는 -로 바꾸고
3. 대문자는 소문자로!
   그래서 ### 1. Header -> #1-header

## Link: [google][https://www.google.com/]

### 3. 수평선

```

---

```

---

### 4. 라인 바꾸기

```

스페이스바를 2번 눌러주면 다음칸으로
이동할 수 있어요!

```

---

스페이스바를 2번 눌러주면
다음칸으로 이동할 수 있어요!

### 5. list 만들기

```

1. 1번
2. 2번
3. 3번

- 순서없는 list
  - 순서없는 list
    - 순서없는 list

```

1. 1번
2. 2번
3. 3번

- 순서없는 list
  - 순서없는 list
    - 순서없는 list

---

### 6. font 관련

```

**진하게** -> 볼드
_기울여서_ -> 이탤릭체
~~취소선~~ -> 취소선

<ul>밑줄넣기</ul> -> 밑줄
<span style="color:red">빨간 글씨</span> -> 글자색
이것이 `인라인` 입니다 -> 인라인 코드
```

**진하게** -> 볼드
_기울여서_ -> 이탤릭체
~~취소선~~ -> 취소선
<u>밑줄넣기</u> -> 밑줄
<span style="color:red">빨간 글씨</span>
이것이 `인라인` 입니다 -> 인라인 코드

---

### 7. 인용구문

```
> coding
>
> > JavaScript
> >
> > > 내가 프짱!
```

> coding
>
> > JavaScript
> >
> > > 내가 프짱!

---

### 8. 이미지 삽입

```
유형1: ('사이즈를 조절' -> HTML 태그 사용) : <img src="https://gunhee-jeong.github.io/assets/images/blogLogo.png" width="300" height="200">
유형2: (이미지 삽입 후 -> 링크 걸기)
[![이미지](https://gunhee-jeong.github.io/assets/images/blogLogo/blogLogo.png)](https://gunhee-jeong.github.io/)
```

유형1: ('사이즈를 조절' -> HTML 태그 사용) : <img src="https://gunhee-jeong.github.io/assets/images/blogLogo.png" width="300" height="200">
유형2: (이미지 삽입 후 -> 링크 걸기)
[![이미지](https://gunhee-jeong.github.io/assets/images/blogLogo.png)](https://gunhee-jeong.github.io/)

### 9. 표 만들기

```
||국어|영어|
| :--- | ---: | :--: |
|건희 | 100점 | 100점
|철수 | 100점 | 100점
```

|      |  국어 | 영어  |
| :--- | ----: | :---: |
| 건희 | 100점 | 100점 |
| 철수 | 100점 | 100점 |

> - header를 넣고 싶은 경우 ---을 사용하고 :을 이용하여 정렬에 사용함!

### 10. 토글 만들기

```
<details>
<summary>여기를 누르세요</summary>
<div markdown="1">
숨겨진 내용
</div>
</details>
```

<details>
<summary>여기를 누르세요</summary>
<div markdown="1">
숨겨진 내용
</div>
</details> -->
