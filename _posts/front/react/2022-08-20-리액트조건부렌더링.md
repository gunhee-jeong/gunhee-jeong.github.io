---
layout: single
title: "리액트 조건부 렌더링"
# categories: Git
categories:
  - React # HTML CSS JavaScript Server Algorithm Wecode Programmers CS Github Blog
tag: [리액트 기초] #tag는 여러개 가능함
toc: true #table of content 기능!
toc_sticky: true
author_profile: true #blog 글안에서는 author_profile이 따라다니지 않도록 설정함
date: 2022-08-20T14:00:00+09:00
# sidebar:
# nav: "docs" #네비게이션에 있는 docs를 의미함
---
<style>
.red {
  color: red;
  font-weight: bold;
}

.tomato {
  color: tomato;
  font-weight: bold;
}

.blue {
  color: blue;
  font-weight: bold;
}

.royalblue {
  color: royalblue;
  font-weight: bold;
}

.forestgreen {
  color: forestgreen;
  font-weight: bold;
}

.darkorange {
  color: darkorange;
  font-weight: bold;
}
</style>

# 1장 단축 평가를 이용한 조건부 렌더링
<img src="https://user-images.githubusercontent.com/87808288/185731403-7241bbf4-880e-4c12-8f9a-38583eab99e3.gif" width="80%">  
위의 이미지와 같이 <u>처음 렌더링에서는 "New Add Expense" 버튼</u>이 화면에 출력된다.  
그리고 <span class="royalblue">"New Add Expense" 버튼을 click</span>하면 <span class="blue">Expnese form이 새롭게 화면에 렌더링</span>된다.  

이를 위해서는 리액트의 <span class="red">조건부 렌더링</span>이라는 것을 활용해야한다.  
우선 `App.js`는 아래와 같이 코드가 구성되어 있다.  

```jsx
// App.js
import { useState } from 'react';

import Expenses from './components/Expenses/Expenses';
import NewExpense from './components/NewExpense/NewExpense';

export default function App() {
  const DUMMY_EXPENSES = [
    {
      id: 'e1',
      title: 'Toilet Paper!!!',
      amount: 94.12,
      date: new Date(2020, 7, 14),
    },
    { id: 'e2', title: 'New TV', amount: 799.49, date: new Date(2021, 2, 12) },
    {
      id: 'e3',
      title: 'Car Insurance',
      amount: 294.67,
      date: new Date(2021, 2, 28),
    },
    {
      id: 'e4',
      title: 'New Desk (Wooden)',
      amount: 450,
      date: new Date(2021, 5, 12),
    },
  ];

  const [expenses, setExpenses] = useState(DUMMY_EXPENSES);

  function addExpenseHandler (expense) {
    setExpenses((prevExpenses) => {
      return [expense, ...prevExpenses];
    })
  }

  return (
    <div>
      <NewExpense 
        onAddExpense={addExpenseHandler}
      />
      <Expenses
        data={expenses}
      />
    </div>
  );
}
```

<u>NewExpense 컴포넌트에게 props</u>로 넘겨주는 <span class="darkorange">onAddExpense={addExpenseHandler}</span>는  
ExpenseForm에서 <span class="blue">사용자가 지출내역을 추가하면 동작하는 함수</span>이다.  

처음 화면에 렌더링 되는 부분은 App.js에서 바로 <u>function App의 return 부분</u>이다.  
`NewExpense 컴포넌트`에서 바로 이 <span class="red">조건부 렌더링</span>을 만들어주어야 처음에 살펴본 이미지와 같은 상황을 구현할 수 있다.  

```jsx
// NewExpense.js
import { useState } from 'react';

import './NewExpense.css';
import ExpenseForm from './ExpenseForm';

export default function NewExpense({ onAddExpense }) {
  let [isEditing, setIsEditing] = useState(false);

  function saveExpenseDataHandler (enteredExpenseData) {
    const expenseData = {
      ...enteredExpenseData,
      id: Math.random().toString()
    }
    console.log(expenseData);
    onAddExpense(expenseData);
  };

  function startEditingHandler () {
    setIsEditing(true);
  }
  
  function stpoEditingHandler() {
    setIsEditing(false);
  }

  return (
    <div className='new-expense'>
      {!isEditing && <button onClick={startEditingHandler}> Add New Expense</button>}
      {isEditing && 
        <ExpenseForm
          onSaveExpenseData={saveExpenseDataHandler}
          onCancel={stpoEditingHandler}
        />
      }
    </div>
  );
}
```

위의 NewExpense.js의 에서 return에 해당하는 부분에서 <span class="blue">isEditing</span>과 <span class="blue">&&</span>을 사용하여 <u>조건부 렌더링을</u> 만들었다.  
`isEditing`이라는 state는 <span class="royalblue">초기값으로 false</span>가 들어있다.  
그래서 NewExpense.js의 return에서 <span class="tomato">!isEditing은 true</span>로, isEditing은 false이므로  
<span class="darkorange">{!isEditing && <button onClick={startEditingHandler}> Add New Expense</button>}</span>  
부분만이 화면에 출력된다.  

그리고 <u>Add New Expense 버튼</u>의 <span class="blue">onClick 이벤트로 startEditingHandler 함수</span>를 설정해주었다.  
startEditingHandler 함수는 <span class="royalblue">isEditing의 상태값을 바꾸는 setState를 실행</span>시키므로  
<u>Add New Expense 버튼은 사라지고</u> <span class="tomato">ExpenseForm이 새롭게 렌더링</span>된다.  

이제 ExpenseForm이 아래의 이미지와 같이 렌더링된 상태에서 사용자가 지출내역을 입력하게 된다.  
<img src="https://user-images.githubusercontent.com/87808288/185733727-3b2e607b-bd8c-40a4-85e9-719087b0e4ba.png" width="80%">  
사용자가 여기서 `cancel 버튼`을 누르면 <u>"Add New Expense" 버튼이 렌더링</u>되어야하고  
title, amount, date를 입력하고 `Add Expense 버튼`을 click 해도 <u>"Add New Expense" 버튼이 렌더링</u>되면서  
<span class="royalblue">지출 list에 입력정보가 추가</span>되어야 한다.  

```jsx
//ExpenseForm.js
import { useState } from 'react';

import './ExpenseForm.css';

export default function ExpenseForm({ 
  onSaveExpenseData,
  onCancel,
}) {
  const [inputs, setInputs] = useState({
    title: '',
    amount: '',
    date: '',
  });

  const { title, amount, date } = inputs;


  function handleInputValue(e) {
    setInputs({
      ...inputs, title: e.target.value,
    });
  }

  function handleAmountValue(e) {
    setInputs({
      ...inputs, amount: e.target.value,
    });
  }

  function handleDateValue(e) {
    setInputs({
      ...inputs, date: e.target.value,
    });
  }

  function submitHandler(e) {
    e.preventDefault();
    
    const expenseData = {
      title: title,
      amount: amount,
      date: new Date(date),
    };

    onSaveExpenseData(expenseData);

    setInputs({
      title: '',
      amount: '', 
      date: '',
    });

    onCancel();
  }

  return (
    <form onSubmit={submitHandler}>
      <div className='new-expense__controls'>
        <div className='new-expense__control'>
          <label>Title</label>
          <input 
            type="text"
            value={title}
            onChange={handleInputValue} 
          />
        </div>
        <div className='new-expense__control'>
          <label>Amount</label>
          <input 
            type="number"
            value={amount}
            min="0.01"
            step="0.01" 
            onChange={handleAmountValue}
          />
        </div>
        <div className='new-expense__control'>
          <label>Date</label>
          <input
            type="date"
            value={date}
            min="2019-01-01"
            max="2022-12-31" 
            onChange={handleDateValue}
          />
        </div>
      </div>
      <div className='new-expense__actions'>
        <button type='button' onClick={onCancel}>
          Cancel
        </button>
        <button type="submit">Add Expense</button>
      </div>
    </form>
  );
}
```

ExpenseForm 컴포넌트의 `Cancel 버튼`을 click하여 <u>"Add New Expense" 버튼이 렌더링되도록</u> 하기 위해서는 state인 <span class="royalblue">isEditing의 상태값을 true에서 false로 바꾸어야</span>한다.  
이를 위해 <u>Expenses에서 ExpenseForm으로</u> <span class="royalblue">props</span>를 이용하여 <span class="darkorange">onCancel={stpoEditingHandler}</span>로 stpoEditingHandler 함수를 전달했다.  
그렇게 ExpeseForm에서 <span class="blue">Cancel 버튼의 onClick 이벤트</span>로 <span class="darkorange">&lt;button type='button' onClick={onCancel}&gt;</span> 이렇게 stpoEditingHandler 함수를 실행하도록 설정했다.  
따라서 <u>Cancel 버튼을 클릭</u>하면 <span class="tomato">isEditing의 state 값이 변경</span>되면서 조건부 렌더링에 의해 "Add New Expense" 버튼이 렌더링된다.  

그리고 사용자가 지출내역을 입력하고 `Add Expense 버튼`을 누르면 마찬가지로 <u>"Add New Expense" 버튼이 렌더링</u>되면서 밑에 <u>list에 사용자가 입력한 지출내역이 추가</u>되어야한다.  
ExpenseForm 컴포넌트의 구조를 살펴보면 기본적으로 <span class="royalblue">form 태그 안에 버튼들</span>이 들어가 있으며, <span class="blue">Add Expense 버튼의 type은 submit</span>으로 Add Expense 버튼을 click하면 submit 이벤트가 발생하면서 <u>form 태그에 onSubmit 이벤트가 실행</u>된다. 여기서 <u>onSubmit 이벤트로 실행</u>되는 <span class="tomato">submitHandler 함수</span>는 아래와 같다.  

```jsx
// EspenseForm.js
......
function submitHandler(e) {
  e.preventDefault();
  
  const expenseData = {
    title: title,
    amount: amount,
    date: new Date(date),
  };

  onSaveExpenseData(expenseData);

  setInputs({
    title: '',
    amount: '', 
    date: '',
  });

  onCancel();
}
......
```

우선 <u>사용자가 입력한 정보</u>는 state인 <span class="royalblue">title, amount, date</span>에 저장되어 이를 <span class="blue">expenseDate라는 변수</span>에 할당한다.  
그래서 이를 `NewExpense 컴포넌트`에서 props로 보낸 <span class="blue">onSaveExpenseData</span>의 <u>인수로 expenseDate 객체를 보내 list를 업데이트</u>하게 된다. 그리고 <span class="tomato">onCancel 함수를 실행</span>시켜 Cancel 버튼을 click 했을 때와 마찬가지로 isEditing의 state 값을 변경시켜 "Add New Expense" 버튼이 렌더링되도록 하면 된다.  

# 2장 조건문을 이용한 조건부 렌더링
1장에서는 단축 평가를 활용하여 조건부 렌더링을 사용했다.  
이번에는 조건문을 사용하여 조건부 렌더링을 해보려고 한다.  

<img src="https://user-images.githubusercontent.com/87808288/185774444-00f5f2e5-16a6-4f44-9ff7-a8325376bd2b.gif" width="70%">  
위의 이미지는 <u>년도를 선택하면</u> <span class="royalblue">해당 년도에 지출한 목록들이 리스트로</span> 나오게된다.  
<u>해당 년도에 지출 내용이 없다면</u> <span class="royalblue">Found no expenses.</span>가 렌더링되는 것을 확인할 수 있다.  

```jsx
// App.js
import { useState } from 'react';

import Expenses from './components/Expenses/Expenses';
import NewExpense from './components/NewExpense/NewExpense';

export default function App() {
  const DUMMY_EXPENSES = [
    {
      id: 'e1',
      title: 'Toilet Paper!!!',
      amount: 94.12,
      date: new Date(2020, 7, 14),
    },
    { id: 'e2', title: 'New TV', amount: 799.49, date: new Date(2021, 2, 12) },
    {
      id: 'e3',
      title: 'Car Insurance',
      amount: 294.67,
      date: new Date(2021, 2, 28),
    },
    {
      id: 'e4',
      title: 'New Desk (Wooden)',
      amount: 450,
      date: new Date(2021, 5, 12),
    },
  ];

  const [expenses, setExpenses] = useState(DUMMY_EXPENSES);

  function addExpenseHandler (expense) {
    setExpenses((prevExpenses) => {
      return [expense, ...prevExpenses];
    })
  }

  return (
    <div>
      <NewExpense 
        onAddExpense={addExpenseHandler}
      />
      <Expenses
        data={expenses}
      />
    </div>
  );
}
```

`App`에서 <span class="royalblue">지출항목 list</span>가 <u>배열 안에 객체</u>로 <span class="blue">expenses 변수</span>에 할당되어 있다.  
그리고 이를, 지출내역 리스트를 화면에 렌더링하기 위한 컴포넌트인 `Expenses`의 <span class="royalblue">props로 전달</span>(data={expenses})한다.  

```jsx
// Expenses.js
import { useState } from 'react';

import './Expenses.css';
import Card from '../UI/Card';
import ExpensesFilter from './ExpensesFilter';
import ExpensesList from './ExpensesList';

export default function Expenses({ 
  data,
}) {
  const [filterYear, setFilterYear] = useState('2020');

  function filterChangeHandler(yearData) {
    setFilterYear(yearData);
  }

  const filteredExpenses = data.filter(expense => {
    return expense.date.getFullYear().toString() === filterYear;
  });

  return (
    <div>
      <Card className='expenses'>
        <ExpensesFilter
          selected={filterYear}
          onChangeFilter={filterChangeHandler}
        />
        <ExpensesList
          items={filteredExpenses}
        />
      </Card>
    </div>
  );
}
```

위의 Expenses.js의 구조를 살펴보면  
<img src="https://user-images.githubusercontent.com/87808288/185776275-f69320b7-3743-4d42-b0b5-b9fab5f7af50.png" width="70%">  
<u>년도를 선택할 수 있는 컴포넌트</u>인 `ExpensesFilter` 그리고 이를 <u>리스트화하는</u> `ExpensesList` 컴포넌트가 위치하고 있다.  

`Expenses 컴포넌트`의 <span class="tomato">state</span>와 <span class="tomato">함수</span>를 살펴보자.  
<span class="blue">filterYear</span>는 사용자가 ExpensesFilter에서 <u>선택한 year를 담기 위한 state</u>이다.  
<span class="blue">filterChangeHandler 함수</span>에서는 <span class="royalblue">사용자가 year를 선택</span>하면 filterChangeHandler의 <u>인수로, 선택한 year를 넘기고</u> <span class="royalblue">setFilterYear를 통해 filterYear의 state 값을 변경</span>하게 된다.  
그렇게 <span class="blue">filteredExpenses</span> 변수에 <span class="royalblue">filter 메서드</span>를 통해, 사용자가 선택한 year과 일치하는 expenses만을 담아 <u>새로운 배열로 반환</u>하게 된다. 그리고 이것을 `ExpensesList 컴포넌트`에 <u>props(items={filteredExpenses})로 최종적으로 전달</u>하게 된다.  

```jsx
// ExpensesList.js
import './ExpensesList.css';

import ExpenseItem from './ExpenseItem';

export default function ExpensesList({
  items,
}) {
  if (items.length === 0) {
    return (
      <h2 className='expenses-list__fallback'>
        Found no expenses.
      </h2>
    )
  }

  return (
    <ul className='expenses-list'>
      {items.map((expense) => (
        <ExpenseItem 
          key={expense.id}
          title={expense.title} 
          amount={expense.amount}
          date={expense}
        />
      ))}
    </ul>
  )
}
```

ExpensesList.js에서는 props로 전달받은 filteredExpenses를 프로퍼티 키인 items로 destructuring하였다.  
그리고 <span class="tomato">조건문</span>을 사용하여 <span class="blue">itesm의 length가 0이라면</span> "<u>Found no expenses.</u>"를 리턴하여 화면에 렌더링하고, <span class="blue">length가 0이 아니라면</span> <u>조건문 밑에 위치한 return문으로 이동</u>하여 화면에 렌더링한다.  

<!-- ⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ -->

<!-- ### 2. Link 넣기

```

유형 1: (설명어를 입력) : [gunhee's coding blog](https://gunhee-jeong.github.io/)
유형 2: (URL 자동연결) : <https://gunhee-jeong.github.io/>
유형 3: (동일 파일 내 '문단으로 이동') : [1. Header로 이동](###-1-header)

```

유형 1: (설명어를 입력) : [gunhee's coding blog](https://gunhee-jeong.github.io/)
유형 2: (URL 자동연결) : <https://gunhee-jeong.github.io/>
유형 3: (동일 파일 내 '문단으로 이동') : [1. Header로 이동](#1-header)
유형 3의 방법

1. 특수문자를 제거
2. 스페이스는 -로 바꾸고
3. 대문자는 소문자로!
   그래서 ### 1. Header -> #1-header

## Link: [google][https://www.google.com/]

### 3. 수평선

```

---

```

---

### 4. 라인 바꾸기

```

스페이스바를 2번 눌러주면 다음칸으로
이동할 수 있어요!

```

---

스페이스바를 2번 눌러주면
다음칸으로 이동할 수 있어요!

### 5. list 만들기

```

1. 1번
2. 2번
3. 3번

- 순서없는 list
  - 순서없는 list
    - 순서없는 list

```

1. 1번
2. 2번
3. 3번

- 순서없는 list
  - 순서없는 list
    - 순서없는 list

---

### 6. font 관련

```

**진하게** -> 볼드
_기울여서_ -> 이탤릭체
~~취소선~~ -> 취소선

<ul>밑줄넣기</ul> -> 밑줄
<span style="color:red">빨간 글씨</span> -> 글자색
이것이 `인라인` 입니다 -> 인라인 코드
```

**진하게** -> 볼드
_기울여서_ -> 이탤릭체
~~취소선~~ -> 취소선
<u>밑줄넣기</u> -> 밑줄
<span style="color:red">빨간 글씨</span>
이것이 `인라인` 입니다 -> 인라인 코드

---

### 7. 인용구문

```
> coding
>
> > JavaScript
> >
> > > 내가 프짱!
```

> coding
>
> > JavaScript
> >
> > > 내가 프짱!

---

### 8. 이미지 삽입

```
유형1: ('사이즈를 조절' -> HTML 태그 사용) : <img src="https://gunhee-jeong.github.io/assets/images/blogLogo.png" width="300" height="200">
유형2: (이미지 삽입 후 -> 링크 걸기)
[![이미지](https://gunhee-jeong.github.io/assets/images/blogLogo/blogLogo.png)](https://gunhee-jeong.github.io/)
```

유형1: ('사이즈를 조절' -> HTML 태그 사용) : <img src="https://gunhee-jeong.github.io/assets/images/blogLogo.png" width="300" height="200">
유형2: (이미지 삽입 후 -> 링크 걸기)
[![이미지](https://gunhee-jeong.github.io/assets/images/blogLogo.png)](https://gunhee-jeong.github.io/)

### 9. 표 만들기

```
||국어|영어|
| :--- | ---: | :--: |
|건희 | 100점 | 100점
|철수 | 100점 | 100점
```

|      |  국어 | 영어  |
| :--- | ----: | :---: |
| 건희 | 100점 | 100점 |
| 철수 | 100점 | 100점 |

> - header를 넣고 싶은 경우 ---을 사용하고 :을 이용하여 정렬에 사용함!

### 10. 토글 만들기

```
<details>
<summary>여기를 누르세요</summary>
<div markdown="1">
숨겨진 내용
</div>
</details>
```

<details>
<summary>여기를 누르세요</summary>
<div markdown="1">
숨겨진 내용
</div>
</details> -->
