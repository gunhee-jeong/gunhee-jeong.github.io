---
layout: single
title: "리액트 라우팅"
# categories: Git
categories:
  - React # HTML CSS JavaScript Server Algorithm Wecodes Programmers CS Github Blog
tag: [리액트 기초, SPA] #tag는 여러개 가능함
toc: true #table of content 기능!
toc_sticky: true
author_profile: true #blog 글안에서는 author_profile이 따라다니지 않도록 설정함
date: 2022-09-12T15:30:00+09:00
# sidebar:
# nav: "docs" #네비게이션에 있는 docs를 의미함
---
<style>
.crimson {
  color: crimson;
  font-weight: bold;
}

.mediumblue {
  color: mediumblue;
  font-weight: bold;
}

.forestgreen {
  color: forestgreen;
  font-weight: bold;
}
</style>

# 리액트 라우팅
<span class="crimson">Routing</span> 이란 <span class="mediumblue">다른 경로(url 주소)</span>에 따라 <span class="forestgreen">다른 View</span>를 보여주는 것을 말한다. React는 라이브러리로 이러한 기능이 내장되어 있지 않으므로 <span class="mediumblue">Router</span>를 이용하는 것이다.

<img src="https://user-images.githubusercontent.com/87808288/192272173-437633e4-9d09-4d5a-bdba-0cd888da96d5.png" width="50%">

# historyApiFallback
(webpack) : [devServer.historyApiFallback](https://webpack.js.org/configuration/dev-server/#devserverhistoryapifallback)

```jsx
// webpack.config.js
const path = require('path');

module.exports = {
  entry: path.resolve(__dirname, 'src/index.jsx'),
  module: {
    rules: [
      {
        test: /\.jsx?$/,
        exclude: /node_modules/,
        use: 'babel-loader',
      },
    ],
  },
  resolve: {
    extensions: ['.js', '.jsx'],
  },
  devServer: { // add ~
    historyApiFallback: {
      index: 'index.html',
    },
  }, // ~ add
};
```

위의 webpack.config.js의 `devServer`와 같이 설정하면 <u>우리가 요청하는 모든 곳</u>은 무엇이든 <span class="forestgreen">index로 연결</span>이 된다. 리액트에서 <span class="crimson">SPA</span>를 구현한다는 것은 URL이 바뀌면 새로운 HTML 파일을 서버에서 받는 것이 아닌, <span class="mediumblue">index.html에서 모든 변화를 렌더링</span>하는 것이기 때문에 URL이 바뀌어도 index.html로 이동하는 연결이 필요하다. 리액트에서는 index.html 밖에는 html 파일이 없기 때문에 위의 코드와 같은 설정을 해야한다.  
<img src="https://user-images.githubusercontent.com/87808288/189670640-bd531f39-7c57-453d-ab1c-d5ec3c39d2ee.png" width="40%">  
index로 연결된다는 것은 <span class="mediumblue">index.jsx</span>로 온다는 것을 의미한다.

# Window.location
(mdn web docs) : [Location](https://developer.mozilla.org/ko/docs/Web/API/Location)

<span class="crimson">window.location</span>을 통해서 Location 객체를 얻어올 수 있다.

Location 인터페이스는 객체가 연결된 장소(URL)를 표현한다. Location 인터페이스에 변경을 가하면 연결된 객체에도 반영되는데, Document와 인터페이스가 이런 Location을 가지고 있다. 각각 Document.location과 window.location으로 접근할 수 있다.

'http://localhost:8080/' 상태에서 <u>console.log(location);</u> 을 이용하여 console을 확인해보면 아래의 이미지와 같이 결과를 확인할 수 있다.  
<img src="https://user-images.githubusercontent.com/87808288/189809131-46da7ca2-5d49-4661-8180-27c3927a9851.png" width="80%">

그리고 'http://localhost:8080/<span class="forestgreen">about</span>' 에서 console.log(location); 이용하여 console을 확인하면 이제는 아래와 같이 내용이 변경되었다.  
<img src="https://user-images.githubusercontent.com/87808288/189809434-fe2f1692-71e1-475c-b952-da211097b376.png" width="80%">  
이를 이용해 console.log(<span class="mediumblue">location.pathname</span>);을 사용하면 <u>'/about'만을 값으로</u> 가지고 올 수 있게 된다.

```jsx
// App.jsx
import RestaurantsPage from './RestaurantsPage';

export default function App() {
  const { location: { pathname } } = window;

  if (pathname === '/') {
    return (
      <p>Home</p>
    );
  }

  return (
    <RestaurantsPage />
  );
}
```

pathname을 이용하여 위의 코드와 같이 기본 url일 경우에는 Home이 보이도록 하고, pathname이 다른 것이 붙는 경우는 RestaurantsPage 컴포넌트가 렌더링된다.

```jsx
// App.jsx
import RestaurantsPage from './RestaurantsPage';

function HomePage() {
  return (
    <p>Home</p>
  );
}

export default function App() {
  const { location: { pathname } } = window;

  const MyComponent = {
    '/': HomePage,
    '/restaurants': RestaurantsPage,
  }[pathname];

  return (
    <MyComponent />
  );
}
```

그리고 `객체의 구조분해할당`과 `대괄호 표기법`을 사용하면 위의 코드와 같이 <u>MyComponent 변수</u>를 선언과 동시에 해당 <span class="mediumblue">pathname에 따라 그에 맞는 값으로 함수를 Myconponemt 함수에 할당</span>하게 된다. 변수 MyComponent에 최종적으로 <span class="forestgreen">값이 할당되는 시점</span>은 대괄호 표기법([pathname])까지 실행되어 객체에서 그에 맞는 <span class="mediumblue">대괄호 표기법을 검색한 후에 할당</span>된다.

```jsx
// App.jsx
import RestaurantsPage from './RestaurantsPage';

function HomePage() {
  return (
    <p>Home</p>
  );
}

function NotFoundPage() {
  return (
    <p>NotFoundPage</p>
  );
}

export default function App() {
  const { location: { pathname } } = window;

  const MyComponent = {
    '/': HomePage,
    '/restaurants': RestaurantsPage,
  }[pathname] || NotFoundPage;

  return (
    <MyComponent />
  );
}
```

<u>사용자가 주소를 잘못 쳐서</u> 들어오는 경우, '/', 'restaurants' 외의 pathname을 시도하는 경우들도 있다. 이러한 <span class="forestgreen">에러를 처리</span>하기 위해 MyComponent에 <span class="mediumblue">논리합 연산자</span>를 사용하여 <u>객체에서 찾을 수 없는 프로퍼티 키인 경우 <span class="forestgreen">undefined</span>를 반환하는 것을 이용</u>해 위의 코드와 같이 'NotFoundPage' 함수를 변수의 값으로 할당하게 할 수도 있다.

# Routing
(poiemaweb) : [37장 SPA & Routing](https://poiemaweb.com/js-spa)

라우팅이란 <u>출발지에서 목적지까지의 경로를 결정하는 기능</u>이다. 애플리케이션의 라우팅은 사용자가 태스크를 수행하기 위해 어떤 화면(view)에 다른 화면으로 전환하는 내비게이션을 관리하기 위한 기능을 의미한다. 일반적으로 사용자가 요청한 URL 또는 이벤트를 해석하고 새로운 페이지로 전환하기 위한 데이터를 취득하기 위해 서버에 필요한 데이터를 요청하고 화면을 전환하는 일련의 행위를 말한다.

## SPA와 Routing
### SPA(Single Page Application)
단일 페이지 애플리케이션은 모던 웹의 패러다임이다. <span class="crimson">SPA</span>는 기본적으로 <span class="mediumblue">단일 페이지</span>로 구성되며 기존의 서버 사이드 렌더링과 비교할 때, <span class="forestgreen">배포가 간단</span>하며 <span class="forestgreen">네이티브 앱과 유사한 사용자 경험</span>을 제공할 수 있다.

<span class="forestgreen">link tag</span>를 사용하는 <u>전통적인 화면 전환 방식</u>은 <span class="crimson">새로운 페이지 요청 시마다 정적 리소스가 다운로드</span>되고 <span class="forestgreen">전체 페이지를 다시 렌더링</span>하는 방식을 사용하므로 <span class="mediumblue">새로고침이 발생하는 문제</span>가 있었다. 그리고 이로인해 <u>변경이 필요하지 않은 부분까지 포함</u>되면서 <span class="crimson">전체 페이지를 갱신하므로 비효율적</span>이다.

`SPA`는 웹 애플리케이션에 필요한 <span class="crimson">모든 정적 리소스를 최초 접근시 단 한 번만 다운로드</span>한다. <u>이후 새로운 페이지 요청 시</u>, <span class="forestgreen">페이지 갱신에 필요한 데이터만을 JSON으로 전달받아 페이지를 갱신</span>하므로 <u>전체적인 트래픽을 감소</u>시킬 수 있다. 그리고 전체 페이지를 다시 렌더링하지 않고 변경되는 부분만 갱신하므로 새로고침이 발생하지 않아 네이티브 앱과 유사한 사용자 경험을 제공한다.

SPA의 핵심 가치는 사용자 경험(UX) 향상에 있으며 부가적으로 애플리케이션 속도의 향상도 기대할 수 있어서 <u>모바일 퍼스트(Mobile First) 전략에 부합</u>한다.

`SPA`는 크게 <span class="crimson">초기 구동 속도</span>와 <span class="crimson">SEO(검색엔진 최적화) 이슈</span>라는 대표적인 단점을 가지고 있다. SPA는 웹 애플리케이션에 필요한 모든 정적 리소스를 최초 접근시 단 한번 다운로드하기 때문에 초기 구동 속도가 상대적으로 느리다. 하지만 SPA는 웹페이지보다 애플리케이션에 적합한 기술이므로 트래픽 감소와 속도, 사용성, 반응성의 향상 등의 장점을 생각한다면 결정적인 단점이라 할 수는 없다.

SEO 이슈는, SPA는 일반적으로 서버 사이드 렌더링 방식이 아닌 자바스크립트 기반 비동기 모델의 클라이언트 사이드 렌더링 방식으로 동작한다. 클라이언트 사이드 렌더링은 일반적으로 데이터 패치 요청을 서버로부터 데이터를 응답받아 뷰를 동적으로 생성하는데 이때 브라우저 주소창의 URL이 변경되지 않는다. 이는 사용자 방문 history를 관리할 수 없음을 의미하며 SEO 이슈의 발생 원인이기도 하다. SPA는 정보 제공을 위한 웹페이지보다는 애플리케이션에 적합한 기술이므로 SEO 이슈는 심각한 문제로 취급할 수 없다고 생각할 수도 있지만 블로그와 같이 애플리케이션의 경우 SEO는 무시할 수 없는 중요한 의미를 갖는다.

### Routing
라우팅이란 출발지에서 목적지까지의 경로를 결정하는 기술이다. 애플리케이션의 라우팅은 사용자가 태스크를 수행하기 위해 <u>어떤 화면(view)에서 다른 화면으로 화면을 전환하는</u> <span class="forestgreen">내비게이션을 관리하기 위한 기능</span>을 의미한다. 일반적으로 라우팅은 사용자가 요청한 URL 또는 이벤트를 해석하고 새로운 페이지로 전환하기 위해 필요한 데이터를 서버에 요청하고 페이지를 전환하기 위한 일련의 행위이다.

브라우저가 화면을 전환하는 경우는 아래와 같다.

- 브라우저의 주소창에 URL을 입력하면 해당 페이지로 이동한다.
- 웹페이지의 링크(a 링크)를 클릭하면 해당 페이지로 이동한다.
- 브라우저의 뒤로가기 또는 앞으로가기 버튼을 클릭하면 사용자 방문 기록(history)의 뒤 또는 앞으로 이동한다. history 관리를 위해서는, 각 페이지는 브라우저의 주소창에서 구별할 수 있는 유일한 URL을 소유해야 한다.

### 전통적 링크 방식
```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>SPA-Router - Link</title>
    <link rel="stylesheet" href="css/style.css" />
  </head>
  <body>
    <nav>
      <ul>
        <li><a href="/">Home</a></li>
        <li><a href="/service.html">Service</a></li>
        <li><a href="/about.html">About</a></li>
      </ul>
    </nav>
    <section>
      <h1>Home</h1>
      <p>This is main page</p>
    </section>
  </body>
</html>
```

<u>link tag를 클릭</u>하면 href 어트리뷰트 값인 리소스 경로가 URL의 path에 추가되어 주소창에 나타나고 해당 리소스를 서버에 요청한다.  
<img src="https://user-images.githubusercontent.com/87808288/189653541-3e6d1412-2fdd-45ec-b317-dfe3acd8d938.png" width="90%">

이때 <span class="mediumblue">서버</span>는 <u>html로 화면을 표시하는데 부족함이 없는 완전한 리소스</u>를 클라이언트에 응답한다. 이를 <span class="crimson">서버 사이드 렌더링(SSR)</span>이라 한다. 브라우저는 서버가 응답한 html을 응답받아 렌더링한다. 이때 응답받은 html로 전체 페이지를 다시 렌더링하게 되므로 새로고침이 발생한다.  
<img src="https://user-images.githubusercontent.com/87808288/189655507-c0edeee6-0fa2-444b-80a3-cc61ab18410f.png" width="50%">

이 방식은 <span class="forestgreen">자바스크립트의 도움 없이 응답받은 html만으로 렌더링이 가능</span>하며 <span class="mediumblue">각 페이지마다 고유의 URL이 존재</span>하므로 history 관리 및 SEO 대응에 아무런 문제가 없다. 하지만 요청마다 중복된 리소스를 응답받아야 하며 전체 페이지를 다시 렌더링하는 과정에서 새로고침이 발생하여 사용성이 좋지 않은 단점이 있다.

# React Router
(REACT ROUTER) : [Quick start](https://v5.reactrouter.com/web/guides/quick-start)

React-Router는 신규 페이지를 불러오지 않는 상황에서 각각의 URL에 따라 선택된 데이터를 하나의 페이지에서 렌더링해주는 라이브러리이다.

`리액트 라우터`는 <u>사용자가 입력한 주소를 감지</u>하는 역할을 하고, 다양한 환경에서 동작할 수 있도록 여러 종류의 라우터 컴포넌트를 제공한다. 그중 많이 사용되는 라우터 컴포넌트가 바로 '<span class="mediumblue">BrowserRouter</span>'이다.

<span class="mediumblue">Routes</span> 컴포넌트는 여러 Route를 감싸서 그 중 <span class="forestgreen">규칙이 일치하는 Route 하나만을 렌더링 시켜주는 역할</span>을 한다. Route 컴포넌트는 path 속성에 경로, element 속성에 컴포넌트를 그리고 여러 라우팅을 매칭하고자 할 때는 URL 뒤에 *을 사용하면 된다.

```jsx
// App.jsx
import {
  Routes,
  Route,
} from 'react-router-dom';

import HomePage from './HomePage';
import AboutPage from './AboutPage';
import NotFoundPage from './NotFoundPage';
import RestaurantsPage from './RestaurantsPage';

export default function App() {
  return (
    <Routes>
      <Route path="/" element={<HomePage />} />
      <Route path="/about" element={<AboutPage />} />
      <Route path="/restaurants" element={<RestaurantsPage />} />
      <Route path="*" element={<NotFoundPage />} />
    </Routes>
  );
}
```

## 시작하기
react-router를 사용하기 위해 설치가 필요하다.

```bash
npm i react-router-dom
```

## Link & useNavigate
Route로 이동하는 방법에는 크게 2가지가 존재한다. 바로 `Link`와 `useNavigate`이다.

<span class="crimson">Link</span>를 사용하여 이동하는 방법은, <u>클릭시 a 태그와 같이 바로 이동하는 로직</u>을 만들 때 사용되는 도구이다.

```jsx
import React from "react";
import { Link } from "react-router-dom";

function Login() {
  return (
    <div>
      <Link to="/signup">회원가입</Link>
    </div>
  );
}

export default Login;
```

<span class="crimson">useNavigate</span>는 페이지 전환시 추가로 처리해야 하는 로직이 있을 경우에 사용하게 된다. 예를 들어 로그인 버튼을 클릭시 회원가입이 되어있는 사용자는 main 페이지로, 회원가입이 안되어 있는 사용자는 sign 페이지로 이동시키는 경우에 useNavigate를 사용한다. 이렇게 자바스크립트 코드를 사용한 <span class="forestgreen">조건문에 맞게 이동시키는</span> 것이 가능한 것이다.

```jsx
import React from "react";
import { useNavigate } from "react-router-dom";

function Login() {
  const navigate = useNavigate();

  const goToMain = () => {
    navigate("/main");
  };

  // 실제 활용 예시
  // const goToMain = () => {
  //   if(response.message === "valid user"){
  //     navigate('/main');
  //   } else {
  //     alert("가입된 회원이 아닙니다. 회원가입을 먼저 해주세요.")
  //     navigate('/signup');
  //   }
  // }

  return (
    <div>
      <button className="loginBtn" onClick={goToMain}>
        로그인
      </button>
    </div>
  );
}

export default Login;
```

<!-- ⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ -->

<!-- ### 2. Link 넣기

```

유형 1: (설명어를 입력) : [gunhee's coding blog](https://gunhee-jeong.github.io/)
유형 2: (URL 자동연결) : <https://gunhee-jeong.github.io/>
유형 3: (동일 파일 내 '문단으로 이동') : [1. Header로 이동](###-1-header)

```

유형 1: (설명어를 입력) : [gunhee's coding blog](https://gunhee-jeong.github.io/)
유형 2: (URL 자동연결) : <https://gunhee-jeong.github.io/>
유형 3: (동일 파일 내 '문단으로 이동') : [1. Header로 이동](#1-header)
유형 3의 방법

1. 특수문자를 제거
2. 스페이스는 -로 바꾸고
3. 대문자는 소문자로!
   그래서 ### 1. Header -> #1-header

## Link: [google][https://www.google.com/]

### 3. 수평선

```

---

```

---

### 4. 라인 바꾸기

```

스페이스바를 2번 눌러주면 다음칸으로
이동할 수 있어요!

```

---

스페이스바를 2번 눌러주면
다음칸으로 이동할 수 있어요!

### 5. list 만들기

```

1. 1번
2. 2번
3. 3번

- 순서없는 list
  - 순서없는 list
    - 순서없는 list

```

1. 1번
2. 2번
3. 3번

- 순서없는 list
  - 순서없는 list
    - 순서없는 list

---

### 6. font 관련

```

**진하게** -> 볼드
_기울여서_ -> 이탤릭체
~~취소선~~ -> 취소선

<ul>밑줄넣기</ul> -> 밑줄
<span style="color:crimson">빨간 글씨</span> -> 글자색
이것이 `인라인` 입니다 -> 인라인 코드
```

**진하게** -> 볼드
_기울여서_ -> 이탤릭체
~~취소선~~ -> 취소선
<u>밑줄넣기</u> -> 밑줄
<span style="color:crimson">빨간 글씨</span>
이것이 `인라인` 입니다 -> 인라인 코드

---

### 7. 인용구문

```
> coding
>
> > JavaScript
> >
> > > 내가 프짱!
```

> coding
>
> > JavaScript
> >
> > > 내가 프짱!

---

### 8. 이미지 삽입

```
유형1: ('사이즈를 조절' -> HTML 태그 사용) : <img src="https://gunhee-jeong.github.io/assets/images/blogLogo.png" width="300" height="200">
유형2: (이미지 삽입 후 -> 링크 걸기)
[![이미지](https://gunhee-jeong.github.io/assets/images/blogLogo/blogLogo.png)](https://gunhee-jeong.github.io/)
```

유형1: ('사이즈를 조절' -> HTML 태그 사용) : <img src="https://gunhee-jeong.github.io/assets/images/blogLogo.png" width="300" height="200">
유형2: (이미지 삽입 후 -> 링크 걸기)
[![이미지](https://gunhee-jeong.github.io/assets/images/blogLogo.png)](https://gunhee-jeong.github.io/)

### 9. 표 만들기

```
||국어|영어|
| :--- | ---: | :--: |
|건희 | 100점 | 100점
|철수 | 100점 | 100점
```

|      |  국어 | 영어  |
| :--- | ----: | :---: |
| 건희 | 100점 | 100점 |
| 철수 | 100점 | 100점 |

> - header를 넣고 싶은 경우 ---을 사용하고 :을 이용하여 정렬에 사용함!

### 10. 토글 만들기

```
<details>
<summary>여기를 누르세요</summary>
<div markdown="1">
숨겨진 내용
</div>
</details>
```

<details>
<summary>여기를 누르세요</summary>
<div markdown="1">
숨겨진 내용
</div>
</details> -->
