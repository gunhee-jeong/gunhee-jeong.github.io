---
layout: single
title: "Front-end의 역사와 미래"
# categories: Git
categories:
  - web # HTML CSS JavaScript Server Algorithm Wecode Programmers CS vsCode
tag: [프론트엔드, teo, 역사, 미래] #tag는 여러개 가능함
toc: true #table of content 기능!
toc_sticky: true
author_profile: true #blog 글안에서는 author_profile이 따라다니지 않도록 설정함
# sidebar:
# nav: "docs" #네비게이션에 있는 docs를 의미함
---
teo님의 velog 글들을 보던 중 "프론트엔드 역사와 미래, 업무 분야 and 잘하는 프론테엔드 개발자란?"  
라는 글을 보고 다시 한 번 블로그에 정리한다.  
>teo.log : [프론트엔드 역사와 미래, 업무 분야 ... 그리고 잘하는 프론트엔드 개발자란?](https://velog.io/@teo/frontend)   

# Front-end 포지션의 탄생 이유  
## WEB 1.0  
### 문서를 공유하기 위하여 web이 만들어졌다(1990)  
이때 <u>가상의 공간에서 텍스트에 새로운 문서에 대한 링크</u>가 존재하는 '<span style="color:red">하이퍼텍스트</span>'가 탄생한다.  
그렇게 HTML의 첫 글자가 바로 -> Hypertext!  
<span style="color:red">web</span>은 그렇게 문서를 모든 사람이 `쉽게 만들고 또 공유하기 위해서` 탄생하게된다.   

### CGI(Common Gate Interface) 통신이 가능해진(1994)  
정적인 정보만 담고 있는 문서에 사용자가 <u>일정한 정보를 입력해서 전달하면</u> 그 정보를 바탕으로  
<span style="color:blue">서버에서 동적으로 페이지를 생성</span>할 수 있게 되었다.  
<u>PHP를 시작으로</u> 여러가지 서버 스크립트 언어가 만들어지면서 본격적인 홈페이지 서비스들이 만들어진다.   

### JavaScript의 탄생(1995)  
<img src="https://user-images.githubusercontent.com/87808288/164964694-380d57f3-7c8e-422d-81b4-3a940b972311.png" width="500" height="400">  
서버뿐만이 아니라 <u>브라우저에서 실행이 가능한 스크립트 언어</u>가 필요했고 -> <span style="color:red">자바스크립트</span>가 탄생한다.  
이렇게 <u>서버와 통신을 하기 전에 화면을 조작</u>하고 <span style="color:blue">서버에 데이터를 전달하기 전에 검증</span>을 하는 등의 기능이 가능해진 것이다.  

### 문서를 예쁘게! 웹 디자인의 발전(1996)  
<img src="https://user-images.githubusercontent.com/87808288/164964752-5a472b35-92d6-4080-bf4f-c85cf7ef6241.png" width="400" height="300">  
HTML에 과도한 스타일이 작성되어 유지보수를 어렵게 하던 문제에서 <u>컨텐츠와 서식을 분리하자는</u> <span style="color:red">CSS</span>가 탄생한다.  
그리고 브라우저의 성능상의 한계로 표현하지 모하던 애니메이션 등을 해결한 FLASH가 탄생한다.  

### Internet Exploer의 대중화와 웹의 상업화(1995-2004)  
Windows가 대중화되고 Internet Exploer가 기본 탑재되면서 -> web은 기업에서는 기본적으로 가지고 있어야하는  
존재들이 되었고 이때 `남들의 주목을 끌기 위해서` <u>기능보다는 디자인으로 이목을</u> 끄는 편이 쉬웠기에  
수많은 디자이너가 생겨났고 홈페이지를 개발하는 웹 개발자가 생겨났다.  

## Web 2.0과 RIA(Rich Web Application)  
### Flash와 RIA(Rich Web Application)  
2000년대 초 닷컴 버블로 여러가지 웹 비즈니스가 재편되면서 `WEB2.0`이라는 용어가 생겨난다.  
여기에는 여러가지 개념들이 있지만 Front-end와 가장 밀접한 관계의 키워드는 <span style="color:blue">RIA</span>이다.   

기존의 정적인 문서 구조에서 벗어나 <span style="color:blue">사용자와 적극적으로 상호작용</span>하며 화면이 동적으로 변하는 방향으로 나아가고있었다.   
당시에는 이와 가장 적합한 도구가 바로 `Flash`였다.   
당시 Internet Exploer의 동적 스크립트 능력을 한없이 열악했으며 더 막강한 언어인 ActionScript로  
되어있는 Flash는 <u>디자인, 애니메이션, 사용자 인터렉션</u> 모두에서 월등했다.  
하지만 Flash는 HTML이 아니므로 검색엔진에 포함되지 않았다.  
문서라는 본질적인 측면에서는 Flash가 효과적이지 않다는 것을 알게 된다.  

### 구글 - 마이크로소프트의 대항마로 WEB을 선택하다   
<img src="https://user-images.githubusercontent.com/87808288/164964838-f8d4674f-54ef-4eb8-a0a5-e1127edd8956.png" width="400" height="300">  
검색엔진과 구글애드로 성공을 거둔 구글은 당시 IT의 1인자인 마이크로소프트를 넘오보고자 했었고  
자신들의 아이덴티디는 검색엔진이고 -> 웹을 맨 처음시작할 때 google로 시작한다면  
'웹이 하나의 OS가 되면 어떨까?'라는 생각으로 프로젝트를 시작하게 된다.  

### 웹 표준과 웹 접근성, 시맨틱... 크로스 브라우징  
Window, Internet Exploer, ActiveX 등이 독점적 지위로 인해 자체 표준이 되어버린  
상황에서 여러가지 브라우저 벤더를 포함 웹 종사자들이 다 같이 웹을 쓸 수 있도록 하는 `웹 표준`을 만들게 된다.  
<u>웹은 모두의 것이고</u> 특정 벤더에 의해 관리되지 않아야 하고 웹의 발전을 위해서는 최적의 것들을 표준으로  
만들어야 한다는 취지로 만들어지게 된다.  
<u>웹 표준을 지켜서 html, css, javascript를 만들면</u> <span style="color:blue">브라우저와 관계없이 동작할 수 있다</span>는 것을 의미한다.  

이때부터 웹 디자이너, 웹 개발자들에게는 <span style="color:red">웹 표준</span>에 맞게 작성을 해야하고 JavaScript나 CSS 등을 이용해서  
<u>동적으로 화면을 만드는 능력</u>을 요구받게 된다.  
또한 이때 웹표준과 함께 <span style="color:blue">시맨틱</span>이라는 요소가 함께 강조되면서 `검색에 유리한 구조`와 `의미를 부여`하는 식으로  
HTML과 CSS를 작성하고 `시각장애인`들과 같은 경우에도 웹을 사용할 수 있도록 하는 접근성에 대해서 강조가  
되면서 디자인보다 <u>Front-end에서 더 전문성을 요하는 부분들이 생겨나게</u>되었다.   

### 크롬브라우저와 V8 엔진  
<u>웹을 통한 OS와 웹 어플리케이션</u>을 다음 먹거리로 삼았던 <span style="color:blue">구글</span>은 `JavaScript의 성능 개선`이 중요한 과제가 되었다.  
그래서 JavaScript의 성능을 개선한 <span style="color:blue">V8 엔진</span>을 만들고 이것을 오픈소스로 공유하게 된다.  
그리고 <u>V8</u>와 당시 <u>apple의 safari 오픈소스 웹브라우저 엔진인 webkit</u>을 결합시킨 <span style="color:red">크롬 브라우저</span>가 탄생하게 된다.  

### Node와 npm   
<img src="https://user-images.githubusercontent.com/87808288/164964901-0a7ccfcd-4068-4a7c-9bc8-2b8b83fb20ba.png" width="300" height="300">  
V8의 오픈소스는 새로운 국면을 맞이하는데 -> <u>JavaScript를 가지고 서버사이드 환경을 개발</u>할 수 있는  
`Node가 탄생`했기 때문이다.  
그리고 Node에서 <u>module이라는 방법을 채택</u>하면서 JavaScript에도 <span style="color:blue">module 방식의 개념이 보편화</span>되는 계기가 된다.  
> module 개념이 중요한 것은 <u>파일을 쪼갬으로써</u> <span style="color:red">훨씬 더 덩치를 키울 수 있는 프로그램을</span> 만들 수 있기 때문이다.  
`자바스크립트는 모듈이 없다보니 한 파일에만 크게 작성을` 해야했고 여러 파일들을 쪼개서 불러오면 성능상의 이슈가  
발생헀기 때문에 JavaScript 덩치를 키우는게 쉽지 않았기 때문이다.  

이후 `npm`이라는 <u>module을 패키징해서 등록하고 관리</u>할 수 있는 도구가 생겨나면서  
JavaScript 생태계는 폭발적으로 성장하게 된다.  
이를 바탕으로 <u>webpack, babel, rollup</u>과 같은 Node를 기반으로 하는 dev-ops 영역이 활방해지면서  
그간 JavaScript 개발에 불편했던 영역들이 개선되기 시작한다.   

### 페이스북 - 연결의 가치(1분에 3테라의 데이터가 쌓인다)  
페이스북은 1분에 3테라의 데이터가 쌓일 만큼 성장하게 된다. -> 이를 위해서는 기존과는 완전히 다른 체계의  
서버 구상이 필요하게 된다.  
그리고 페이스북은 유래없이 단일 웹 서비스로 거대한 성공을 경험하고 -> 페이스북 역시도 하나의 OS의 역할을  
하길 원했고 -> 웹, 게임, 연결, 채팅, 메신저 등 많은 기능들이 Facebook에서 구동되기를 바랐다.  

### Back-end와 Front-end의 각자의 전문성의 분리(React의 탄생)   
<img src="https://user-images.githubusercontent.com/87808288/164964970-82982505-b47c-4627-88c7-7c45fb29ab02.png" width="300" height="300">  
지금까지 없었던 거대한 웹 사이트를 유지하고 관리한다는 것은 쉽지 않았다.  
Facebook은 Facebook을 개발하던 서버언어인 PHP를 확장시키고 싶었다.  
나중에 이것은 JavaScript의 개발경험을 바꾸는 것으로 이어졌고 JSX를 기본으로 하는 React Framework의  
탄생이기도 했다.   
> Front-end가 새로 생겼다기보다는 거대 웹 서비스의 등장과 웹 산업이 발전하는 과정에서 자연스레  
세분화된 것이다. Back-end는 이제 거대 데이터를 처리하기 위한 도구와 자동배포와 스케일링 등의  
새로운 과제를 맞이하게 되었고, Front-end 역시 화면을 동적으로 다루는 역할이 중요해지면서 더 필요한 역할을  
부여받게 되었다.  
특히 <u>React를 기점으로</u> Front-end 개발의 체계가 잡히면서 이러한 체계가 뚜렷해지기 시작한다.  

## 앞으로의 Front-end의 방향성  
### 보다 Serverless 하게(클라우드 서비스)  
Back-end의 로직의 영역은 점점 Front-end로 내려오고 있고 -> Back-end는 데이터를 교환하고 저장하고  
관리하는 인프라의 영역으로 확대되고 있다.  
<u>데이터를 다루는 로직은</u> `점점 Front-end가 담당`하게 되면서 <span style="color:red">클라우드를 통해 서버없이 작업을 하는 형태로</span>  
발전하고 있다.   

### 보다 실시간으로  
게시판에서, SNS, 메신저 등 점점 <span style="color:blue">데이터의 교환속도가 빨라지는 방향</span>으로 발전하고 있다.  
메타버스에서는 완전히 실시간으로 연결된 것들을 상상하고 있다.  
> 데이터를 실시간으로 다루는 형식으로 서비스들은 발전하고 있다.  
슬랙, 피그마, 노션, 게더타운 등을 떠올려보면 이해하기 쉽다.   

# Front-end 개발자의 업무 범위  
웹 서비스란 <u>사용자가 어떠한 입력을 하고</u> `입력을 통해 더 가치있는 데이터를 만들어` 사용자에게 잘 전달하는 것을  
의미한다. 이 과정에서 Front-end는 <span style="color:red">사용자와 서비스를 연결해주는 과정의 모든 것들을 구현하는 역할</span>을 하는 것이다. 
## 데이터를 잘 보여주기  
서버에서 내려오는 데이터를 적절히 HTML, CSS를 통해서 요구하는 디자인의 형태로 나타내야하는 영역이다.  

1. 디자인을 HTML + CSS로 만들어내는 작업  
2. 적절히 재사용이 가능한 형태로 디자인을 컴포넌트화 하는 작업  
3. 기기, 브라우저, 화면 등에 맞게 디자인이 제대로 보이기 위한 작업  
4. 시맨틱, 접근성, 검색엔진 최적화 등을 하기 위한 작업  
5. 초기 로딩 속도를 개선하기 위한 최적화 작업  
6. 서버의 데이터를 적절히 디자인 컨텐츠에 연결하여 데이터와 함께 출력하는 작업  

## 데이터(화면)를 조작하는 기능  
이미 만들어진 데이터에서 사용자의 입력을 받아서 적절히 다른 데이터(화면)로 변경하는 역할을 담당한다.  
대부분의 UI와 DOM, WEB API에 대한 이해와 View를 이루고 있는 데이터에 대한 깊은 이해를 요구한다.  

데이터의 관점으로 보았을 때는 `의미있는 데이터를 화면 내에서 만들려고 할수록` <span style="color:blue">어려워지고  
복잡해지고 중요해지는 경향</span>이 있다.  블로그의 글쓰기 에디터나 벨로그의 마크다운 글쓰기,  
구글 시트의 셀, 피그마의 기능과 같은 부분들을 떠올려볼 수 있다.  
1. 현재의 화면을 데이터로 구성한다.  
2. 사용자의 이벤트를 감지한다.  
3. 해당 이벤트를 적절한 행동으로 분류한다.  
4. 행동에 맞는 적절한 WEB API를 동작한다.  
5. 해당 API의 결과를 통해 새로운 데이터를 생성한다.  
6. 이 데이터를 기존의 데이터와 조립해서 원하는 데이터로 변경한다.  
7. 해당 데이터를 화먄에 출력한다.   

## 서버로 데이터 보내기  
여기에서는 앞에서 만들어낸 중요한 데이터들을 서버로 보내는 역할을 하게 된다.  
예전에는 Back-end를 개발하던 사람이 본인의 API를 테스트 하면서 작업하던 영역이었지만  
이제는 완전히 Front-end로 분리된 영역이다.    
`WEB의 가치는 데이터의 공유와 유통에` 있기 때문에 데이터가 서버를 통해 공유가 되지 않는다면  
의미가 퇴색이 되는 부분이기에 점점 더 중요해지고 있는 영역이다.  

<u>Back-end로 데이터를 전달하는 작업 자체는 어렵지 않은데</u> 이 부분이 어려운 이유에는  
이 작업이 <span style="color:blue">Back-end에 의존성이 있기 때문</span>이다.  
<span style="color:red">인증, 보안, 헤더, CORS</span> 등 <u>Back-end에서 만들어둔 설정</u>에 따라 맞춰서 작업을 해야하는데  
이것들은 코딩의 영역이 아니라 `학습의 영역`이기 때문에 <span style="color:blue">Back-end와 적절히 협업을 할 수 있을</span> 정도의  
`CS 능력`이 필요하기 때문이다. 대표적으로 <span style="color:red">HTTP 프로토콜</span>과 <span style="color:red">REST API</span>의 간단한 이해라고 할 수 있다.  

## 서버에서 받은 데이터 다루기  
서버에서 데이터를 전달받아서 화면에 필요한 데이터로 전환하는 변환하는 과정을 주로 다룬다.  
1. Back-end에서 만들어둔 스펙과 실제 화면에서 보여줘야 할 스펙이 일치하지 않기 때문에  
이를 적절히 만들어 줄 수 있어야 한다.  
2. 데이터의 응답속도가 느리기 때문에 실제 화면과 데이터간의 타이밍이 일치하지 않는다.  
이러한 비동기성 특징으로 인한 로딩, 중복 방지 등 중간 과정을 적절히 처리할 수 있어야 한다.  
3. 서버 응답에 따른 문제원인 확인 및 문제해결 능력이 필요하다.  

## 개발환경 관리하기, 서버로 배포하기  
프로젝트를 담당하게 되면서 초기 모든 사람들이 개발을 할 수 있도록 기술 스택을 정리하고 개발 환경을  
설정하는 작업도 필요하다. 그리고 이렇게 만들어진 Front-end의 결과물을 외부로 배포하기 위한 작업도 필요하다.  
소스코드를 관리하고 일정을 관리하는 일도 필요하게 된다. 보통 이런 역할을 하는 사람들은 PL(Project Leader)라고 한다.   
1. 프로젝트 개발 환경 설정 및 패키지 관리  
2. 프로젝트 컨벤션, 디자이너와의 컨벤션 조율  
3. 일정과 이슈관리 및 분배  
4. 배포 프로세스 및 릴리즈 관리  

## 개발자들을 위한 개발  
우리가 흔히 쓰는 React와 같은 도구들을 개발하는 업무이다.  
거창하게 React가 아니더라도 사내에서 쓰이는 공통 모듈이나 공통 라이브러리나 디자인 시스템의 컴포넌트와 같은 것을  
만들고 배포할 수 있다.  
뿐만 아니라 Git, Jira, npm과 같은 도구들을 사내 환경에 맞게 설치하고 환경을 만들어주는 업무들도 여기에 속한다.  

# 잘하는 Front-end 개발자란?  
## 회사의 입장에서 잘하는 개발자란...?  
일반적으로 회사 내에서 잘하는 개발자란 `시간을 잘 맞추고 협업을 잘하는` 사람을 이야기한다.  
오해를 하면 안되는 것은 <u>일정을 잘 지킨다는 의미</u>는 **열정페이로 밤새가며 마감을 맞춰야 좋다는 의미가 절대 아니다**.  
프로젝트의 규모와 요구사항을 통해서 `전체적인 일정을 스스로 컨트롤`할 수 있고 그 일정을 내가 조율하고  
`예측가능한 작업을 할 수 있는 것`이 회사에서 일을 잘 돌아갈 수 있도록 하는 능력이다.  

## 그러기 위해서 많이 알고 소통을 잘해야 한다.  
<u>기획, 디자인, Back-end, QA, UX, 사업, 사용자까지</u> 협업 라인이 **다채로운 파트**가 Front-end 분야이다.  
그렇기 때문에 Front-end의 기술 뿐만 아니라 <span style="color:blue">다른 분야에 대한 지식이 충분히</span> 있어야 한다.  

<span style="color:red">사용자를 기준으로 하는 사고 방식</span>과 <span style="color:red">Back-end의 데이터를 기준으로 하는 사고방식</span>의 차이가 존재하기 때문이다.  
<span style="color:red">디자인의 사고방식</span>과 <span style="color:red">구현의 사고방식</span> 역시 다르기 때문에 `이러한 조율` 역시 <u>Front-end 개발의 능력</u>이기도 하다.  

## 소통의 방식 중에는 말도 있지만 글도 있다  
<u>회사의 규모가 커질수록</u> <span style="color:red">문서의 중요성</span>이 높아진다. 말은 보관되지 않기 때문에 시간이 지나버리고  
담당자가 퇴사를 하고 나면 막막해지는 순간이 오기 마련이다.  
취업에서 <span style="color:blue">블로그</span>를 중요하게 보는 이유는 그 사람이 어떠한 사람인가를 보여주는 역할도 있지만  
`기본적으로 글을 얼마나 잘 작성하는지를 보기 위함`도 있다.  

## 일하는 소통만 소통이 아니다   
<span style="color:blue">회사는 사람과 사람이 살아가는 곳</span>으로 -> 기본적인 <u>인성과 유머, 성실함, 공감능력, 긍정성, 주도성</u>과 같은  
`인성적인 측면`이 무엇보다 중요하다.  
면접에서도 그 사람의 능력이 중요하지만 <span style="color:red">무엇보다 먼저 함께 일하고 싶은 사람인가?</span>가 가장 중요하다.  
함께 하고 싶은 좋은 사람이 되는 것은 좋은 개발자의 덕목이라 할 수 있다.   

## 빨리 할 줄 알아야한다  
특히 스타트업이나 초기 프로젝트에서 중요한 능력이기도 하다.  
웹 프론트엔드는 다른 앱과 달리 가볍고 빨리 만들 수 있다는 장점이 있다.  
이러한 장점이 극대화가 되려면 정말로 `요구사항을 빨리 이해해서 빠른 결과물을 만들어내는 능력`이 필요하다.  
<span style="color:blue">Front-end의 가치</span>는 <u>기술적인 부분</u>이라기 보다는 <span style="color:red">사업 그 자체</span>에 있다.  
그러기 위해서는 `빠른 구현`이 중요하다. <u>일정을 당기는 데 목적이 있는 것이 아니라</u> 아이디어가 굳어가기 전에  
검증이 필요하기 때문이다. 아이디어나 디자인들이 만들어지고 나서 <u>구현에 까지 시간이 오래 걸릴수록</u>  
<span style="color:blue">매몰 비용으로 인해 포기하는 비용이 높아진다</span>. 이런 것들을 몇번 겪고 나면 -> <span style="color:blue">안 좋은 아이디어나 디자인을 그냥  
채택</span>해버리기 때문이고 이는 나중에 <span style="color:red">사업 자체의 가치를 떨어뜨리게</span> 된다.  


## Front-end의 가치는 기술보다 본인이 만드는 서비스의 가치로 먼저 평가받는다  
안타까운 말이지만 <u>Front-end의 가치</u>는 먼저 <span style="color:red">내가 만드는 서비스의 가치</span>이다.  
그렇기에 Front-end의 기술이 좋다고 해도 <u>결과물이 형편이 없다면 가치를 인정받을 수 없다</u>.  
아무리 실력이 있는 개발자라도 형편없는 디자인과 UX를 가진 서비스를 만들어낸다면 사람들은 구현해낸 능력을 보지 않는다.   
그래서 일단 잘 만드는 것이 중요하다.  
`'디자인과 UX는 개발자가 관여하지 않는거 아닌가요?'`라는 궁금증이 생긴다면 <span style="color:blue">마인드를 고쳐야</span>한다.  
<u>개발자가 얼마 만큼 서포트를 하느냐에 따라</u> -> <span style="color:blue">디자인과 UX는 얼마든지 좋아질 수</span> 있다.  
좋은 디자이너와 UX를 선별하고 조율하는 것도 Front-end의 능력이다.  

좋은 서비스가 무엇인지에 대한 철학, 좋은 서비스를 만들기 위해서라면 내가 한 것을 갈아 엎을 수도 있는 용기와 끈기,  
좋은 서비스를 만들기 위해 협업하고 조율하는 과정, 좋은 서비스를 골라낼 수 있는 시각,  
좋은 서비스를 만들기 위한 문제 인식 과정 등 좋은 서비스를 위한 모든 행동들이  
잘하는 Front-end 개발자로 만들어 줄 것이다.  

## 정해진 리소스 안에서 되게 해주는 것!  
일정과 인력이라고 하는 `정해진 리소스` 안에서 <span style="color:red">어떻게든 최대한의 퍼모먼스를</span> 내어 요구하는 것을  
구현해주는 것이 <span style="color:blue">개발자의 역할</span>이다.  
그리고 이것을 함께 하는 사람들과 원만하게 잘 해낼 수 있는 사람이 좋은 Front-end 개발자일 것이다.  
이렇게 하기 위해서는 -> <span style="color:blue">요구사항을 잘 이해</span>하고, <span style="color:blue">잘 소통해야하고</span> 적극적으로 협업을 해야한다.  
결과적으로 <span style="color:blue">좋은 서비스</span>를 만들어내야 <span style="color:red">좋은 개발자</span>가 되는 것이기에 최대한의 요구사항을 충족시키기 위해  
노력을 하면서도 정해진 리소스가 부족할 때에는 가능한 더 나은 방식을 찾아보고 대안을 제시할 수 있어야 한다.  

<style>
.red {
  color: ivory;
  background-color: red;
}

.tomato {
  color: ivory;
  background-color: tomato;
}

.blue {
  color: ivory;
  background-color: blue;
}

.royalblue {
  color: ivory;
  background-color: royalblue;
}

.forestgreen {
  color: ivory;
  background-color: forestgreen;
}

.darkorange {
  color: ivory;
  background-color: darkorange;
}
</style>

<!-- ### 2. Link 넣기

```

유형 1: (설명어를 입력) : [gunhee's coding blog](https://gunhee-jeong.github.io/)
유형 2: (URL 자동연결) : <https://gunhee-jeong.github.io/>
유형 3: (동일 파일 내 '문단으로 이동') : [1. Header로 이동](###-1-header)

```

유형 1: (설명어를 입력) : [gunhee's coding blog](https://gunhee-jeong.github.io/)
유형 2: (URL 자동연결) : <https://gunhee-jeong.github.io/>
유형 3: (동일 파일 내 '문단으로 이동') : [1. Header로 이동](#1-header)
유형 3의 방법

1. 특수문자를 제거
2. 스페이스는 -로 바꾸고
3. 대문자는 소문자로!
   그래서 ### 1. Header -> #1-header

## Link: [google][https://www.google.com/]

### 3. 수평선

```

---

```

---

### 4. 라인 바꾸기

```

스페이스바를 2번 눌러주면 다음칸으로
이동할 수 있어요!

```

---

스페이스바를 2번 눌러주면
다음칸으로 이동할 수 있어요!

### 5. list 만들기

```

1. 1번
2. 2번
3. 3번

- 순서없는 list
  - 순서없는 list
    - 순서없는 list

```

1. 1번
2. 2번
3. 3번

- 순서없는 list
  - 순서없는 list
    - 순서없는 list

---

### 6. font 관련

```

**진하게** -> 볼드
_기울여서_ -> 이탤릭체
~~취소선~~ -> 취소선

<ul>밑줄넣기</ul> -> 밑줄
<span style="color:red">빨간 글씨</span> -> 글자색
이것이 `인라인` 입니다 -> 인라인 코드
```

**진하게** -> 볼드
_기울여서_ -> 이탤릭체
~~취소선~~ -> 취소선
<u>밑줄넣기</u> -> 밑줄
<span style="color:red">빨간 글씨</span>
이것이 `인라인` 입니다 -> 인라인 코드

---

### 7. 인용구문

```
> coding
>
> > JavaScript
> >
> > > 내가 프짱!
```

> coding
>
> > JavaScript
> >
> > > 내가 프짱!

---

### 8. 이미지 삽입

```
유형1: ('사이즈를 조절' -> HTML 태그 사용) : <img src="https://gunhee-jeong.github.io/assets/images/blogLogo.png" width="300" height="200">
유형2: (이미지 삽입 후 -> 링크 걸기)
[![이미지](https://gunhee-jeong.github.io/assets/images/blogLogo/blogLogo.png)](https://gunhee-jeong.github.io/)
```

유형1: ('사이즈를 조절' -> HTML 태그 사용) : <img src="https://gunhee-jeong.github.io/assets/images/blogLogo.png" width="300" height="200">
유형2: (이미지 삽입 후 -> 링크 걸기)
[![이미지](https://gunhee-jeong.github.io/assets/images/blogLogo.png)](https://gunhee-jeong.github.io/)

### 9. 표 만들기

```
||국어|영어|
| :--- | ---: | :--: |
|건희 | 100점 | 100점
|철수 | 100점 | 100점
```

|      |  국어 | 영어  |
| :--- | ----: | :---: |
| 건희 | 100점 | 100점 |
| 철수 | 100점 | 100점 |

> - header를 넣고 싶은 경우 ---을 사용하고 :을 이용하여 정렬에 사용함!

### 10. 토글 만들기

```
<details>
<summary>여기를 누르세요</summary>
<div markdown="1">
숨겨진 내용
</div>
</details>
```

<details>
<summary>여기를 누르세요</summary>
<div markdown="1">
숨겨진 내용
</div>
</details> -->
