---
layout: single
title: "모두의 네트워크 -> 7장 응용 계층: 애플리케이션에 데이터 전송하기"
# categories: Git
categories:
  - network # HTML CSS JavaScript Server Algorithm Wecode Programmers CS vsCode
tag: [모두의 네트워크] #tag는 여러개 가능함
toc: true #table of content 기능!
toc_sticky: true
author_profile: true #blog 글안에서는 author_profile이 따라다니지 않도록 설정함
date: 2022-05-08T08:30:00+09:00   
# sidebar:
# nav: "docs" #네비게이션에 있는 docs를 의미함
---  
# 28장 응용 계층의 역할
## 1. 응용 계층의 역할
애플리케이션은 서비스를 요청하는 측(사용자 측)에서 사용하는 애플리케이션으로 분류할 수 있고,  
서비스를 제공하는 측도 있다.   
<img src="https://user-images.githubusercontent.com/87808288/178613260-d1381f3c-e0f9-4a01-b923-2678729c0474.png" width="400">  

일반적으로 서비스를 요청하는 측은 <span style="color:red">클라이언트</span>, 서비스를 제공하는 측은 <span style="color:red">서버</span>라고 한다.  
웹 브라우저나 메일 프로그램 등은 사용자 측에서 사용하는 애플리케이션이므로 -> 클라이언트  

반면에 서비스를 제공하는 측인 서버에는 웹 서버 프로그램과 메일 서버 프로그램 등이 있다.  
그리고 이러한 애플리케이션은 응용 계층에서 동작한다.  
(애플리케이션이 동작하는 계층이라서 응용 계층인 것이다.)  

응용 계층에서는 사용자 측(클라이언트)의 요청을 전달하기 위해 통신 대상(서버 등)이 이해할 수 있는  
메시지(데이터)로 변환하고 전송 계층으로 전달하는 역할을 한다.  
<img src="https://user-images.githubusercontent.com/87808288/167275627-7f6af204-af36-418b-9202-ddab069779f9.png" width="500">  
위의 그림과 같이, 클라이언트 측 애플리케이션이 서버 측 애플리케이션과 통신하려면  
<span style="color:red">응용 계층의 프로토콜</span>을 사용해야 한다.   

|프로토콜|내용|
|:--:|:--:|
|HTTP|웹 사이트 접속|
|DNS|이름 해석|
|FTP|파일 전송|
|SMTP|메일 송신|
|POP3|메일 수신|  

위의 표와 같이, 웹 사이트를 볼 때는 `HTTP`,  
파일을 전송할 때는 `FTP`,  
메일을 보낼 때는 `SMTP`,  
메일을 받을 때는 `POP3`라는 프로토콜을 사용한다.  
그리고 네트워크에서 컴퓨터나 네트워크 장비에 붙여진 이름을 기반으로 IP 주소를 알아내는 것을  
<span style="color:blue">이름 해석</span>이라고 하는데, 이를 위해 `DNS`를 사용한다.  

응용 계층은 각각의 애플리케이션에 대응되는 데이터를 전송하는 역할을 한다.  
그리고 응용 계층에서 보내려는 데이터는 하위 계층인 전송 계층, 네트워크 계층, 데이터 링크 계층,  
물리 계층 순서로 처리된다.  
<img src="https://user-images.githubusercontent.com/87808288/178613984-1ede8058-7842-4817-9f33-b200a554dd64.png" width="500">  

# 29장 웹 서버의 구조(웹 사이트 접속)
## 1. WWW란?
WWW은 줄여서 W3나 웹(Web)이라고도 불린다.  
<span style="color:red">WWW</span>에서는 <span style="color:blue">HTML</span>, <span style="color:blue">URL</span>, <span style="color:blue">HTTP</span>라는 세 가지 기술이 사용된다.  

<span style="color:red">HTML</span>은 웹 페이지에서 문장 구조나 문자를 꾸미는 태그를 사용하여 작성하는 <span style="color:blue">마크업 언어</span>이다.  
제목이나 목록과 같은 문장 구조를 지정하거나 이미지 파일을 보여 줄 때도 <span style="color:blue">태그</span>를 사용한다.  
또한 HTML은 하이퍼텍스트(hypertext)를 작성하는 마크업 언어라고도 한다.  
<span style="color:red">하이퍼텍스트</span>로는 <u>문자와 이미지</u>를 표시하거나 <u>하이퍼링크</u>를 사용할 수도 있다.  
<img src="https://user-images.githubusercontent.com/87808288/178614481-af026df6-7d5b-44f2-b2f4-69df9500317c.png" width="500">  
위의 그림과 같이 문서와 이미지는 각각 별도로 요청한다.  
그래서 글과 이미지가 나중에 보일 때가 있는 것이다.  

## 2. HTTP란?
`HTTP`는 <u>웹 서비스</u>에서 <span style="color:blue">클라이언트(웹 브라우저)</span>와 <span style="color:blue">웹 서버 간</span>에 정보를 주고받기 위해 사용되는 <span style="color:red">네트워크 프로토콜</span>이다.  

클라이언트(웹 브라우저)는 웹 사이트를 보기 위해 서버(웹 서버 프로그램)의 `80번 포트`를 사용하여 <span style="color:blue">HTTP 통신</span>을 한다.  
아래의 그림과 같이 클라이언트에서 HTTP 요청을 보내고 서버에서 HTTP 응답을 반환한다.  
<img src="https://user-images.githubusercontent.com/87808288/167316944-75e19a70-29c3-460a-9f39-edd02f8d01e8.png" width="500">  
클라이언트가 데이터를 요청할 때는 "GET"이라고 하는 요청 정보, 파일 이름, 버전 등을 서버에 전송한다.  
그러면 서버에서는 응답으로 요청을 정상적으로 처리했다는 'OK'라는 정보를 반환하고 index.html을 클라이언트에 보낸다.  
이렇게 <u>웹 브라우저</u>에서는 <span style="color:red">HTTP 요청</span>을 보내고, <u>웹 서버</u>에서는 <span style="color:red">HTTP 응답</span>을 반환한다.  

지금은 HTTP/2나 HTTP/1.1 버전을 사용하지만, 예전의 HTTP/1.0 버전에서는  
요청을 보낼 때마다 연결했다 끊는 작업을 반복했다.  
그러다 <span style="color:blue">HTTP/ 1.1</span> 버전에서는 <span style="color:red">keepalive</span>라는 기능이 추가되었다.  

킵어라이브(keepalive)는 아래의 그림과 같이,  
`연결을 한 번 수립하면 데이터 교환을 마칠 때까지 유지`하고, <u>데이터 교환을 모두 끝내면 연결을 끊는</u> 구조이다.  
<img src="https://user-images.githubusercontent.com/87808288/167317130-5aa2cde7-c505-4a91-890f-50e8e11199e6.png" width="500">  
keepalive는 요청도 순서대로 처리하는 특징이 있어서,  
1의 요청에 대해 1의 응답을 반환하고 -> 2의 요청에 대해 2의 응답을 반환한다.  

최근에는 HTTP/1.1 버전의 단점을 보완해서 빠르게 콘텐츠를 표시할 수 있는 프로토콜인 HTTP/2버전도 사용하게 되었다.  
HTTP/1.1 버전은 요청을 보낸 순서대로 응답을 반환하는데  
이런 경우에는 이전 요청을 처리하는 데 시간이 길어지면 다음 요청에 대한 처리가 늦어진다.  
그렇게 나온 것이 바로 HTTP/2 버전이다. <span style="color:red">HTTP/2</span> 버전은 <span style="color:blue">요청을 보낸 순서대로 응답을 반환하지 않아도</span> 된다.  
그래서 보다 빠르게 콘텐츠를 표시할 수 있게 되었다.  
<img src="https://user-images.githubusercontent.com/87808288/167317511-c0c9cf05-cca6-487c-b5b0-f41c18afb3df.png" width="500">  
그림을 보면 2의 요청에 대한 응답이 맨 먼저 도착하고, 1의 요청에 대한 응답이 맨 끝에 도착한 것을 확인할 수 있다.  
이렇게 HTTP/1.1 버전과는 다르게 동작하는 것을 알 수 있다. 

# 30장 DNS 서버의 구조(이름 해석)
## 1. 도메인 이름이란?
기본적으로 컴퓨터(서버)에는 IP 주소가 있어서 인터넷을 통해 서버에 접속하여 웹사이트를 볼 수 있다.  
그런데 우리는 컴퓨터(서버)에 접속하려면 IP 주소를 입력해야 하는데,  
우리는 www.xxx.com이라는 주소를 입력했다.  
IP 주소가 아닌데도 웹 사이트를 볼 수 있었던 것이다.  
이러한 것은 간단히 말하면 <span style="color:red">DNS</span>는 URL을 IP 주소로 변환하는 서비스(시스템)이다.  
IP 주소는 222.235.64.222와 같은 숫자로 구성이 되는데,  
www.xxx.com 대신에 IP 주소인 222.235.64.222을 입력해야한다면 이를 기억하는 것은 쉽지 않을 것이다.  
이러한 이유로 IP 주소가 아닌 www.xxx.com과 같은 주소를 사용하여 접속하도록  
돕는 것을 DNS의 <span style="color:red">이름 해석(name resolution)</span>이라고 한다.  
www.xxx.com에 접속하면 DNS 서버가 이 웹 사이트 서버의 IP 주소를 알려주는 것이다.  
이를 '이름 해석'이라고 한다.  
www.xxx.com과 같이 컴퓨터나 네트워크를 식별하기 위해 붙여진 이름을 <span style="color:red">도메인 이름</span>(<span style="color:blue">xxx.com</span>)이라고 하고,  
도메인 이름 앞에 있는 <span style="color:blue">www</span>는 <span style="color:red">호스트 이름(서버 이름)</span>이라고 한다.  

아래의 그림과 같이 웹 브라우저가 www.xxx.com에 접속하면,  
컴퓨터와 DNS 서버 사이에서는 1~3와 같은 통신의 교환이 일어난다.   
<img src="https://user-images.githubusercontent.com/87808288/167319103-653d69f6-6dde-4671-ab8a-6a807b048e74.png" width="500">  

1. 컴퓨터에서 '이 도메인 이름의 IP 주소는 무엇인가요?'라고 질문한다.
2. DNS 서버는 해당 요청에 해당하는 도메인 이름의 IP 주소를 알려준다.
3. 컴퓨터는 IP 주소로 서버에 접속한다.  

이렇게 처음에는 웹 사이트의 IP 주소를 모르기 때문에 먼저 DNS 서버에 요청하여 IP 주소를 확인하고 웹 서버에 접속한다.  

그러나 `요청한 첫 번째 DNS 서버가 도메인의 IP 주소를 모르는 경우도 있다`.  
그럴 경우에는 아래의 그림과 같이 <span style="color:blue">DNS 서버 1이 DNS 서버 2에 요청을 보낸다</span>.  
<img src="https://user-images.githubusercontent.com/87808288/167319246-b6be77dc-c30a-4ae1-8068-46229f4ac212.png" width="600">  
<span style="color:blue">DNS 서버는 전 세계에</span> 흩어져 있고 `모두 계층적으로 연결`되어 있다.  

# 31장 메일 서버의 구조(SMTP와 POP3)
## 1. 메일의 송수신 구조
메일을 송수신하려면 클라이언트 측의 메일 프로그램과 서버 측의 메일 서버 프로그램 간에 통신을 해야 한다.  
이때 사용되는 프로토콜에는 두 가지 종류가 존재한다.  

<span style="color:blue">메일을 보내는</span> 데 사용되는 프로토콜은 SMTP이고, <span style="color:blue">메일을 받는</span> 데 사용되는 프로토콜은 POP3이다.  
<span style="color:red">SMTP</span>는 `포트 번호로 25번`을 사용하고 <span style="color:red">POP3</span>는 `110번`을 사용한다.  

아래의 그림과 같이 SMTP와 POP3을 사용하면 메일을 주고받을 수 있게 된다.  
<span style="color:blue">SMTP는 메일 서버 간의 메일 전송에도 이용</span>된다.  
<img src="https://user-images.githubusercontent.com/87808288/178617963-5d009040-1afb-4efa-919c-08ea091a71c2.png" width="500">  
컴퓨터 1의 사용자는 메일 서버 1을 사용하는데,  
메일 서비스를 제공하는 포털사이트나 회사의 메일 서버를 사용하는 경우가 많다.   
그래서 메일을 보낼 때는 메일 서비스를 제공하는 포털사이트나 회사의 메일 서버에 메일을 보내게 되는 것이다.  
(그 서버가 그림에서는 메일 서버 1에 해당한다.)  
그리고 메일 서버를 사용하기 위해서는 -> 컴퓨터 1에서 사용하는 메일 프로그램에 메일 서비스를 제공하는  
메일 서버의 호스트 이름(서버 이름)을 설정하면 된다. 그러면 메일 서버 1로 메일을 보낼 수 있다.  

## 2. SMTP에 의한 메일 송신과 메일 전송
컴퓨터 1과 메일 서버 1간의 통신을 좀 더 자세히 살펴보자면,  
우선 컴퓨터 1의 메일 프로그램은 SMTP를 사용하여 메일 서버 1로 메일을 보낸다.  
<img src="https://user-images.githubusercontent.com/87808288/167319837-543407c0-25a9-4174-8234-4ea0359cad89.png" width="500">  
이제 컴퓨터 1에서 매일 서버 1로 메일을 보냈다.  
아래의 그림과 같이 SMTP를 사용하여 메일 서버 1에서 메일 서버 2로 메일을 전송한다.  
<img src="https://user-images.githubusercontent.com/87808288/178618247-4ca219a2-1438-46ec-ab33-15c93eee5fa9.png" width="500">  

## (3) POP3에 의한 메일 수신
SMTP로 메일 서버 1이 메일 서버 2로 메일을 전송할 수 있다.  
메일 서버에는 <span style="color:blue">메일 박스</span>라고 하는 메일을 보관해 주는 기능이 있다.  
아래의 그림과 같이 메일 서버 2는 POP3를 사용하여 메일 서버 2의 메일 박스에서 메일을 가져와 컴퓨터 2로 전송한다.  
<img src="https://user-images.githubusercontent.com/87808288/178618420-e385c4a7-caeb-44ff-a115-44dd5765d188.png" width="500">  
메일 서버 2에 컴퓨터 1의 메일이 도착하면 컴퓨터 2는 메일 서버 2의 메일 박스에 있는 메일을 받아 가야 하지만  
아래의 그림과 같이 메일을 수신할 때는 사용자 이름과 비밀번호를 이용한 사용자 인증을 필요로 한다.  
<img src="https://user-images.githubusercontent.com/87808288/178618515-257f6629-c69f-4aec-8ac4-6d964465556c.png" width="500">   

1. 세션을 시작한다.
2. 컴퓨터 2에서 받는 사람의 사용자 이름을 통지하고 메일 서버 2에 'OK'라는 확인 응답을 반환한다.  
3. 컴퓨터 2에서 수신자의 비밀번호를 통지하고 메일 서버 2에 '비밀번호 확인'이라는 확인 응답을 반환한다.
4. 컴퓨터 2에서 자신의 메일이 있는지 확인하고 메일 서버 2는 '있음'이라는 확인 응답을 반환한다.
5. 컴퓨터 2에서 메일 박스에 보관된 이메일을 전송받는다.
6. 세션을 종료한다.  

<!-- ### 2. Link 넣기

```

유형 1: (설명어를 입력) : [gunhee's coding blog](https://gunhee-jeong.github.io/)
유형 2: (URL 자동연결) : <https://gunhee-jeong.github.io/>
유형 3: (동일 파일 내 '문단으로 이동') : [1. Header로 이동](###-1-header)

```

유형 1: (설명어를 입력) : [gunhee's coding blog](https://gunhee-jeong.github.io/)
유형 2: (URL 자동연결) : <https://gunhee-jeong.github.io/>
유형 3: (동일 파일 내 '문단으로 이동') : [1. Header로 이동](#1-header)
유형 3의 방법

1. 특수문자를 제거
2. 스페이스는 -로 바꾸고
3. 대문자는 소문자로!
   그래서 ### 1. Header -> #1-header

## Link: [google][https://www.google.com/]

### 3. 수평선

```

---

```

---

### 4. 라인 바꾸기

```

스페이스바를 2번 눌러주면 다음칸으로
이동할 수 있어요!

```

---

스페이스바를 2번 눌러주면
다음칸으로 이동할 수 있어요!

### 5. list 만들기

```

1. 1번
2. 2번
3. 3번

- 순서없는 list
  - 순서없는 list
    - 순서없는 list

```

1. 1번
2. 2번
3. 3번

- 순서없는 list
  - 순서없는 list
    - 순서없는 list

---

### 6. font 관련

```

**진하게** -> 볼드
_기울여서_ -> 이탤릭체
~~취소선~~ -> 취소선

<ul>밑줄넣기</ul> -> 밑줄
<span style="color:red">빨간 글씨</span> -> 글자색
이것이 `인라인` 입니다 -> 인라인 코드
```

**진하게** -> 볼드
_기울여서_ -> 이탤릭체
~~취소선~~ -> 취소선
<u>밑줄넣기</u> -> 밑줄
<span style="color:red">빨간 글씨</span>
이것이 `인라인` 입니다 -> 인라인 코드

---

### 7. 인용구문

```
> coding
>
> > JavaScript
> >
> > > 내가 프짱!
```

> coding
>
> > JavaScript
> >
> > > 내가 프짱!

---

### 8. 이미지 삽입

```
유형1: ('사이즈를 조절' -> HTML 태그 사용) : <img src="https://gunhee-jeong.github.io/assets/images/blogLogo.png" width="300" height="200">
유형2: (이미지 삽입 후 -> 링크 걸기)
[![이미지](https://gunhee-jeong.github.io/assets/images/blogLogo/blogLogo.png)](https://gunhee-jeong.github.io/)
```

유형1: ('사이즈를 조절' -> HTML 태그 사용) : <img src="https://gunhee-jeong.github.io/assets/images/blogLogo.png" width="300" height="200">
유형2: (이미지 삽입 후 -> 링크 걸기)
[![이미지](https://gunhee-jeong.github.io/assets/images/blogLogo.png)](https://gunhee-jeong.github.io/)

### 9. 표 만들기

```
||국어|영어|
| :--- | ---: | :--: |
|건희 | 100점 | 100점
|철수 | 100점 | 100점
```

|      |  국어 | 영어  |
| :--- | ----: | :---: |
| 건희 | 100점 | 100점 |
| 철수 | 100점 | 100점 |

> - header를 넣고 싶은 경우 ---을 사용하고 :을 이용하여 정렬에 사용함!

### 10. 토글 만들기

```
<details>
<summary>여기를 누르세요</summary>
<div markdown="1">
숨겨진 내용
</div>
</details>
```

<details>
<summary>여기를 누르세요</summary>
<div markdown="1">
숨겨진 내용
</div>
</details> -->
