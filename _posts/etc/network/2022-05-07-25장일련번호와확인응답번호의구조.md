---
layout: single
title: "25장 일련번호와 확인 응답 번호의 구조"
# categories: Git
categories:
  - network # HTML CSS JavaScript Server Algorithm Wecode Programmers CS vsCode
tag: [모두의 네트워크] #tag는 여러개 가능함
toc: true #table of content 기능!
toc_sticky: true
author_profile: true #blog 글안에서는 author_profile이 따라다니지 않도록 설정함
date: 2022-05-07T11:10:00+09:00   
# sidebar:
# nav: "docs" #네비게이션에 있는 docs를 의미함
---  
# 25장 일련번호와 확인 응답 번호의 구조  
## (1) 일련번호와 확인 응답 번호란?  
`3-way 핸드셰이크가 끝나고` 실제 데이터를 보내거나 상대방이 받을 때는 <span style="color:red">TCP 헤더의 일련번호</span>와  
<span style="color:red">확인 응답 번호</span>를 사용한다.  
<img src="https://user-images.githubusercontent.com/87808288/167234309-f0a5fcf3-fc1a-4ae7-8fb8-2b45f0cd8d24.png" width="500">  

TCP는 데이터를 분할해 보내는데 일련번호는 송신 측에서 수신 측에 '이 데이터가 몇 번째 데이터인지' 알려 주는 역할을 한다.  
전송된 데이터에 일련번호를 부여하여 수신자는 원래 데이터의 몇 번째 데이터를 받았는지 알 수 있다.  

확인 응답 번호는 수신 측이 몇 번째 데이터를 수신했는지 송신 측에 알려주는 역할을 한다.  
그래서 이 번호는 다음 번호의 데이터를 요청하는 데도 사용된다.  
예를 들어 10번 데이터를 수신하면 11번 데이터를 송신 측에 요청한다. -> 이것을 확인 응답이라고 한다.  

'3001'번은 지금 보내는 200바이트 데이터의 첫 번째 바이트의 번호고,  
확인 응답 번호는 다음에 보냈으면 하는 데이터의 첫 번째 바이트 번호가 되는 것이다.  
<img src="https://user-images.githubusercontent.com/87808288/167234473-b0162454-e52f-41aa-844f-62e86a057931.png" width="500">   
위의 그림에서 데이터를 전송하기 전 단계에서 3-way 핸드셰이크 연결 수립이 이루어질 때 -> 이번 통신에 사용하는  
일련번호인 '3001'번과 확인 응답 번호인 '4001'번이 결정된다.  

1. 컴퓨터 1은 컴퓨터 2로 200바이트의 데이터를 전송한다.  
2. 컴퓨터 2는 200바이트를 수신하고 다음에 수신하고자 하는 데이터 번호를 확인 응답 번호로 넣는다.  
다음에 수신하고자 하는 데이터는 3001 + 200 = 3201이므로 3201번부터 보내 달라 요청한다.  
3. 컴퓨터 1은 컴퓨터 2로 3201번부터 200바이트의 데이터를 전송한다.  
4. 컴퓨터 2는 200바이트를 수신하고 다음에 수신하고자 하는 데이터의 번호를 확인 응답 번호에 넣는다.  
다음에 수신하고자 하는 데이터는 3201 + 200 = 3401이므로 3401번부터 보내 달라고 요청한다.  

여기에서 TCP의 특징이 나오는데  
데이터가 항상 올바르게 전달되는 것은 아니므로 -> 일련번호와 확인 응답 번호를 사용해서   
<span style="color:blue">데이터가 손상되거나 유실된 경우에 데이터를 재전송</span>하게 되어 있다. -> 이것을 <span style="color:red">재전송 제어</span>라고 한다.  

## (2) 윈도우 크기란?  
데이터를 한 번 보낼 때마다 한 번 응답을 반환하는 방식은 효율이 높지 않다.  
그대신 매번 확인 응답을 기다리는 대신 세그먼트를 연속해서 보내고 난 다음에 확인 응답을 반환하면 효율이 높아진다.  
그리고 받은 `세그먼트를 일시적으로 보관하는 장소`가 있는데 -> 그 장소를 <span style="color:red">버퍼(buffer)</span>라고 한다.  
이 버퍼 덕분에 세그먼트를 연속해서 보내도 수신 측은 대응할 수 있고 확인 응답의 효율도 높아진다.  

하지만 수신 측이 세그먼트를 대량으로 받아서 처리하지 못하는 경우가 생기는데  
<span style="color:blue">수신 측은 대량으로 데이터가 전송되면 보관하지 못하고 넘쳐</span> 버린다. 이것을 <span style="color:red">오버플로(overFlow)</span>라고 한다.  
그래서 오버플로가 발생하지 않도록 `버퍼의 한계 크기를 알고 있어야` 한다.  
그것이 TCP 헤더의 <span style="color:red">윈도우 크기(window size)</span> 값에 해당한다.  

윈도우 크기는 얼마나 많은 용량의 데이터를 저장해 둘 수 있는지를 나타내는 것이다.  
즉, 확인 응답을 일일이 하지 않고 연속해서 송수신할 수 있는 데이터 크기이다.  
윈도우 크기의 초기값은 3-way 핸드셰이크를 할 때 판단한다.  
<img src="https://user-images.githubusercontent.com/87808288/167237757-96bd366c-82c2-49f2-8fd8-6ac29088ac20.png" width="500">  
위의 그림처럼 상대방 버퍼의 한계 값을 알았으면 -> 세그먼트(데이터)를 오버플로되지 않도록 보내면 되는 것이다.  
<img src="https://user-images.githubusercontent.com/87808288/167237807-69bc1925-f2b2-464c-ae20-1c1b39d533a4.png" width="500">  

확인 응답을 기다리지 않고 세그먼트(데이트)를 연속해서 보내면 아래와 같이 통신하게 된다.  
<img src="https://user-images.githubusercontent.com/87808288/167237842-9dff30cf-4c3d-4d35-87c5-8be97c0cec58.png" width="500">  
위의 그림처럼 수신 측이 윈도우 크기를 가지고 있다면 확인 응답을 받지 않고도 세그먼트(데이터)를  
연속적으로 전송할 수 있다.  


<!-- ### 2. Link 넣기

```

유형 1: (설명어를 입력) : [gunhee's coding blog](https://gunhee-jeong.github.io/)
유형 2: (URL 자동연결) : <https://gunhee-jeong.github.io/>
유형 3: (동일 파일 내 '문단으로 이동') : [1. Header로 이동](###-1-header)

```

유형 1: (설명어를 입력) : [gunhee's coding blog](https://gunhee-jeong.github.io/)
유형 2: (URL 자동연결) : <https://gunhee-jeong.github.io/>
유형 3: (동일 파일 내 '문단으로 이동') : [1. Header로 이동](#1-header)
유형 3의 방법

1. 특수문자를 제거
2. 스페이스는 -로 바꾸고
3. 대문자는 소문자로!
   그래서 ### 1. Header -> #1-header

## Link: [google][https://www.google.com/]

### 3. 수평선

```

---

```

---

### 4. 라인 바꾸기

```

스페이스바를 2번 눌러주면 다음칸으로
이동할 수 있어요!

```

---

스페이스바를 2번 눌러주면
다음칸으로 이동할 수 있어요!

### 5. list 만들기

```

1. 1번
2. 2번
3. 3번

- 순서없는 list
  - 순서없는 list
    - 순서없는 list

```

1. 1번
2. 2번
3. 3번

- 순서없는 list
  - 순서없는 list
    - 순서없는 list

---

### 6. font 관련

```

**진하게** -> 볼드
_기울여서_ -> 이탤릭체
~~취소선~~ -> 취소선

<ul>밑줄넣기</ul> -> 밑줄
<span style="color:red">빨간 글씨</span> -> 글자색
이것이 `인라인` 입니다 -> 인라인 코드
```

**진하게** -> 볼드
_기울여서_ -> 이탤릭체
~~취소선~~ -> 취소선
<u>밑줄넣기</u> -> 밑줄
<span style="color:red">빨간 글씨</span>
이것이 `인라인` 입니다 -> 인라인 코드

---

### 7. 인용구문

```
> coding
>
> > JavaScript
> >
> > > 내가 프짱!
```

> coding
>
> > JavaScript
> >
> > > 내가 프짱!

---

### 8. 이미지 삽입

```
유형1: ('사이즈를 조절' -> HTML 태그 사용) : <img src="https://gunhee-jeong.github.io/assets/images/blogLogo.png" width="300" height="200">
유형2: (이미지 삽입 후 -> 링크 걸기)
[![이미지](https://gunhee-jeong.github.io/assets/images/blogLogo/blogLogo.png)](https://gunhee-jeong.github.io/)
```

유형1: ('사이즈를 조절' -> HTML 태그 사용) : <img src="https://gunhee-jeong.github.io/assets/images/blogLogo.png" width="300" height="200">
유형2: (이미지 삽입 후 -> 링크 걸기)
[![이미지](https://gunhee-jeong.github.io/assets/images/blogLogo.png)](https://gunhee-jeong.github.io/)

### 9. 표 만들기

```
||국어|영어|
| :--- | ---: | :--: |
|건희 | 100점 | 100점
|철수 | 100점 | 100점
```

|      |  국어 | 영어  |
| :--- | ----: | :---: |
| 건희 | 100점 | 100점 |
| 철수 | 100점 | 100점 |

> - header를 넣고 싶은 경우 ---을 사용하고 :을 이용하여 정렬에 사용함!

### 10. 토글 만들기

```
<details>
<summary>여기를 누르세요</summary>
<div markdown="1">
숨겨진 내용
</div>
</details>
```

<details>
<summary>여기를 누르세요</summary>
<div markdown="1">
숨겨진 내용
</div>
</details> -->
