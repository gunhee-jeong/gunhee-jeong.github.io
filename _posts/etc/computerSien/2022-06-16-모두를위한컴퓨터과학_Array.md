---
layout: single
title: "모두를 위한 컴퓨터 과학 -> Array"
# categories: Git
categories:
  - CS # HTML CSS JavaScript Server Algorithm Wecodes Programmers CS Github Blog
tag: [모두를 위한 컴퓨터 과학] #tag는 여러개 가능함
toc: true #table of content 기능!
toc_sticky: true
author_profile: true #blog 글안에서는 author_profile이 따라다니지 않도록 설정함
date: 2022-06-16T16:20:00+09:00
# sidebar:
# nav: "docs" #네비게이션에 있는 docs를 의미함
---
# 3장 Array
## 1. 컴파일링
```c
#include <stdio.h>
```
위의 코드는 <span style="color:red">시작한다는 의미</span>를 가지며 꼭 추가되어야 한다.  
정확히 말하면 stdio.h는 헤더 파일로 C언어로 작성되어 있으며 파일명이 .h로 끝나는 파일이다.  
(printf 함수를 사용하기 위해서는 stdio.h 라이브러리를 필요로 한다.)  
<u>이 파일에는</u> <span style="color:royalblue">printf 함수의 프로토타입이</span> 있어서 Clang 컴파일러가 프로그램을 컴파일할 때  
printf가 무엇인지 알려주는 역할을 하게 된다.  

```c
#include <stdio.h> //-> '시작한다'는 의미를 가지고 있다.  

int main(void)
{
  printf("hello, world"); //이 코드의 핵심적인 내용
}
```  

위의 코드를 좀더 자세히 들여다보자면,  
우선 <u>main이라는 함수</u>가 있는 것이다. 프로그램의 시작점으로 실행 버튼을 클릭하는 것과 같다.  

### (1) clang  
'<span style="color:red">clang</span>'은 코드를 컴파일하는 프로그램의 이름으로, clang을 통해서 소스코드를 <span style="color:blue">머신코드로 번역</span>할 수 있다.   
```bash
clang hello.c
```
위의 명령어를 터미널에서 입력하는 순간 <u>a.out이라는 파일이 생성</u>된다.  
(파일 종류 -> <u>hello.c</u>, <u>a.out</u>)  
이 `a.out`에는 바로 `머신코드`가 들어있다.  
(<u>'hello.c'</u>라는 파일을 `clang hello.c`를 통해서 <span style="color:blue">a.out</span>이라는 <span style="color:red">머신코드</span>로 변환한다.)   

### ./  

```bash
./a.out
```  
위의 명령어는 컴퓨터가 현재 디렉토리에 있는 <u>a.out이라는 프로그램을 실행</u>하도록 한다.  
<u>'.'은 현재의 위치</u>를 나타내고,  
'/a.out'은 이 디렉토리에서 a.out이라는 <span style="color:royalblue">파일을 실행하라는 것</span>을 의미한다.  
결과적으로 아래의 결과를 출력한다.  
```bash
hello world$
```
그런데 여기서 $가 나오는 것은 프롬프트에 불과하지만, 우리는 <u>'hello world'라는 결과를 원한 것</u>이지  
'hello world$'라는 결과를 원한 것이 아니다.  
따라서 우리는 $가 뒤에 붙지 않도록 줄바꿈을 해주어야하고

```c
#include <stdio.h>

int main(void)
{
  printf("hello, world\n"); //이 코드의 핵심적인 내용
}
```
이렇게 printf("hello, world<span style="color:red">\n</span>")라는 것을 사용해서 <u>컴퓨터로 하여금 줄을 바꾸도록 설정</u>해야한다.  

하지만 여기서도 바로 "./a.out" 명령어를 터미널에서 입력한다고해서 -> 우리가 원하는 결과를 얻지 못한다.  
<span style="color:blue">바로 컴파일을 하지 않았기 때문</span>이다!  
```c
clang hello.c
./a.out
```
따라서 우리는 위와 같은 순서로 접근해야한다.  

### clang -o  
코드를 <span style="color:green">clang hello.c</span>로 컴파일하고 <span style="color:green">./a.out</span> 명령으로 프로그램을 실행할 때 이 과정은  
<u>컴퓨터가 이해하는 0과 1로 가득찬 파일</u> <span style="color:royalblue">a.out을 생성</span>하여 실행 가능하도록 한다.  
만약 <span style="color:blue">a.out과 다른 이름(hello)으로 컴파일을 하고 싶다면</span> 아래와 같은 명령행 인자를 추가하게 된다.  

```c
clang -o hello hello.c
```

(파일 종류 -> <span style="color:green">a.out</span>, <span style="color:green">hello.c</span>, <span style="color:green">hello</span>)  
<span style="color:purple">clang -o hello</span>를 통해서 <span style="color:green">hello.c</span>라는 `소스코드 파일`을 -> <span style="color:green">hello</span>라는 `머신코드 파일`로 만들었다.  
이렇게 a.out 파일과 같은 내용을 담은 hello 파일이 생성되었다.  
`clang -0`를 통해서 <span style="color:blue">생성되는 파일명을 지정</span>하게 되는 것이다.  

```c
./hello
```

위와 같이 실행하면 a.out 파일을 실행했을 때와 같은 결과를 보여준다!   

### clang -0 -l
```bash
clang -o hello hello.c -lcs50
```

위의 코드는 <span style="color:royalblue">clang에게 cs50 라이브러리에 있는 모든 0과 1들을 여기에 연결하라</span>는 의미이다.  
간단하게는, <span style="color:red">make</span> 프로그램을 이용하면 이 모든 컴파일 과정을 자동으로 처리할 수 있었다.  
이렇게 make나 clang을 사용해서 프로그램을 실행할 때 아래의 네 단계를 거치게 된다.  
<span style="color:red">전처리</span> -> <span style="color:red">컴파일링</span> -> <span style="color:red">어셈블링</span> -> <span style="color:red">링킹</span>  
이렇게 <span style="color:blue">C 소스 파일의 컴파일, 블드, 링크 작업을 자동화</span>해준다.  

## 2. 컴파일
```c
#include <stdio.h>

int main(void)
{
  printf("hello, world\n"); //이 코드의 핵심적인 내용
}
```

### (1) 전처리(Precompile)
첫 번째 단계가 바로 <span style="color:red">전처리</span>이다.  
<u>#으로 시작되는 C 소스 코드</u>는 전처리기에게 <span style="color:royalblue">실질적인 컴파일이 이루어지기 전</span>에 <span style="color:blue">무언가를 실행하라고 알려준다</span>.  

예를 들어, `#include`는 <span style="color:royalblue">전처리기에게 다른 파일의 내용을 포함시키라고 알려</span>준다.  
프로그램의 소스 코드에 #include와 같은 줄을 포함하면 ->  
<span style="color:royalblue">전처리기는 새로운 파일을 생성</span>하는데  
이 파일은 여전히 C 소스 코드 형태이며 <span style="color:blue">stdio.h 파일의 내용이 #include 부분에 포함</span>된다.  

### (2) 컴파일(Compile)
전처리기가 전처리한 소스 코드를 생성하고 나면 그 다음 단계는 <span style="color:red">컴파일</span>이다.  
<span style="color:red">컴파일러</span>라고 불리는 프로그램은 <u>C 코드를</u> <span style="color:blue">어셈블리어</span>라는 저수준 프로그래밍 언어로 컴파일한다.  

어셈블리는 C보다 연산의 종류가 훨씬 적지만,  
여러 연산들이 함께 사용되면 C에서 할 수 있는 모든 것을 수행할 수 있게 된다.  
C코드를 어셈블리 코드로 변환시켜줌으로써  
컴파일러는 <span style="color:royalblue">컴퓨터가 이해할 수 있는 언어와 최대한 가까운 프로그래밍으로 만들어</span> 준다.  
컴파일이라는 용어는 소스 코드에서 오브젝트 코드로 변환하는 전체 과정을 통틀어 일컫기도 하지만,  
구체적으로 전처리한 소스 코드를 어셈블리 코드로 변환시키는 단계를 말하기도 한다.  

### (3) 어셈블(Assemble)
<u>소스 코드</u>가 <span style="color:royalblue">어셈블리 코드</span>로 변환되면, 다음 단계인 <span style="color:red">어셈블 단계</span>로 <u>어셈블리 코드를 오브젝트 코드로 변환</u>시키는 것이다.  
<span style="color:royalblue">컴퓨터의 중앙처리장치가 프로그램을 어떻게 수행해야 하는지 알 수 있는 명령어 형태</span>인  
<span style="color:blue">연속된 0과 1들로 바꿔주는 작업</span>인 것이다. 이 변환 작업을 어셈블리라는 프로그램이 수행하게 된다.  
소스 코드에서 오브젝트 코드로 컴파일 되어야 할 파일이 딱 한 개라면,  
컴파일 작업은 여기서 끝나지만, 그러지 않은 경우엔 링크라 불리는 단계가 추가된다.  

### (4) 링크(Link)
만약 프로그램이 (math.h나 cs50.h와 같은 라이브러리를 포함해) 여러 개의 파일로 이루어져 있어  
<span style="color:blue">하나의 오브젝트 파일로 합쳐져야 한다면 <span style="color:red">링크</span>라는 컴파일의 마지막 단계가 필요로하다.  
링커는 여러 개의 다른 오브젝트 코드 파일을 실행 가능한 하나의 오브젝트 코드 파일로 합쳐준다.  

## 3. 디버깅
### (1) 버그와 디버깅
<span style="color:red">버그(bug)</span>는 <u>코드에 들어있는 오류</u>를 말한다.  
버그로 인해 프로그램의 실행에 실패하거나 프로그래머가 원하는 대로 동작하지 않게 된다.  
<span style="color:red">디버깅(debugging)</span>은 코드에 있는 버그를 식별하고 고치는 과정이다.  

### (2) 디버깅의 기본
디버거는 프로그램을 특정 행에서 멈출 수 있게 해주기 때문에 버그를 찾는데 도움이 된다.  
<u>프로그램이 멈추는 특정 지점</u>을 <span style="color:red">중지점</span>이라고 한다.  
또한 프로그래머가 프로그램을 한번에 한 행씩 실행시킬 수 있도록 해준다.  

## 4. 배열
### (1) 메모리
C에는 여러 자료형이 존재한다. 이 각각의 자료형은 서로 다른 크기의 메로리를 차지한다.  
- bool(불리언): 1바이트
- char(문자): 1바이트
- int(정수): 4바이트
- float(실수): 4바이트
- long(더 큰 정수): 8바이트
- double(더 큰 실수): 8바이트
- string(문자열)

컴퓨터 안에는 아래의 사진과 같은 <span style="color:blue">RAM</span>이라고 하는 물리적 칩이 존재하고 이것이 메모리의 역할을 한다.  
사진에서의 노란색 사각형이 메모리를 의미하고, <span style="color:blue">작은 사각형 하나가 1바이트</span>를 의미한다.  
<img src="https://user-images.githubusercontent.com/87808288/174168735-c1bfc056-46cb-4629-b29f-536daba78e2d.png" width="500">  

### (2) 배열
```c
#include <cs50.h>
#include <stdio.h>

int main(void)
{
    // Scores
    int score1 = 72;
    int score2 = 73;
    int score3 = 33;

    // Print average
    printf("Average: %i\n", (score1 + score2 + score3) / 3);
}
```

위의 코드에서 점수의 개수가 많아진다면 이 프로그램의 많은 부분을 수정해야한다.  
이때 활용할 수 있는 것이 바로 배열의 개념이다.  
배열은 같은 자료형의 데이터를 메모리상에 연이어서 저장하고 이를 하나의 변수로 관리하기 위해 사용된다.  

```c
#include <cs50.h>
#include <stdio.h>

int main(void)
{
    // Scores
    int scores[3];
    scores[0] = 72;
    scores[1] = 73;
    scores[2] = 33;

    // Print average
    printf("Average: %i\n", (scores[0] + scores[1] + scores[2]) / 3);
}
```

<span style="color:green">int scores[3];</span> 이라는 코드는 <span style="color:blue">int 자료형을 가지는 크기 3의 배열을 scores라는 이름으로 생성</span>하겠다는 의미이다.  
배열의 인덱스는 0부터 시작하기 때문에, scores의 인덱스는 0, 1, 2 세 개가 있다.  

따라서 <u>char 자료형을 5개 담을 수 있는 [edwith]라는 이름의 배열</u>을 선언하는 코드는 <span style="color:red">char edwith[5]</span>이다.  

### (3) 전역 변수
아래의 코드에서 scores 배열의 크기를 정해주는 N이라는 변수를 새로 선언하였다.  
만약 N이 고정된 값(상수)이라면 그 값을 선언할 때 const를 앞에 붙여서 전역 변수,  
즉 코드 전반에 거쳐 바뀌지 않는 값임을 지정할 수 있다.  
관례적으로 이런 전역 변수의 이름은 대문자로 표기한다.  

```c
#include <cs50.h>
#include <stdio.h>

const int N = 3;

int main(void)
{
    // 점수 배열 선언 및 값 저장
    int scores[N];
    scores[0] = 72;
    scores[1] = 73;
    scores[2] = 33;

    // 평균 점수 출력
    printf("Average: %i\n", (scores[0] + scores[1] + scores[2]) / N);
}
```

### (4) 배열의 동적 선언 및 저장

```c
#include <cs50.h>
#include <stdio.h>

float average(int length, int array[]);

int main(void)
{
    // 사용자로부터 점수의 갯수 입력
    int n = get_int("Scores:  ");

    // 점수 배열 선언 및 사용자로부터 값 입력
    int scores[n];
    for (int i = 0; i < n; i++)
    {
        scores[i] = get_int("Score %i: ", i + 1);
    }

    // 평균 출력
    printf("Average: %.1f\n", average(n, scores));
}

//평균을 계산하는 함수
float average(int length, int array[])
{
    int sum = 0;
    for (int i = 0; i < length; i++)
    {
        sum += array[i];
    }
    return (float) sum / (float) length;
}
```

위의 코드에서는 배열의 크기를 사용자에게 직접 입력 받고,  
배열의 크기만큼 루프를 돌면서 각 인덱스에 해당하는 값을 역시 사용자에게 동적으로 입력 받아 저장한다.  
그리고 average라는 함수를 따로 선언하여 평균을 구하게 된다.  

### (5) 문자열과 배열
우리가 자연스럽게 사용해던 <span style="color:tomato">문자열(string) 자료형</span>의 데이터는 <span style="color:red">사실 문자(char) 자료형의 데이터</span>들의 <span style="color:red">배열</span>이었다.  
<span style="color:green">string s = "HI!";</span>와 같이 문자열 s가되어 있다고 생각해보자.  
s는 문자의 배열기 때문에 메모리상에 아래와 그림과 같이 저장되고, 이는 인덱스로 각 문자에 접근할 수 있다.  
(문자열: string의 각 문자:char는 <span style="color:tomato">메모리상에 연이어서 저장</span>된다.)  
<img src="https://user-images.githubusercontent.com/87808288/174193484-e18c69c9-c8e9-427e-b97c-ca94f93956fc.png" width="500">  
여기서 <u>가장 끝의 '\0'</u>은 문자열의 끝을 나타내는 `null 종단 문자`이다.  
<span style="color:royalblue">단순히 모든 비트가 0인 1바이트를 의미</span>하는 것이다.  

```c
string names[4];

names[0] = "EMMA";
names[1] = "RODRIGO";
names[2] = "BRIAN";
names[3] = "DAVID";

printf("%s\n", names[0]);
printf("%c%c%c%c\n", names[0][0], names[0][1], names[0][2], names[0][3]);
```

<u>names라는 문자열 형식</u>의 `배열`에 <span style="color:royalblue">네 개의 이름이 저장</span>되어있다.  
첫 번째 printf에서는 names의 첫 번째 인덱스의 값, 즉 "EMMA"를 출력한다.  

두 번째 printf에서는 <u>형식 지정자가 %s가 아닌</u> <span style="color:royalblue">%c</span>로 설정되어 있는 것을 볼 수 있다.  
따라서 출력하는 것은 문자열이 아닌 <span style="color:royalblue">문자</span>가 된다.  
이는 names[0][1]과 같이 2차원 배열을 통해 접근할 수 있다.  
다시 말해 <span style="color:green">namse[0][1]</span>은 <u>names의 첫 번째 값, 즉 "EMMA"라는 문자열</u>에서,  
그 <span style="color:blue">두 번째 값</span>, 즉 '<span style="color:blue">M</span>'이라는 문자를 의미한다.  

아래의 그림에는 names가 실제 메모리상에 저장된 예시이다.  
<img src="https://user-images.githubusercontent.com/87808288/174194403-26a4df10-f6f0-47b4-a37a-adbb22a59780.png" width="600">  
문자열(string)은 포함된 <u>문자(char) 개수 만큼의 메모리 자리</u> + <span style="color:red">null 종단 문자의 메모리 자리</span>가 더해져 자리를 차지한다.  
<u>문자열(string)의 끝</u>에는 <span style="color:red">널(null) 종단 문자</span>가 포함된다.  

## 5. 문자열의 활용
### (1) 문자열의 길이 및 탐색
사용자로부터 문자열을 입력받아 한 글자씩 출력하는 프로그램을 만든다고 한다면,  
간단하게 for문을 통해 문자열의 인덱스를 하나씩 증가시키면서 해당하는 문자를 출력할 수 있다.  

문자열의 끝을 알 수 있는 방법으로는 인덱스 문자의 널 종단 문자, 즉 \0와 일치하는지 검사하는 것이다.  
s라는 문자열이 있다고 할 때 for (int i = 0; s[i] ! = ['\0'; i++) {...}와 같은 루프를 사용하면 된다.  
다른 방법은 아래의 코드와 같이 strlen()이라는 함수를 사용하는 것이다.  

```c
#include <cs50.h>
#include <stdio.h>
#include <string.h>

int main(void)
{
    string s = get_string("Input: ");
    printf("Output:\n");
    for (int i = 0, n = strlen(s); i < n; i++)
    {
        printf("%c\n", s[i]);
    }
}
```

strlen은 문자열의 길이를 알려주는 함수로, string.h 라이브러리 안에 포함되어 있다.  

### (2) 문자열 탐색 및 수정
```c++
#include <cs50.h>
#include <stdio.h>
#include <string.h>

int main(void)
{
    string s = get_string("Before: ");
    printf("After:  ");
    for (int i = 0, n = strlen(s); i < n; i++)
    {
        if (s[i] >= 'a' && s[i] <= 'z')
        {
            printf("%c", s[i] - 32);
        }
        else
        {
            printf("%c", s[i]);
        }
    }
    printf("\n");
}
```

<u>입력받은 문자</u>를 <span style="color:royalblue">s라는 변수에 저장</span>하게 된다.  
그리고 s의 길이만큼 for문을 돌면서 -> 각 인덱스에 해당하는 문자가 <span style="color:royalblue">'a'보다 크고 'z'보다 작은지 검사</span>한다.  
(즉, 소문자인지 검사하는 것)  

알파벳의 대소비교가 가능한 이유는 ASCII값,  
즉 그 문자가 정의되는 ASCII 코드 상에서의 숫자값으로 비교할 수 있기 떄문이다.  
또한 알파벳의 ASCII 값을 살펴보면 각 알파벳의 소문자와 대문자는 32씩 차이가 나는 것을 볼 수 있다.  
따라서 각 문자가 소문자인 경우 그 값에서 32를 뺀 후에 '문자'형태로 출력하면 대문자가 출력된다.  

이와 동일한 작업을 수행하는 함수가 ctype 라이브러리에 toupper()이라는 함수로 정의된다.  

```c++
#include <cs50.h>
#include <ctype.h>
#include <stdio.h>
#include <string.h>

int main(void)
{
    string s = get_string("Before: ");
    printf("After:  ");
    for (int i = 0, n = strlen(s); i < n; i++)
    {
        printf("%c", toupper(s[i]));
    }
    printf("\n");
}
```

## 6. 명령행 인자
main도 그 형태를 보면 하나의 함수임을 알 수 있다.  
main() 안에 void라고 입력하는 대신 아래의 코드와 같이 argc, argv를 정의할 수 있다.  

```c++
#include <cs50.h>
#include <stdio.h>

int main(int argc, string argv[])
{
    if (argc == 2)
    {
        printf("hello, %s\n", argv[1]);
    }
    else
    {
        printf("hello, world\n");
    }
}
```

첫 번째 변수 <span style="color:red">argc</span>는 <u>main 함수가 받게 될 입력의 개수</u>이다.  
그리고 <span style="color:blue">argv[]</span>는 <u>그 입력이 포함되어 있는 배열</u>이다.  
프로그램을 명령행에서 실행하므로, 입력은 문자열로 주어지게 된다.  
따라서 argv[]는 string 배열이 된다.  

<u>argv[0]</u>은 <span style="color:blue">기본적으로 프로그램의 이름으로 저장</span>된다.  
<u>만약 하나의 입력이 더 주어지면</u> <span style="color:royalblue">argv[1]에 저장</span>된다.  
예를 들어 위 프로그램을 "arg.c"라는 이름으로 저장하고 컴파일 한 후 "./argc"로 실행해보면  
"hello, world"라는 값이 출력된다.  
명령행 인자에 주어진 값이 프로그램 이름 하나 밖에 없기 때문이다.  
하지만 "<u>./argc David</u>"로 실행해보면 "hello, David"라는 값이 출력된다.  
명령행 인자에 David라는 값이 추가로 입력되었고,  
따라서 <span style="color:red">argc = 2</span>, argv[1]은 "David"가 되기 때문이다.  

<!-- <span style="color:royalblue"> -->

<!-- ### 2. Link 넣기 

```

유형 1: (설명어를 입력) : [gunhee's coding blog](https://gunhee-jeong.github.io/)
유형 2: (URL 자동연결) : <https://gunhee-jeong.github.io/>
유형 3: (동일 파일 내 '문단으로 이동') : [1. Header로 이동](###-1-header)

```

유형 1: (설명어를 입력) : [gunhee's coding blog](https://gunhee-jeong.github.io/)
유형 2: (URL 자동연결) : <https://gunhee-jeong.github.io/>
유형 3: (동일 파일 내 '문단으로 이동') : [1. Header로 이동](#1-header)
유형 3의 방법

1. 특수문자를 제거
2. 스페이스는 -로 바꾸고
3. 대문자는 소문자로!
   그래서 ### 1. Header -> #1-header

## Link: [google][https://www.google.com/]

### 3. 수평선

```

---

```

---

### 4. 라인 바꾸기

```

스페이스바를 2번 눌러주면 다음칸으로
이동할 수 있어요!

```

---

스페이스바를 2번 눌러주면
다음칸으로 이동할 수 있어요!

### 5. list 만들기

```

1. 1번
2. 2번
3. 3번

- 순서없는 list
  - 순서없는 list
    - 순서없는 list

```

1. 1번
2. 2번
3. 3번

- 순서없는 list
  - 순서없는 list
    - 순서없는 list

---

### 6. font 관련

```

**진하게** -> 볼드
_기울여서_ -> 이탤릭체
~~취소선~~ -> 취소선

<ul>밑줄넣기</ul> -> 밑줄
<span style="color:red">빨간 글씨</span> -> 글자색
이것이 `인라인` 입니다 -> 인라인 코드
```

**진하게** -> 볼드
_기울여서_ -> 이탤릭체
~~취소선~~ -> 취소선
<u>밑줄넣기</u> -> 밑줄
<span style="color:red">빨간 글씨</span>
이것이 `인라인` 입니다 -> 인라인 코드

---

### 7. 인용구문

```
> coding
>
> > JavaScript
> >
> > > 내가 프짱!
```

> coding
>
> > JavaScript
> >
> > > 내가 프짱!

---

### 8. 이미지 삽입

```
유형1: ('사이즈를 조절' -> HTML 태그 사용) : <img src="https://gunhee-jeong.github.io/assets/images/blogLogo.png" width="500" height="200">
유형2: (이미지 삽입 후 -> 링크 걸기)
[![이미지](https://gunhee-jeong.github.io/assets/images/blogLogo/blogLogo.png)](https://gunhee-jeong.github.io/)
```
### 9. 표 만들기

```
||국어|영어|
| :--- | ---: | :--: |
|건희 | 100점 | 100점
|철수 | 100점 | 100점
```

|      |  국어 | 영어  |
| :--- | ----: | :---: |
| 건희 | 100점 | 100점 |
| 철수 | 100점 | 100점 |

> - header를 넣고 싶은 경우 ---을 사용하고 :을 이용하여 정렬에 사용함!

### 10. 토글 만들기

```
<details>
<summary>여기를 누르세요</summary>
<div markdown="1">
숨겨진 내용
</div>
</details>
```

<details>
<summary>여기를 누르세요</summary>
<div markdown="1">
숨겨진 내용
</div>
</details> -->
