---
layout: single
title: "모두를 위한 컴퓨터 과학 -> Array"
# categories: Git
categories:
  - CS # HTML CSS JavaScript Server Algorithm Wecodes Programmers CS Github Blog
tag: [모두를 위한 컴퓨터 과학] #tag는 여러개 가능함
toc: true #table of content 기능!
toc_sticky: true
author_profile: true #blog 글안에서는 author_profile이 따라다니지 않도록 설정함
date: 2022-06-16T16:20:00+09:00
# sidebar:
# nav: "docs" #네비게이션에 있는 docs를 의미함
---
# 3장 Array
## 1. 컴파일링
```c
#include <stdio.h>
```
위의 코드는 <span style="color:red">시작한다는 의미</span>를 가지며 꼭 추가되어야 한다.  
정확히 말하면 stdio.h는 헤더 파일로 C언어로 작성되어 있으며 파일명이 .h로 끝나는 파일이다.  
(printf 함수를 사용하기 위해서는 stdio.h 라이브러리를 필요로 한다.)  
<u>이 파일에는</u> <span style="color:royalblue">printf 함수의 프로토타입이</span> 있어서 Clang 컴파일러가 프로그램을 컴파일할 때  
printf가 무엇인지 알려주는 역할을 하게 된다.  

```c
#include <stdio.h> //-> '시작한다'는 의미를 가지고 있다.  

int main(void)
{
  printf("hello, world"); //이 코드의 핵심적인 내용
}
```  

위의 코드를 좀더 자세히 들여다보자면,  
우선 <u>main이라는 함수</u>가 있는 것이다. 프로그램의 시작점으로 실행 버튼을 클릭하는 것과 같다.  

### (1) clang  
'<span style="color:red">clang</span>'은 코드를 컴파일하는 프로그램의 이름으로, clang을 통해서 소스코드를 <span style="color:blue">머신코드로 번역</span>할 수 있다.   
```bash
clang hello.c
```
위의 명령어를 터미널에서 입력하는 순간 <u>a.out이라는 파일이 생성</u>된다.  
(파일 종류 -> <u>hello.c</u>, <u>a.out</u>)  
이 `a.out`에는 바로 `머신코드`가 들어있다.  
(<u>'hello.c'</u>라는 파일을 `clang hello.c`를 통해서 <span style="color:blue">a.out</span>이라는 <span style="color:red">머신코드</span>로 변환한다.)   

### ./  

```bash
./a.out
```  
위의 명령어는 컴퓨터가 현재 디렉토리에 있는 <u>a.out이라는 프로그램을 실행</u>하도록 한다.  
<u>'.'은 현재의 위치</u>를 나타내고,  
'/a.out'은 이 디렉토리에서 a.out이라는 <span style="color:royalblue">파일을 실행하라는 것</span>을 의미한다.  
결과적으로 아래의 결과를 출력한다.  
```bash
hello world$
```
그런데 여기서 $가 나오는 것은 프롬프트에 불과하지만, 우리는 <u>'hello world'라는 결과를 원한 것</u>이지  
'hello world$'라는 결과를 원한 것이 아니다.  
따라서 우리는 $가 뒤에 붙지 않도록 줄바꿈을 해주어야하고

```c
#include <stdio.h>

int main(void)
{
  printf("hello, world\n"); //이 코드의 핵심적인 내용
}
```
이렇게 printf("hello, world<span style="color:red">\n</span>")라는 것을 사용해서 <u>컴퓨터로 하여금 줄을 바꾸도록 설정</u>해야한다.  

하지만 여기서도 바로 "./a.out" 명령어를 터미널에서 입력한다고해서 -> 우리가 원하는 결과를 얻지 못한다.  
<span style="color:blue">바로 컴파일을 하지 않았기 때문</span>이다!  
```c
clang hello.c
./a.out
```
따라서 우리는 위와 같은 순서로 접근해야한다.  

### clang -o  
코드를 <span style="color:green">clang hello.c</span>로 컴파일하고 <span style="color:green">./a.out</span> 명령으로 프로그램을 실행할 때 이 과정은  
<u>컴퓨터가 이해하는 0과 1로 가득찬 파일</u> <span style="color:royalblue">a.out을 생성</span>하여 실행 가능하도록 한다.  
만약 <span style="color:blue">a.out과 다른 이름(hello)으로 컴파일을 하고 싶다면</span> 아래와 같은 명령행 인자를 추가하게 된다.  

```c
clang -o hello hello.c
```

(파일 종류 -> <span style="color:green">a.out</span>, <span style="color:green">hello.c</span>, <span style="color:green">hello</span>)  
<span style="color:purple">clang -o hello</span>를 통해서 <span style="color:green">hello.c</span>라는 `소스코드 파일`을 -> <span style="color:green">hello</span>라는 `머신코드 파일`로 만들었다.  
이렇게 a.out 파일과 같은 내용을 담은 hello 파일이 생성되었다.  
`clang -0`를 통해서 <span style="color:blue">생성되는 파일명을 지정</span>하게 되는 것이다.  

```c
./hello
```

위와 같이 실행하면 a.out 파일을 실행했을 때와 같은 결과를 보여준다!   

### clang -0 -l
```bash
clang -o hello hello.c -lcs50
```

위의 코드는 <span style="color:royalblue">clang에게 cs50 라이브러리에 있는 모든 0과 1들을 여기에 연결하라</span>는 의미이다.  
간단하게는, make 프로그램을 이용하면 이 모든 컴파일 과정을 자동으로 처리할 수 있었다.  
이렇게 make나 clang을 사용해서 프로그램을 실행할 때 아래의 네 단계를 거치게 된다.  
<span style="color:red">전처리</span> -> <span style="color:red">컴파일링</span> -> <span style="color:red">어셈블링</span> -> <span style="color:red">링킹</span>  

## 2. 컴파일
```c
#include <stdio.h>

int main(void)
{
  printf("hello, world\n"); //이 코드의 핵심적인 내용
}
```

### (1) 전처리(Precompile)
첫 번째 단계가 바로 <span style="color:red">전처리</span>이다.  
<u>#으로 시작되는 C 소스 코드</u>는 전처리기에게 <span style="color:royalblue">실질적인 컴파일이 이루어지기 전</span>에 <span style="color:blue">무언가를 실행하라고 알려준다</span>.  

예를 들어, `#include`는 <span style="color:royalblue">전처리기에게 다른 파일의 내용을 포함시키라고 알려</span>준다.  
프로그램의 소스 코드에 #include와 같은 줄을 포함하면 ->  
<span style="color:royalblue">전처리기는 새로운 파일을 생성</span>하는데  
이 파일은 여전히 C 소스 코드 형태이며 <span style="color:blue">stdio.h 파일의 내용이 #include 부분에 포함</span>된다.  

### (2) 컴파일(Compile)
전처리기가 전처리한 소스 코드를 생성하고 나면 그 다음 단계는 <span style="color:red">컴파일</span>이다.  
<span style="color:red">컴파일러</span>라고 불리는 프로그램은 <u>C 코드를</u> <span style="color:blue">어셈블리어</span>라는 저수준 프로그래밍 언어로 컴파일한다.  

어셈블리는 C보다 연산의 종류가 훨씬 적지만,  
여러 연산들이 함께 사용되면 C에서 할 수 있는 모든 것을 수행할 수 있게 된다.  
C코드를 어셈블리 코드로 변환시켜줌으로써  
컴파일러는 <span style="color:royalblue">컴퓨터가 이해할 수 있는 언어와 최대한 가까운 프로그래밍으로 만들어</span> 준다.  
컴파일이라는 용어는 소스 코드에서 오브젝트 코드로 변환하는 전체 과정을 통틀어 일컫기도 하지만,  
구체적으로 전처리한 소스 코드를 어셈블리 코드로 변환시키는 단계를 말하기도 한다.  

### (3) 어셈블(Assemble)
<u>소스 코드</u>가 <span style="color:royalblue">어셈블리 코드</span>로 변환되면, 다음 단계인 <span style="color:red">어셈블 단계</span>로 <u>어셈블리 코드를 오브젝트 코드로 변환</u>시키는 것이다.  
<span style="color:royalblue">컴퓨터의 중앙처리장치가 프로그램을 어떻게 수행해야 하는지 알 수 있는 명령어 형태</span>인  
<span style="color:blue">연속된 0과 1들로 바꿔주는 작업</span>인 것이다. 이 변환 작업을 어셈블리라는 프로그램이 수행하게 된다.  
소스 코드에서 오브젝트 코드로 컴파일 되어야 할 파일이 딱 한 개라면,  
컴파일 작업은 여기서 끝나지만, 그러지 않은 경우엔 링크라 불리는 단계가 추가된다.  

### (4) 링크(Link)
만약 프로그램이 (math.h나 cs50.h와 같은 라이브러리를 포함해) 여러 개의 파일로 이루어져 있어  
<span style="color:blue">하나의 오브젝트 파일로 합쳐져야 한다면 <span style="color:red">링크</span>라는 컴파일의 마지막 단계가 필요로하다.  
링커는 여러 개의 다른 오브젝트 코드 파일을 실행 가능한 하나의 오브젝트 코드 파일로 합쳐준다.  

## 3. 디버깅
### (1) 버그와 디버깅
<span style="color:red">버그(bug)</span>는 코드에 들어있는 오류를 말한다.  
버그로 인해 프로그램의 실행에 실패하거나 프로그래머가 원하는 대로 동작하지 않게 된다.  
<span style="color:red">디버깅(debugging)</span>은 코드에 있는 버그를 식별하고 고치는 과정이다.  

### (2) 디버깅의 기본
디버거는 프로그램을 특정 행에서 멈출 수 있게 해주기 때문에 버그를 찾는데 도움이 된다.  
<u>프로그램이 멈추는 특정 지점</u>을 <span style="color:red">중지점</span>이라고 한다.  
또한 프로그래머가 프로그램을 한번에 한 행씩 실행시킬 수 있도록 해준다.  

<!-- <span style="color:royalblue"> -->

<!-- ### 2. Link 넣기 

```

유형 1: (설명어를 입력) : [gunhee's coding blog](https://gunhee-jeong.github.io/)
유형 2: (URL 자동연결) : <https://gunhee-jeong.github.io/>
유형 3: (동일 파일 내 '문단으로 이동') : [1. Header로 이동](###-1-header)

```

유형 1: (설명어를 입력) : [gunhee's coding blog](https://gunhee-jeong.github.io/)
유형 2: (URL 자동연결) : <https://gunhee-jeong.github.io/>
유형 3: (동일 파일 내 '문단으로 이동') : [1. Header로 이동](#1-header)
유형 3의 방법

1. 특수문자를 제거
2. 스페이스는 -로 바꾸고
3. 대문자는 소문자로!
   그래서 ### 1. Header -> #1-header

## Link: [google][https://www.google.com/]

### 3. 수평선

```

---

```

---

### 4. 라인 바꾸기

```

스페이스바를 2번 눌러주면 다음칸으로
이동할 수 있어요!

```

---

스페이스바를 2번 눌러주면
다음칸으로 이동할 수 있어요!

### 5. list 만들기

```

1. 1번
2. 2번
3. 3번

- 순서없는 list
  - 순서없는 list
    - 순서없는 list

```

1. 1번
2. 2번
3. 3번

- 순서없는 list
  - 순서없는 list
    - 순서없는 list

---

### 6. font 관련

```

**진하게** -> 볼드
_기울여서_ -> 이탤릭체
~~취소선~~ -> 취소선

<ul>밑줄넣기</ul> -> 밑줄
<span style="color:red">빨간 글씨</span> -> 글자색
이것이 `인라인` 입니다 -> 인라인 코드
```

**진하게** -> 볼드
_기울여서_ -> 이탤릭체
~~취소선~~ -> 취소선
<u>밑줄넣기</u> -> 밑줄
<span style="color:red">빨간 글씨</span>
이것이 `인라인` 입니다 -> 인라인 코드

---

### 7. 인용구문

```
> coding
>
> > JavaScript
> >
> > > 내가 프짱!
```

> coding
>
> > JavaScript
> >
> > > 내가 프짱!

---

### 8. 이미지 삽입

```
유형1: ('사이즈를 조절' -> HTML 태그 사용) : <img src="https://gunhee-jeong.github.io/assets/images/blogLogo.png" width="500" height="200">
유형2: (이미지 삽입 후 -> 링크 걸기)
[![이미지](https://gunhee-jeong.github.io/assets/images/blogLogo/blogLogo.png)](https://gunhee-jeong.github.io/)
```
### 9. 표 만들기

```
||국어|영어|
| :--- | ---: | :--: |
|건희 | 100점 | 100점
|철수 | 100점 | 100점
```

|      |  국어 | 영어  |
| :--- | ----: | :---: |
| 건희 | 100점 | 100점 |
| 철수 | 100점 | 100점 |

> - header를 넣고 싶은 경우 ---을 사용하고 :을 이용하여 정렬에 사용함!

### 10. 토글 만들기

```
<details>
<summary>여기를 누르세요</summary>
<div markdown="1">
숨겨진 내용
</div>
</details>
```

<details>
<summary>여기를 누르세요</summary>
<div markdown="1">
숨겨진 내용
</div>
</details> -->
