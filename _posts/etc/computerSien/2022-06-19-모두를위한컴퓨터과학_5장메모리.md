---
layout: single
title: "모두를 위한 컴퓨터 과학 -> 5장 메모리"
# categories: Git
categories:
  - CS # HTML CSS JavaScript Server Algorithm Wecodes Programmers CS Github Blog
tag: [모두를 위한 컴퓨터 과학] #tag는 여러개 가능함
toc: true #table of content 기능!
toc_sticky: true
author_profile: true #blog 글안에서는 author_profile이 따라다니지 않도록 설정함
date: 2022-06-19T20:00:00+09:00
# sidebar:
# nav: "docs" #네비게이션에 있는 docs를 의미함
---
# 5장 메모리
## 1. 메모리 주소
### (1) 16진수
컴퓨터 과학에서는 숫자를 10진수, 2진수 그리고 <span style="color:red">16진수(Hexadecimal)</span>로 표현하는 경우가 많다.  
16진수를 사용하면 10진수보다 2진수를 간단하게 나타낼 수 있다.  

### (2) 10진수를 16진수로 바꾸기  
JPG 이미지 파일은 항상 255 216 255로 시작되고 이것은 10진수이다.  
하지만 실제 컴퓨터 내에서는 10진수를 사용하지 않는다.  
컴퓨터는 0과 1만을 이해할 수 있기 때문이다.  
<img src="https://user-images.githubusercontent.com/87808288/174478652-78815374-8d86-4ea2-b7f4-2c3e633842c2.png" width="500">  

255 216 255를 2진수로 나타내보면 위의 그림과 같다.  
16진수에서는 10을 a, 11은 b, ...15는 f를 대입하여 사용하게 된다.  
4bits씩 16진수로 변환한 후 <span style="color:red">Ox</span>를 붙여 뒤에 오는 문자들이 16진수임을 알려준다.  

### (3) 16진수의 유용성
ASCII 코드에 의해 “A, B, C”는 10진수로 65, 66, 67에 해당한다.  
컴퓨터는 10진수를 이해할 수 없으므로 2진수로 표현해보면  "01000001 01000010 01000011＂이다.  
<u>컴퓨터가 처리할 수 있어야 하기 때문에 어쩔 수 없지만</u> <span style="color:royalblue">그 길이가 너무 긴 것을 알 수</span> 있습니다.  

하지만 16진수로 표현하면 2진수로 표현했을 때보다 훨씬 간단해진다.  
컴퓨터는 8개의 비트가 모인 바이트 단위로 정보를 표현한다.  
2개의 16진수는 1byte의 2진수로 변환되기 때문에 정보를 표현하기 매우 유용하다.  
<img src="https://user-images.githubusercontent.com/87808288/174478889-e8db43cd-63c0-495a-97ac-54ca27ab7a46.png" width="500">  

### (4) 메모리 주소
정수형 변수 n에 50이라는 값을 저장하고 출력해보면  
n이라는 값은 int 타입이므로, 아래의 그림과 같이 컴퓨터의 메모리 어딘가에 4바이트 만큼의 자리를 차지하며 저장된다.  
<img src="https://user-images.githubusercontent.com/87808288/174478991-6513ca94-89c5-4e0e-9c90-77f8a398629e.png" width="400">  

c에서는 <u>변수의 메모리상 주소</u>를 받기 위해 <span style="color:blue">'&'이라는 연산자</span>를 사용할 수 있다.  
아래와 같은 코드를 실행하면 ‘<u>0x7ffe00b3adbc</u>’와 같은 값을 얻을 수 있고,  
이는 변수 n의  16진법으로 표현된 메모리의 주소입니다.  

```c++
#include <stdio.h>

int main(void)
{
    int n = 50;
    printf("%p\n", &n);
}
```

반대로 '`*`'를 사용하면 그 <span style="color:blue">메모리 주소에 있는 실제 값을</span> 얻을 수 있다.  
아래의 코드는 먼저 n의 주소를 얻고, 다시 그 주소에 해당하는 값을 얻어와 출력한 것이므로  
결국 "50"이라는 값이 출력된다.  
<span style="color:green">printf("%i\n", *&n);</span>에서 <span style="color:red">*&n</span>가 나타내는 <span style="color:tomato">값은 50</span>인 것이다.  

```c++
#include <stdio.h>

int main(void)
{
    int n = 50;
    printf("%i\n", *&n);
}
```

## 2. 포인터
*연산자를 사용하여 포인터 역할을 하는 변수를 선언할 수 있다.  

```c++
#include <stdio.h>

int main(void)
{
   int n = 50;
   int *p = &n;
   printf("%p\n", p);
   printf("%i\n", *p);
}
```

위 코드를 살펴보면 정수형 변수 <u>n에는 50이라는 값이</u> 저장되어있다.  
`*p`라는 포인터 변수에 <u>&n 이라는 값</u> == <span style="color:royalblue">변수 n의 주소</span>를 저장한다.  
int <span style="color:blue">*</span>p에서 p앞의 <u>*는 이 변수가 포인터라는 의미</u>이고,  
<span style="color:blue">int</span>는 <u>이 포인터가 int 타입의 변수를 가리킨다는 의미</u>이다.  

따라서 `첫 번째 printf문`과 같이 포인터 <span style="color:tomato">p의 값</span>, 즉 <span style="color:red">변수 n의 주소</span>를 출력하거나,  
`두 번째 printf문`과 같이 포인터 <span style="color:tomato">p가 가리키는 변수의 값</span>, 즉 <span style="color:red">변수 n의 값</span>을 출력할 수도 있다.  
(변수 *p에는 n의 주소값을 값으로 가지고 있고, 따라서 *p는 n을 가리키고 있는 포인터이므로  
*p의 값은 결과적으로 변수 n의 값인 50을 나타낸다.)  

실제 컴퓨터 메모리에서 변수 p는 아래와 같이 저장될 수 있다.  
<img src="https://user-images.githubusercontent.com/87808288/174481375-4f59558f-7229-477a-8b6d-f52df05205f7.png" width="500">  

하지만 아래 그림과 같이 실제로 p의 값, 즉 n의 주소값을 생각하지 않고,  
추상적으로 단지 p가 n을 가리키고 있다는 것만 생각해도 된다.  
<img src="https://user-images.githubusercontent.com/87808288/174481412-c95facd4-185e-4671-b5ef-9914532acd98.png" width="500">  

## 3. 문자열
<u>"EMMA"와 같은 문자열</u>을 저장하기 위해서 <span style="color:royalblue">string 이라는 자료형</span>을 사용했다.  
하지만 이는 실제로 <span style="color:blue">C에서는 존재하지 않는 자료형</span>이다.  

`문자열`은 결국 <span style="color:blue">문자의 배열</span>이고, s[0], s[1], s[2]...와 같이 하나의 문자가 배열의 한 부분을 나타낸다.  
가장 마지막은 `\0`으로 이루어진 바이트로, <span style="color:blue">문자열의 끝을 표시하는 약속</span>이다.  
<img src="https://user-images.githubusercontent.com/87808288/174503193-a8fa5bfe-483f-4682-84ff-a52bd9351268.png" width="400">  

여기서 `변수 s`는 결국 이러한 <span style="color:blue">문자열을 가리키는 포인터</span>가 되는 것이다.  
더 상세하게는 문자열의 가장 첫 번째 문자, <u>즉 주소 Ox123</u>에 있는 <span style="color:royalblue">s[0]</span>을 가리키게 된다.  
<img src="https://user-images.githubusercontent.com/87808288/174503264-773fda82-8842-4910-b169-9a19b4d12f1e.png" width="450">  

```c++
typedef char *string
```

실제 CS50 라이브러리를 보면 string 자료형은 위와 같이 정의되어있다.  
따라서 아래의 두 개의 코드는 동일하게 동작한다.  

```c++
#include <cs50.h>
#include <stdio.h>

int main(void)
{
    string s = "EMMA";
    printf("%s\n", s);
}
```

```c++
#include <stdio.h>

int main(void)
{
    char *s = "EMMA";
    printf("%s\n", s);
}
```

위의 코드의 `char *s`에서 <u>s라는 변수</u>는 <span style="color:blue">문자에 대한 포인터</span>가 되고,  
"EMMA"라는 문자열의 가장 첫 번째 값을 저장하기 때문이다.  
<span style="color:red">string s</span> 와 <span style="color:red">char *s</span>는 <span style="color:tomato">동일한 의미</span>를 가지는 것이다.  

## 4. 문자열의 비교
```c++
#include <stdio.h>

int main(void)
{
    char *s = "EMMA";
    printf("%p\n", s);
}
```

위의 코드를 실행하면, <u>s라는 포인터의 값</u>,  
즉 "EMMA"라는 문자열의 <span style="color:blue">가장 첫 값인 "E"에 해당하는 메모리 출력를 출력</span>한다.  

```c++
printf("%p\n", &s[0]);
printf("%p\n", &s[1]);
printf("%p\n", &s[2]);
printf("%p\n", &s[3]);
```

s가 가리키는 곳을 시작으로 “EMMA”라는 문자열로 이루어진 문자들의 배열이 있으니, 각각  
s라는 문자열의 <span style="color:red">첫 번째 문자에 해당하는 주소값</span>,  
s라는 문자열의 <span style="color:red">두 번째 문자에 해당하는 주소값</span>,  
s라는 문자열의 <span style="color:red">세 번째 문자에 해당하는 주소값</span>,  
s라는 문자열의 <span style="color:red">네 번째 문자에 해당하는 주소값</span>을 출력하게 된다.  

좀 더 자세히 살펴보면,  
<u>&s[0]</u>는 <span style="color:royalblue">"E"의 주소값</span>을, <u>&s[1]</u>은 <span style="color:royalblue">"M"의 주소값</span>을 &s[3]은 "A"의 주소값을 의미한다.  
<u>문자열</u>은 <span style="color:royalblue">첫 번째 문자를 시작으로 메모리상에서 바로 옆에 저장</span>되어있다.  
다시 말하면, 가장 첫 번째 문자에 해당하는 주소값을 하나씩 증가시키면 바로 옆에 있는 문자의 값을 출력한다는 것이다.  
따라서 아래의 코드의 결과로는 E M M A를 순서대로 출력하게 된다.  

```c++
printf("%c\n", *s);
printf("%c\n", *(s+1));
printf("%c\n", *(s+2));
printf("%c\n", *(s+3));
```

<u>문자열을 비교할 때도</u> 아래 코드와 같이 문자열이 저장된 변수를 바로 비교하게 되면  
그 변수가 저장되어 있는 <span style="color:blue">주소가 다르기 때문에 다르다는 결과가 출력</span>된다.  
정확한 비교를 위해서는 실제 문자열이 저장되어 있는 곳으로 이동하여, 각 문자를 하나씩 비교해야 한다.  

```c++
#include <cs50.h>
#include <stdio.h>

int main(void)
{
    // 사용자로부터 s와 t 두 개의 문자열 입력받아 저장
    string s = get_string("s: ");
    string t = get_string("t: ");

    // 두 문자열을 비교 (각 문자들을 비교)
    if (s == t)
    {
        printf("Same\n");
    }
    else
    {
        printf("Different\n");
    }
}
```

## 5. 문자열 복사
문자열을 복사하기 위해 아래의 코드를 실행할 수 있다.  

```c++
#include <cs50.h>
#include <ctype.h>
#include <stdio.h>

int main(void)
{
    string s = get_string("s: ");
    string t = s;

    t[0] = toupper(t[0]);

    printf("s: %s\n", s);
    printf("t: %s\n", t);
}
```

위의 코드를 사용하여 입력값으로 "emma"를 주면 -> 예상과는 다르게 s와 t는 모두 "Emma"를 출력한다.  
그 이유는 `s라는 변수`에는 <u>"emma"라는 문자열이 아닌</u> <span style="color:blue">그 문자열이 있는 메모리의 주소가 저장</span>되기 때문이다.  
(string s는 <span style="color:royalblue">char *s</span>와 동일하기 때문이다.)  
따라서 <u>t도 s와 동일한 주소를</u> 가리키고 있고,  
t를 통한 수정은 s에도 그대로 반영되기 때문이다.  

따라서 실제로 메모리상에 복사를 하려면 아래와 같이 메모리 할당 함수를 사용하면 된다.  

```c++
#include <cs50.h>
#include <ctype.h>
#include <stdio.h>
#include <string.h>

int main(void)
{
    char *s = get_string("s: ");
    char *t = malloc(strlen(s) + 1);

    for (int i = 0, n = strlen(s); i < n + 1; i++)
    {
        t[i] = s[i];
    }

    t[0] = toupper(t[0]);

    printf("s: %s\n", s);
    printf("t: %s\n", t);
}
```

위의 코드가 먼저 코드와 다른 점은 `malloc`라는 함수를 이용해서 t를 정의한다는 것이다.  
<span style="color:tomato">malloc</span>라는 함수는 <span style="color:blue">정해진 크기 만큼 메모리를 할당하는 함수</span>이다.  

<u>s 문자열의 길이에</u> <span style="color:red">널 종단 문자(\0)에 해당하는 1을 더한 만큼 메모리를 할당</span>한다.  
그리고 루프를 돌면서 s 문자열 배열에 있는 문자 하나 하나를 t 배열에 복사하면 된다.  
이렇게 하면 컴파일 후 실행하여 "emma"를 주면  
우리가 생각한대로 s는 "emma"를, t는 "Emma"를 출력한다.  

## 6. 메모리 할당과 해제
malloc 함수를 이용하여 메모리를 할당한 후에는 <span style="color:red">free라는 함수</span>를 이용하여 <span style="color:tomato">메모리를 해제</span>해야한다.  
그렇지 않을 경우 메모리에 저장한 값은 쓰레기 값으로 남게 되어 메모리 용량의 낭비가 발생하기 때문이다.  
이러한 현상을 "메모리 누수"라고 한다.  

```c++
help50 valgrind ./filename
```

위의 코드처럼 valgrind 라는 프로그램을 사용하면 우리가 작성한 코드에서 메모리와 관련된 문제가 있는지 확인할 수 있다.  
아래와 같은 코드가 있다고 생각해보자.  

```c++
#include <stdlib.h>

void f(void)
{
    int *x = malloc(10 * sizeof(int));
    x[10] = 0;
}

int main(void)
{
    f();
    return 0;
}
```

`f 함수`를 살펴보면 <u>포인터 x</u>에는 <span style="color:royalblue">int형의 사이즈(4바이트)에 10배</span>에 해당하는 크기의 메모리, 즉 <span style="color:royalblue">40바이트를 할당</span>한다.  
그리고 x의 10번째 값으로 0을 할당한다.  

main 함수에서 f를 실행하는데, 이 코드를 valgrind로 검사해보면  
<span style="color:blue">버퍼 오버플로우</span>와 <span style="color:blue">메모리 누수</span> 두 가지 에러를 확인할 수 있다.  

먼저 버퍼 오버플로우는 <span style="color:green">x[10] = 0;</span> 코드로 인해 발생한다.  
우리는 <span style="color:blue">10개의 int형의 배열</span>을 만들었는데 배열의 인덱스가 0부터 시작한다는 점을 감안하면  
<u>인덱스 10은 11번째 인덱스에 접근하겠다는 의미</u>이고, 이는 정의되지 않은 것이기 때문에 오버플로우가 발생한다.  
따라서 이 오류는 0에서 9 사이의 인덱스를 사용하면 해결된다.  

또한 <span style="color:blue">메모리 누수</span>는 x라는 포인터를 통해 할당한 메모리를 해제하기 위해 <span style="color:green">free(x)</span>라는 코드를 추가하여 해결할 수 있다.  

## 7. 메모리 교환, 스택, 힙
```c++
#include <stdio.h>

void swap(int a, int b);

int main(void)
{
    int x = 1;
    int y = 2;

    printf("x is %i, y is %i\n", x, y);
    swap(x, y);
    printf("x is %i, y is %i\n", x, y);
}

void swap(int a, int b)
{
    int tmp = a;
    a = b;
    b = tmp;
}
```

위의 코드에서 함수 swap은 정수 a와 b를 입력받아 그 값을 바꾸는 일을 수행한다.  
main 함수에서는 x에 1, y에 2를 입력하고 swap 함수를 통해 두 값을 바꾸려고 한다.  

위 코드를 컴파일하고 출력해보면 우리의 의도와는 다르게 swap 함수를 거친 후에도 x와 y의 값은 바뀌지 않는다.  
swap 함수 자체는 교환 작업을 정상적으로 수행하였다.  
문제는 교환하는 대상이 x, y 그 자체가 아닌 함수 내에서 새롭게 정의된 a, b라는 것이다.  
a와 b는 각각 x와 y의 값을 복제하여 가지게 된다.  
서로 다른 메모리 주소에 저장되는 것이다.  

아래의 그림과 같이 메모리 안에는 데이터가 저장되는 구역이 나누어져 존재한다.  
<span style="color:blue">머신 코드 영역</span>에는 <u>우리 프로그램이 실행될 때</u> <span style="color:royalblue">그 프로그램이 컴파일된 바이너리가 저장</span>된다.  
<span style="color:blue">글로벌 영역</span>에는 프로그램 안에서 저장된 <span style="color:royalblue">전역 변수가 저장</span>된다.  
<span style="color:red">힙 영역</span>에서는 <span style="color:tomato">malloc으로 할당된 메모리의 데이터가 저장</span>된다.  
그리고 <span style="color:blue">스택</span>에는 <span style="color:royalblue">프로그램 내의 함수와 관련된 것들이 저장</span>된다.  

힙 영역에서는 malloc 에 의해 메모리가 더 할당될수록 -> 점점 사용하는 메모리의 범위가 아래로 늘어나게 된다.  
마찬가지로 스택 영역에서도 함수가 더 많이 호출되수록 사용하는 메모리의 범위가 점점 위로 늘어난다.  
이렇게 늘어나다 보면, 제한된 메모리 용량 하에서는 기존의 값을 침범하는 상황이 벌어지는데  
이를 `힙 오버플로우` 또는 `스택 오버플로우`라고 한다.  
<img src="https://user-images.githubusercontent.com/87808288/174534099-3d4e7a3a-3337-420e-b40e-e6621eee9926.png" width="250">  

위의 개념으로 다시 생각해보면,  
위의 코드 a, b, x, y, tmp 모두 스택 영역에 저장되지만  
a와 x, b와 y는 그 안에서도 서로 다른 위치에 저장된 변수인 것이다.  
따라서 a와 b를 바꾸는 것은 x와 y를 바꾸는 것에 아무런 영향도 미치지 못한 것이다.  

그러므로 아래 그림 및 코드와 같이 a와 b를 각각 x와 y를 가리키는 포인터로 지정함으로써  
이 문제를 해결할 수 있다.  
<img src="https://user-images.githubusercontent.com/87808288/174534500-0c1109df-35c2-4494-8be3-860988237d0c.png" width="250">   

```c++
#include <stdio.h>

void swap(int *a, int *b);

int main(void)
{
    int x = 1;
    int y = 2;

    printf("x is %i, y is %i\n", x, y);
    swap(&x, &y);
    printf("x is %i, y is %i\n", x, y);
}

void swap(int *a, int *b)
{
    int tmp = *a;
    *a = *b;
    *b = tmp;
}
```

## 8. 파일 쓰기
### (1) 사용자에게 입력 받기
스택은 우리가 많이 사용했던 get_int나 get_string 과 같은 함수에서도 사용된다.  
이것을 직접 구현한다면 아래와 같은 코드이다.  

```c++
// get_int 코드
#include <stdio.h>

int main(void)
{
    int x;
    printf("x: ");
    scanf("%i", &x);
    printf("x: %i\n", x);
}
```

```c++
// get_string 코드
#include <stdio.h>

int main(void)
{
    char s[5];
    printf("s: ");
    scanf("%s", s);
    printf("s: %s\n", s);
}
```

위의 코드에서 scanf 라는 함수는 사용자로부터 형식 지정자에 해당되는 값을 입력받아 저장하는 함수이다.  

get_int 코드에서 int x 를 정의한 후에 <u>scanf에 x가 아닌</u> <span style="color:blue">&x 로 그 주소를 입력</span>해주는 부분에 유의해야 한다.  
scanf 함수의 변수가 실제로 <span style="color:royalblue">스택 영역 안에 x가 저장된 주소로 찾아가서</span> 사용자가 입력한 값을 저장하도록 하기 위함이다.  

반면 get_string 코드에서는 <u>scanf에 그대로 s를 입력</u>한다.  
그 이유는 <span style="color:blue">s를 크기가 5인 문자열, 즉 크기가 5인 char 자료형의 배열로 정의</span>하였기 때문이다.  
clang 컴파일러는 문자 배열의 이름을 포인터처럼 다룬다.  
즉 scanf에 s라는 배열의 첫 바이트 주소를 넘겨준다.  

### (2) 파일 쓰기
```c++
#include <cs50.h>
#include <stdio.h>
#include <string.h>

int main(void)
{
    FILE *file = fopen("phonebook.csv", "a");
    char *name = get_string("Name: ");
    char *number = get_string("Number: ");
    fprintf(file, "%s,%s\n", name, number);
    fclose(file);
}
```

<span style="color:red">fopen</span> 이라는 함수를 이용하면 파일을 FILE 이라는 자료형으로 불러올 수 있다.  
fopen 함수의 첫 번째 인자는 파일의 이름, 두 번째 인자는 모드로 r은 읽기, w는 쓰기,  
a는 덧붙이기를 의미한다.  

사용자에게 name과 number라는 문자열을 입력 받고, 이를 <span style="color:red">fprintf</span> 함수를 이용하여 printf 에서 처럼  
파일에 직접 내용을 출력할 수 있다.  
작업이 끝난 후에는 <span style="color:red">fclose</span> 함수로 파일에 대한 작업을 종료해야 한다.  

## 9. 파일 읽기
```c++
#include <stdio.h>

int main(int argc, char *argv[])
{
    if (argc != 2)
    {
        return 1;
    }

    FILE *file = fopen(argv[1], "r");

    if (file == NULL)
    {
        return 1;
    }
 
   unsigned char bytes[3];
    fread(bytes, 3, 1, file);

    if (bytes[0] == 0xff && bytes[1] == 0xd8 && bytes[2] == 0xff)
    {
        printf("Maybe\n");
    }
    else
    {
        printf("No\n");
    }
    fclose(file);
}
```

위의 코드는 파일의 내용을 읽어서 파일의 형식이 JPEG 이미지인지를 검사하는 프로그램이다.  

코드에서 main 함수를 보면 사용자로부터 입력을 받는 다는 것을 알 수 있다.  

만약 argc가 2가 아니라면, 파일명이 입력되지 않았거나 파일명 외에 다른 인자가 입력되었기 때문에  
1(오류)를 리턴하고 프로그램을 종료한다.  
만약 argc가 2라면 프로그램이 그대로 진행하게 된다.  

입력받은 파일명(argc[1])을 '읽기(r)' 모드로 불러온다.  
만약 파일이 제대로 열리지 않으면 fopen 함수는 NULL을 리턴하기 때문에  
이를 검사해서 file을 제대로 쓸 수 있는지를 검사하고, 아니라면 역시 1(오류)를 리턴하고 프로그램을 종료한다.  

만약 파일이 잘 열렸다면, 프로그램이 계속 진행된다.  
그 후 크기가 3인 문자 배열을 만들고, fread 함수를 이용해서 파일에서 첫 3바이트를 읽어온다.  
fread 함수의 각 인자는 (배열, 읽을 바이트 수, 읽을 횟수, 읽을 파일)을 의미한다.  

그리고 마지막으로 읽어들인 각 바이트가 각각 Oxff, OxD8, OxFF 인지를 확인한다.  
이는 JPEG 형식의 파일을 정의할 때 만든 약속으로, JPEG 파일의 시작점에 꼭 포함되어 있어야 한다.  

<!-- <span style="color:royalblue"> -->

<!-- ① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ Ω-->

<!-- ### 2. Link 넣기 

```

유형 1: (설명어를 입력) : [gunhee's coding blog](https://gunhee-jeong.github.io/)
유형 2: (URL 자동연결) : <https://gunhee-jeong.github.io/>
유형 3: (동일 파일 내 '문단으로 이동') : [1. Header로 이동](###-1-header)

```

유형 1: (설명어를 입력) : [gunhee's coding blog](https://gunhee-jeong.github.io/)
유형 2: (URL 자동연결) : <https://gunhee-jeong.github.io/>
유형 3: (동일 파일 내 '문단으로 이동') : [1. Header로 이동](#1-header)
유형 3의 방법

1. 특수문자를 제거
2. 스페이스는 -로 바꾸고
3. 대문자는 소문자로!
   그래서 ### 1. Header -> #1-header

## Link: [google][https://www.google.com/]

### 3. 수평선

```

---

```

---

### 4. 라인 바꾸기

```

스페이스바를 2번 눌러주면 다음칸으로
이동할 수 있어요!

```

---

스페이스바를 2번 눌러주면
다음칸으로 이동할 수 있어요!

### 5. list 만들기

```

1. 1번
2. 2번
3. 3번

- 순서없는 list
  - 순서없는 list
    - 순서없는 list

```

1. 1번
2. 2번
3. 3번

- 순서없는 list
  - 순서없는 list
    - 순서없는 list

---

### 6. font 관련

```

**진하게** -> 볼드
_기울여서_ -> 이탤릭체
~~취소선~~ -> 취소선

<ul>밑줄넣기</ul> -> 밑줄
<span style="color:red">빨간 글씨</span> -> 글자색
이것이 `인라인` 입니다 -> 인라인 코드
```

**진하게** -> 볼드
_기울여서_ -> 이탤릭체
~~취소선~~ -> 취소선
<u>밑줄넣기</u> -> 밑줄
<span style="color:red">빨간 글씨</span>
이것이 `인라인` 입니다 -> 인라인 코드

---

### 7. 인용구문

```
> coding
>
> > JavaScript
> >
> > > 내가 프짱!
```

> coding
>
> > JavaScript
> >
> > > 내가 프짱!

---

### 8. 이미지 삽입

```
유형1: ('사이즈를 조절' -> HTML 태그 사용) : <img src="https://gunhee-jeong.github.io/assets/images/blogLogo.png" width="500" height="200">
유형2: (이미지 삽입 후 -> 링크 걸기)
[![이미지](https://gunhee-jeong.github.io/assets/images/blogLogo/blogLogo.png)](https://gunhee-jeong.github.io/)
```
### 9. 표 만들기

```
||국어|영어|
| :--- | ---: | :--: |
|건희 | 100점 | 100점
|철수 | 100점 | 100점
```

|      |  국어 | 영어  |
| :--- | ----: | :---: |
| 건희 | 100점 | 100점 |
| 철수 | 100점 | 100점 |

> - header를 넣고 싶은 경우 ---을 사용하고 :을 이용하여 정렬에 사용함!

### 10. 토글 만들기

```
<details>
<summary>여기를 누르세요</summary>
<div markdown="1">
숨겨진 내용
</div>
</details>
```

<details>
<summary>여기를 누르세요</summary>
<div markdown="1">
숨겨진 내용
</div>
</details> -->
