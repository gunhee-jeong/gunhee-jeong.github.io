---
layout: single
title: "모두를 위한 컴퓨터 과학 -> 알고리즘"
# categories: Git
categories:
  - CS # HTML CSS JavaScript Server Algorithm Wecodes Programmers CS Github Blog
tag: [모두를 위한 컴퓨터 과학] #tag는 여러개 가능함
toc: true #table of content 기능!
toc_sticky: true
author_profile: true #blog 글안에서는 author_profile이 따라다니지 않도록 설정함
date: 2022-06-18T12:20:00+09:00
# sidebar:
# nav: "docs" #네비게이션에 있는 docs를 의미함
---
# 4장 알고리즘
## 1. 검색 알고리즘
### (1) 선형 검색
배열의 인덱스를 처음부터 끝까지 하나씩 증가시키며 그 값이 맞는지 검사하게 된다.  

```bash
For i from 0 to n–1

    If i'th element is 50

        Return true

Return false
```

### (2) 이진 검색
만약 배열이 정렬되어 있다면, 배열 중간 인덱스부터 시작하여  
찾고자 하는 값과 비교하여 그보다 작은 인덱스 또는 큰 인덱스로 이동을 반복하여 찾게 된다.  

```bash
If no items

    Return false

If middle item is 50

    Return true

Else if 50 < middle item

    Search left half

Else if 50 > middle item

    Search right half
```

## 2. 알고리즘 표기법
<img src="https://user-images.githubusercontent.com/87808288/174423979-6dcdeeb2-4d93-4440-9604-c722b2619de8.png" width="500">  
위의 그림과 같이 표기한 것이 바로 "<span style="color:red">Big O</span>" 표기법이다.  
O는 "<u>on the order of</u>"의 약자로, "<u>~만큼의 정도로 커지는</u>"이라고 생각할 수 있다.  

<u>O(n)</u>은 <span style="color:royalblue">n만큼 커지는 것</span>이므로 <span style="color:blue">n이 늘어날수록 선형적으로 증가</span>하게 된다.  
<u>O(n/2)</u>도 결국 <span style="color:royalblue">n이 매우 커지면 1/2은 큰 의미가 없어지므로</span> <span style="color:blue">O(n)</span>이라고 볼 수 있다.  

`Big O`가 <span style="color:blue">알고리즘 실행 시간의 상한</span>을 나타내는 것이라면,  
반대로 `Big Ω`는 <span style="color:blue">알고리즘 실행 시간의 하한</span>을 나타내는 것이다.  
선형 검색에서는 n개의 항목이 있을 때, 최대 n번의 검색을 해야하므로 상한이 O(n)이 되지만  
운이 좋다면 한 번만에 검색을 끝낼 수도 있으므로 하한은 Ω(1)이 되는 것이다.  

## 3. 선형 검색
### (1) 선형 검색
<span style="color:red">선형검색</span>은 원하는 원소가 발견될 때까지 <span style="color:royalblue">처음부터 마지막 자료까지 차례대로 검색</span>한다.  
이렇게 하여 선형 검색은 찾고자 하는 자료를 찾을 때까지 <span style="color:blue">모든 자료를 확인해야</span> 한다.  

### (2) 효율성 그리고 비효율성
<span style="color:red">선형 검색 알고리즘</span>은 <u>정확하지만</u> <span style="color:tomato">아주 효율적이지 못한</span> 방법이다.  
리스트의 길이가 n이라고 하면 -> <span style="color:blue">최악의 경우 모든 원소를 확인해야</span> 하므로 n번만큼 실행하게 된다.  
(여기서 최악의 경우는 == 자료가 맨 마지막에 있거나 리스트에 없는 경우)  
만약 100만 개의 원소가 있는 리스트라 가정한다면, 그 효율성이 매우 떨어짐을 알 수 있다.  

반대로 최선은 상황은 처음 시도했을 때 찾고자 하는 값이 바로 있는 경우이다.  
따라서 `선형 검색`은 <span style="color:blue">자료가 정렬되어 있지 않거나</span>, 어떠한 정보도 없이 하나씩 찾아야 하는 경우에 유용하다.  
이러한 무작위 탐색보다는 <span style="color:blue">순서대로 탐색하는</span> 것이 더 효율적인 것이다.  

주어진 배열에서 특정 값을 찾기 위해 선형 검색을 사용한다면, 아래와 같이 사용할 수 있다.  

```c++
#include <cs50.h>
#include <stdio.h>

int main(void)
{
    // numbers 배열 정의 및 값 입력
    int numbers[] = {4, 8, 15, 16, 23, 42};

    // 값 50 검색
    for (int i = 0; i < 6; i++)
    {
        if (numbers[i] == 50)
        {
            printf("Found\n");
            return 0;
        }
    }
    printf("Not found\n");
    return 1;
}
```

문자열로 이루어진 배열도 비슷한 방식으로 검색이 가능하다.  

```c++
#include <cs50.h>
#include <stdio.h>
#include <string.h>

int main(void)
{
    string names[] = {"EMMA", "RODRIGO", "BRIAN", "DAVID"};
    string numbers[] = {"617–555–0100", "617–555–0101", "617–555–0102", "617–555–0103"};

    for (int i = 0; i < 4; i++)
    {
        if (strcmp(names[i], "EMMA") == 0)
        {
            printf("Found %s\n", numbers[i]);
            return 0;
        }
    }
    printf("Not found\n");
    return 1;
}
```

names 배열과 numbers 배열을 따로 정의하고 names 배열에서 검색을 해서  
해당하는 인덱스의 numbers 배열 값을 출력하는 것이다.  
하지만 이 경우에는 <u>names 배열과 numbers 배열</u>이 <span style="color:blue">서로 같은 인덱스를 가져야 한다는 한계</span>가 있다.  

더 좋은 방법은 아래의 코드와 같이 <u>새로운 자료형</u>으로 <span style="color:blue">구조체를 정의해서 이름과 번호를 묶는 것</span>이다.  
<span style="color:red">typedef struct</span>을 통해서 <span style="color:tomato">새로운 자료형</span>을 구조체로 정의한다.   

```c++
#include <cs50.h>
#include <stdio.h>
#include <string.h>

typedef struct
{
    string name;
    string number;
}
person;

int main(void)
{
    person people[4];

    people[0].name = "EMMA";
    people[0].number = "617–555–0100";
    people[1].name = "RODRIGO";
    people[1].number = "617–555–0101";
    people[2].name = "BRIAN";
    people[2].number = "617–555–0102";
    people[3].name = "DAVID";
    people[3].number = "617–555–0103";

    // EMMA 검색
    for (int i = 0; i < 4; i++)
    {
        if (strcmp(people[i].name, "EMMA") == 0)
        {
            printf("Found %s\n", people[i].number);
            return 0;
        }
    }
    printf("Not found\n");
    return 1;
}
```

## 4. 버블 정렬
정렬되지 않은 리스트를 탐색하는 것보다 정렬한 뒤 탐색하는 것이 더 효율적이다.  
정렬 알고리즘 중 하나가 <span style="color:red">버블 정렬</span>이다.  

버블 정렬은 <span style="color:royalblue">두 개의 인접한 자료 값을 비교</span>하면서 위치를 교환하는 방식으로 정렬을 진행한다.  
버블 정렬은 <span style="color:blue">단 두개의 요소만 정렬해주는 좁은 범위의 정렬</span>에 집중하게 된다.  
이 방법은 간단하지만 <u>단 하나의 요소를 정렬하기 위해</u> <span style="color:royalblue">너무 많이 교환하는 낭비가 발생할 수 있다</span>.  
(마치 거품이 {비교 및 교환이}터지면서 위로 올라오는 방식이기 때문에)  

<u>5 6 7 3 2</u> 와 같은 숫자의 리스트가 존재하고, 이를 오름차순 정렬을 위해 <span style="color:red">버블 정렬</span>하여 한 번만 실행한다면  
`5 6 3 2 7`의 모습으로 정렬된다.  

## 5. 선택 정렬
보통 배열이 정렬되어 있으면 정렬되지 않은 배열보다 더 쉽게 탐색할 수 있다.  
정렬을 위한 알고리즘 중 <span style="color:red">선택정렬</span>은 배열 안의 자료 중 가장 작은 수(혹은 가장 큰수)를 찾아  
<span style="color:blue">첫 번째 위치(혹은 가장 마지막 위치)의 수와 교환해주는 방식</span>의 정렬 방법이다.  
선택 정렬은 교환 횟수를 최소화하는 반면 각 자료를 비교하는 횟수는 증가한다.  

아래의 정렬되지 않은 숫자들을 오름차순 정렬한다면  
6 3 8 5 2 7 4 1  

먼저 숫자들 중에서 가장 작은 값을 찾게 된다.  
가장 작은 값인 1은 가장 앞에 있어야 하므로 리스트의 첫 번째 값 6과 교환하게 된다.  

1 3 8 5 2 7 4 6  
그리고 정렬되어 있는 1은 제외하고, 두 번째 숫자부터 시작해서 또 가장 작은 값을 찾게 된다.  
가장 작은 값인 2는 정렬되지 않는 숫자들 중에서 가장 앞에 있어야 하므로 3과 교환한다.  
1 2 8 5 3 7 4 6  

이 과정을 더 이상 교환이 일어나지 않을 때까지 반복하다보면 아래와 같이 오르차순 정렬이 완성된다.  
1 2 3 4 5 6 7 8

이러한 방법을 선택 정렬이라고 부른다.  

```bash
For i from 0 to n–1

    Find smallest item between i'th item and last item

    Swap smallest item with i'th item
```

여기서도 두 번의 루프를 돌게 되는데,  
`바깥 루프`에서는 <u>숫자들을 처음부터 순서대로 방문</u>하고, `안쪽 루프`에서는 <u>가장 작은 값을 찾아야</u> 한다.  
따라서 소요 시간의 상한은 O(n^2)이 된다.  
하한도 마찬가지로 Ω(n2)이로, 버블 정렬과 동일하다.  

## 6. 정렬 알고리즘의 실행시간
<img src="https://user-images.githubusercontent.com/87808288/174476062-c425c2f4-e689-4998-ad90-c889745bed4e.png" width="400">  
### (1) 실행시간의 상한
- O(n^2): 버블 정렬, 선택 정렬
- O(n log n): 병합 정렬
- `O(n)`: <span style="color:red">선형 검색</span>
- `O(log n)`: <span style="color:red">이진 검색</span>
- O(1)  

알고리즘의 <span style="color:red">최악의 경우</span>를 나타내는 것은 `상한O()`이다.  

### (2) 실행시간의 하한
- Ω(n^2): 선택 정렬
- Ω(n log n): 병합 정렬
- Ω(n): 버블 정렬
- Ω(log n)
- Ω(1): 이진 검색, 선형 검색

여기서 `버블 정렬`을 조금 더 발전시킨다면,  
만약 <u>정렬이 모두 되어 있는 숫자 리스트</u>가 주어진다면, 원래는 아래의 코드와 같다.  

```bash
Repeat n–1 times

    For i from 0 to n–2

        If i'th and i+1'th elements out of order

            Swap them
```

여기서 <span style="color:royalblue">안쪽 루프에서 만약 교환이 일어나지 않는다면</span> <u>이미 정렬이 잘되어 있는</u> 상황이다.  
따라서 `바깥쪽 루프`를 "<span style="color:blue">교환이 일어나지 않을 때</span>"까지만 수행하도록 아래와 같이 바꿀 수 있다.  

```bash
Repeat until no swaps

    For i from 0 to n–2

        If i'th and i+1'th elements out of order

            Swap them
```

## 7. 재귀
main 안에서 프로그램을 작성하면서 필요한 순간에 호출하여 사용한다.  
main도 역시 함수인데, main이라는 함수 안에서 또 다른 함수를 사용한 것이다.  

#  
##  
###  
####  
위와 같이 피라미드를 출력하기 위해서 아래와 같은 코드를 작성할 수 있다.  

```c++
#include <cs50.h>
#include <stdio.h>

void draw(int h);

int main(void)
{
    // 사용자로부터 피라미드의 높이를 입력 받아 저장
    int height = get_int("Height: ");

    // 피라미드 그리기
    draw(height);
}

void draw(int h)
{
    // 높이가 h인 피라미드 그리기
    for (int i = 1; i <= h; i++)
    {
        for (int j = 1; j <= i; j++)
        {
            printf("#");
        }
        printf("\n");
    }
}
```

위의 코드에서, 사실 바깥 쪽 루프는 안 쪽 루프에서 수행하는 내용을 반복하도록 하는 것일 뿐이다.  
따라서 바깥 쪽 루프를 없앤 draw 함수를 만들고,  
이를 "<span style="color:red">재귀적</span>"으로 호출하도록 해서 똑같은 작업을 수행할 수 있다.  

```c++
#include <cs50.h>
#include <stdio.h>

void draw(int h);

int main(void)
{
    int height = get_int("Height: ");

    draw(height);
}

void draw(int h)
{
    // 높이가 0이라면 (그릴 필요가 없다면)
    if (h == 0)
    {
        return;
    }

    // 높이가 h-1인 피라미드 그리기
    draw(h - 1);

    // 피라미드에서 폭이 h인 한 층 그리기
    for (int i = 0; i < h; i++)
    {
        printf("#");
    }
    printf("\n");
}
```

draw 함수 안에서 draw 함수를 다시 호출하는 부분에 유의해야한다.  
h라는 높이를 받았을 때, h-1 높이로 draw 함수를 먼저 호출하고,  
그 후에 h만큼의 #을 출력하게 된다.  
여기서 내부적으로 호출된 draw 함수를 따라가다 보면 h = 0인 상황이 오게 된다.  
따라서 그때는 아무것도 출력을 하지 않도록 하는 조건문을 추가해야한다.  

draw(h - 1);이 호출되면  
높이 3의 피드미드를 그려 달라고 호출하고,  
2로 다시 호출하고,  
1로 다시 호출한다.  
자바스크립트의 콜 스택에 호출이 쌓이듯이 가장 나중에 호출된  
1 -> 2 -> 3으로 호출하면서 피라미드를 그리게 되는 것이다.  

## 8. 병합 정렬
<span style="color:red">병합 정렬</span>은 <u>원소가 한 개가 될 때까지</u> <span style="color:royalblue">계속해서 반으로 나누다가 다시 합쳐나가며 정렬</span>을 하는 방식이다.  
그리고 이 과정은 <span style="color:blue">재귀적으로 구현</span>되게 된다.  

아래의 숫자들을 오름차순으로 정렬한다면  
7 4 5 2 6 3 8 1  

<u>먼저 숫자들을 반으로</u> 나누게 된다.  
7 4 5 2 | 6 3 8 1  
그리고 나눠진 부분 중 <u>첫 번째를 한 번더 반으로</u> 나눈다.  
<span style="color:royalblue">7 4</span> | <span style="color:royalblue">5 2</span> | 6 3 8 1  

<u>마지막으로 한 번더</u> 나눈다.  
<span style="color:blue">7</span> | <span style="color:blue">4</span> | 5 2 | 6 3 8 1  

<span style="color:blue">이제 숫자가 두 개 밖에 남지 않았으므로 더 이상 나누지 않고</span>, <span style="color:tomato">두 숫자를 다시 병합</span>한다.  
이때 작은 숫자가 먼저 오도록 한다.  
4와 7의 순서를 바꿔서 병합하는 것이다.  
4 7 | 5 2 | 6 3 8 1  

마찬가지로 5 2 부분도 반으로 나눈 후에 작은 숫자가 먼저 오도록 다시 병합한다.  
4 7 | 2 5 | 6 3 8 1  

그럼 이제 `4 7`과 `2 5` <u>두 개의 부분들을 병합</u>하게 된다.  
<u>각 부분들의 숫자들을 앞에서 부터</u> 순서대로 읽어들여 비교하여 더 작은 숫자를 병합되는 부분에 가져온다.  
즉, 4와 2를 먼저 비교하여 2를 가져온다.  
그 후에 4와 5를 비교해서 4를 가져온다.  
그리고 7과 5를 비교해서 5를 가져오고, 남은 7을 가져온다.  
2 4 5 7 | 6 3 8 1  

이제 남은 오른쪽 4개의 숫자들도 위와 동일한 과정을 거치게 된다.  
2 4 5 7 | 1 3 6 8  

마지막으로 각각 정렬된 왼쪽 4개와 오른쪽 4개의 두 부분을 병합한다.  
2와 1을 비교하고, 1을 가져완다. 2와 3을 비교하고 2를 가져온다. 4와 3을 비교하여 3을 가져온다.  
...... 이 과정을 병합이 끝날 때까지 진행하면 아래와 같이 정렬이 완료된다.  
1 2 3 4 5 6 7 8  

전체의 과정을 요약하면 아래와 같다.  
7 | 4 | 5 | 2 | 6 | 3 | 8 | 1 → 가장 작은 부분 (숫자 1개)으로 나눠진 결과이다.  
4   7 | 2   5 | 3   6 | 1   8 → 숫자 1개씩을 정렬하여 병합한 결과이다.  
2   4   5   7 | 1   3   6   8 → 숫자 2개씩을 정렬하여 병합한 결과이다.  
1   2   3   4   5   6   7   8 → 마지막으로 숫자 4개씩을 정렬하여 병합한 결과이다.   

병합 정렬 실행 시간의 상한은 O(n log n)이다.  
숫자들을 반으로 나누는 데는 O(log n)의 시간이 들고, 각 반으로 나눈 부분들을 다시 정렬해서 병합하는데  
각각 O(n)의 시간이 걸리기 때문이다.  
실행 시간의 하한도 역시 Ω(n log n)이다.  
이미 정렬되었는지 여부에 관계 없이 나누고 병합하는 과정이 필요하기 때문이다.  

1, 3, 5, 8, 9, 10

<!-- <span style="color:royalblue"> -->

<!-- ① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ Ω-->

<!-- ### 2. Link 넣기 

```

유형 1: (설명어를 입력) : [gunhee's coding blog](https://gunhee-jeong.github.io/)
유형 2: (URL 자동연결) : <https://gunhee-jeong.github.io/>
유형 3: (동일 파일 내 '문단으로 이동') : [1. Header로 이동](###-1-header)

```

유형 1: (설명어를 입력) : [gunhee's coding blog](https://gunhee-jeong.github.io/)
유형 2: (URL 자동연결) : <https://gunhee-jeong.github.io/>
유형 3: (동일 파일 내 '문단으로 이동') : [1. Header로 이동](#1-header)
유형 3의 방법

1. 특수문자를 제거
2. 스페이스는 -로 바꾸고
3. 대문자는 소문자로!
   그래서 ### 1. Header -> #1-header

## Link: [google][https://www.google.com/]

### 3. 수평선

```

---

```

---

### 4. 라인 바꾸기

```

스페이스바를 2번 눌러주면 다음칸으로
이동할 수 있어요!

```

---

스페이스바를 2번 눌러주면
다음칸으로 이동할 수 있어요!

### 5. list 만들기

```

1. 1번
2. 2번
3. 3번

- 순서없는 list
  - 순서없는 list
    - 순서없는 list

```

1. 1번
2. 2번
3. 3번

- 순서없는 list
  - 순서없는 list
    - 순서없는 list

---

### 6. font 관련

```

**진하게** -> 볼드
_기울여서_ -> 이탤릭체
~~취소선~~ -> 취소선

<ul>밑줄넣기</ul> -> 밑줄
<span style="color:red">빨간 글씨</span> -> 글자색
이것이 `인라인` 입니다 -> 인라인 코드
```

**진하게** -> 볼드
_기울여서_ -> 이탤릭체
~~취소선~~ -> 취소선
<u>밑줄넣기</u> -> 밑줄
<span style="color:red">빨간 글씨</span>
이것이 `인라인` 입니다 -> 인라인 코드

---

### 7. 인용구문

```
> coding
>
> > JavaScript
> >
> > > 내가 프짱!
```

> coding
>
> > JavaScript
> >
> > > 내가 프짱!

---

### 8. 이미지 삽입

```
유형1: ('사이즈를 조절' -> HTML 태그 사용) : <img src="https://gunhee-jeong.github.io/assets/images/blogLogo.png" width="500" height="200">
유형2: (이미지 삽입 후 -> 링크 걸기)
[![이미지](https://gunhee-jeong.github.io/assets/images/blogLogo/blogLogo.png)](https://gunhee-jeong.github.io/)
```
### 9. 표 만들기

```
||국어|영어|
| :--- | ---: | :--: |
|건희 | 100점 | 100점
|철수 | 100점 | 100점
```

|      |  국어 | 영어  |
| :--- | ----: | :---: |
| 건희 | 100점 | 100점 |
| 철수 | 100점 | 100점 |

> - header를 넣고 싶은 경우 ---을 사용하고 :을 이용하여 정렬에 사용함!

### 10. 토글 만들기

```
<details>
<summary>여기를 누르세요</summary>
<div markdown="1">
숨겨진 내용
</div>
</details>
```

<details>
<summary>여기를 누르세요</summary>
<div markdown="1">
숨겨진 내용
</div>
</details> -->
