---
layout: single
title: "모두를 위한 컴퓨터 과학 -> 알고리즘"
# categories: Git
categories:
  - CS # HTML CSS JavaScript Server Algorithm Wecodes Programmers CS Github Blog
tag: [모두를 위한 컴퓨터 과학] #tag는 여러개 가능함
toc: true #table of content 기능!
toc_sticky: true
author_profile: true #blog 글안에서는 author_profile이 따라다니지 않도록 설정함
date: 2022-06-18T12:20:00+09:00
# sidebar:
# nav: "docs" #네비게이션에 있는 docs를 의미함
---
# 4장 알고리즘
## 1. 검색 알고리즘
### (1) 선형 검색
배열의 인덱스를 처음부터 끝까지 하나씩 증가시키며 그 값이 맞는지 검사하게 된다.  

```bash
For i from 0 to n–1

    If i'th element is 50

        Return true

Return false
```

### (2) 이진 검색
만약 배열이 정렬되어 있다면, 배열 중간 인덱스부터 시작하여  
찾고자 하는 값과 비교하여 그보다 작은 인덱스 또는 큰 인덱스로 이동을 반복하여 찾게 된다.  

```bash
If no items

    Return false

If middle item is 50

    Return true

Else if 50 < middle item

    Search left half

Else if 50 > middle item

    Search right half
```

## 2. 알고리즘 표기법
<img src="https://user-images.githubusercontent.com/87808288/174423979-6dcdeeb2-4d93-4440-9604-c722b2619de8.png" width="500">  
위의 그림과 같이 표기한 것이 바로 "<span style="color:red">Big O</span>" 표기법이다.  
O는 "<u>on the order of</u>"의 약자로, "<u>~만큼의 정도로 커지는</u>"이라고 생각할 수 있다.  

<u>O(n)</u>은 <span style="color:royalblue">n만큼 커지는 것</span>이므로 <span style="color:blue">n이 늘어날수록 선형적으로 증가</span>하게 된다.  
<u>O(n/2)</u>도 결국 <span style="color:royalblue">n이 매우 커지면 1/2은 큰 의미가 없어지므로</span> <span style="color:blue">O(n)</span>이라고 볼 수 있다.  

`Big O`가 <span style="color:blue">알고리즘 실행 시간의 상한</span>을 나타내는 것이라면,  
반대로 `Big Ω`는 <span style="color:blue">알고리즘 실행 시간의 하한</span>을 나타내는 것이다.  
선형 검색에서는 n개의 항목이 있을 때, 최대 n번의 검색을 해야하므로 상한이 O(n)이 되지만  
운이 좋다면 한 번만에 검색을 끝낼 수도 있으므로 하한은 Ω(1)이 되는 것이다.  

## 3. 선형 검색
### (1) 선형 검색
<span style="color:red">선형검색</span>은 원하는 원소가 발견될 때까지 <span style="color:royalblue">처음부터 마지막 자료까지 차례대로 검색</span>한다.  
이렇게 하여 선형 검색은 찾고자 하는 자료를 찾을 때까지 <span style="color:blue">모든 자료를 확인해야</span> 한다.  

### (2) 효율성 그리고 비효율성
<span style="color:red">선형 검색 알고리즘</span>은 <u>정확하지만</u> <span style="color:tomato">아주 효율적이지 못한</span> 방법이다.  
리스트의 길이가 n이라고 하면 -> <span style="color:blue">최악의 경우 모든 원소를 확인해야</span> 하므로 n번만큼 실행하게 된다.  
(여기서 최악의 경우는 == 자료가 맨 마지막에 있거나 리스트에 없는 경우)  
만약 100만 개의 원소가 있는 리스트라 가정한다면, 그 효율성이 매우 떨어짐을 알 수 있다.  

반대로 최선은 상황은 처음 시도했을 때 찾고자 하는 값이 바로 있는 경우이다.  
따라서 `선형 검색`은 <span style="color:blue">자료가 정렬되어 있지 않거나</span>, 어떠한 정보도 없이 하나씩 찾아야 하는 경우에 유용하다.  
이러한 무작위 탐색보다는 <span style="color:blue">순서대로 탐색하는</span> 것이 더 효율적인 것이다.  

주어진 배열에서 특정 값을 찾기 위해 선형 검색을 사용한다면, 아래와 같이 사용할 수 있다.  

```c++
#include <cs50.h>
#include <stdio.h>

int main(void)
{
    // numbers 배열 정의 및 값 입력
    int numbers[] = {4, 8, 15, 16, 23, 42};

    // 값 50 검색
    for (int i = 0; i < 6; i++)
    {
        if (numbers[i] == 50)
        {
            printf("Found\n");
            return 0;
        }
    }
    printf("Not found\n");
    return 1;
}
```

문자열로 이루어진 배열도 비슷한 방식으로 검색이 가능하다.  

```c++
#include <cs50.h>
#include <stdio.h>
#include <string.h>

int main(void)
{
    string names[] = {"EMMA", "RODRIGO", "BRIAN", "DAVID"};
    string numbers[] = {"617–555–0100", "617–555–0101", "617–555–0102", "617–555–0103"};

    for (int i = 0; i < 4; i++)
    {
        if (strcmp(names[i], "EMMA") == 0)
        {
            printf("Found %s\n", numbers[i]);
            return 0;
        }
    }
    printf("Not found\n");
    return 1;
}
```

names 배열과 numbers 배열을 따로 정의하고 names 배열에서 검색을 해서  
해당하는 인덱스의 numbers 배열 값을 출력하는 것이다.  
하지만 이 경우에는 <u>names 배열과 numbers 배열</u>이 <span style="color:blue">서로 같은 인덱스를 가져야 한다는 한계</span>가 있다.  

더 좋은 방법은 아래의 코드와 같이 <u>새로운 자료형</u>으로 <span style="color:blue">구조체를 정의해서 이름과 번호를 묶는 것</span>이다.  

```c++
#include <cs50.h>
#include <stdio.h>
#include <string.h>

typedef struct
{
    string name;
    string number;
}
person;

int main(void)
{
    person people[4];

    people[0].name = "EMMA";
    people[0].number = "617–555–0100";
    people[1].name = "RODRIGO";
    people[1].number = "617–555–0101";
    people[2].name = "BRIAN";
    people[2].number = "617–555–0102";
    people[3].name = "DAVID";
    people[3].number = "617–555–0103";

    // EMMA 검색
    for (int i = 0; i < 4; i++)
    {
        if (strcmp(people[i].name, "EMMA") == 0)
        {
            printf("Found %s\n", people[i].number);
            return 0;
        }
    }
    printf("Not found\n");
    return 1;
}
```

## 4. 버블 정렬
정렬되지 않은 리스트를 탐색하는 것보다 정렬한 뒤 탐색하는 것이 더 효율적이다.  
정렬 알고리즘 중 하나가 <span style="color:red">버블 정렬</span>이다.  

버블 정렬은 <span style="color:royalblue">두 개의 인접한 자료 값을 비교</span>하면서 위치를 교환하는 방식으로 정렬을 진행한다.  
버블 정렬은 <span style="color:blue">단 두개의 요소만 정렬해주는 좁은 범위의 정렬</span>에 집중하게 된다.  
이 방법은 간단하지만 <u>단 하나의 요소를 정렬하기 위해</u> <span style="color:royalblue">너무 많이 교환하는 낭비가 발생할 수 있다</span>.  
(마치 거품이 {비교 및 교환이}터지면서 위로 올라오는 방식이기 때문에)  

## 5. 선택 정렬
보통 배열이 정렬되어 있으면 정렬되지 않은 배열보다 더 쉽게 탐색할 수 있다.  
정렬을 위한 알고리즘 중 <span style="color:red">선택정렬</span>은 배열 안의 자료 중 가장 작은 수(혹은 가장 큰수)를 찾아  
<span style="color:blue">첫 번째 위치(혹은 가장 마지막 위치)의 수와 교환해주는 방식</span>의 정렬 방법이다.  
선택 정렬은 교환 횟수를 최소화하는 반면 각 자료를 비교하는 횟수는 증가한다.  

아래의 정렬되지 않은 숫자들을 오름차순 정렬한다면  
6 3 8 5 2 7 4 1  

먼저 숫자들 중에서 가장 작은 값을 찾게 된다.  
가장 작은 값인 1은 가장 앞에 있어야 하므로 리스트의 첫 번째 값 6과 교환하게 된다.  

1 3 8 5 2 7 4 6  
그리고 정렬되어 있는 1은 제외하고, 두 번째 숫자부터 시작해서 또 가장 작은 값을 찾게 된다.  
가장 작은 값인 2는 정렬되지 않는 숫자들 중에서 가장 앞에 있어야 하므로 3과 교환한다.  
1 2 8 5 3 7 4 6  

이 과정을 더 이상 교환이 일어나지 않을 때까지 반복하다보면 아래와 같이 오르차순 정렬이 완성된다.  
1 2 3 4 5 6 7 8

이러한 방법을 선택 정렬이라고 부른다.  

```bash
For i from 0 to n–1

    Find smallest item between i'th item and last item

    Swap smallest item with i'th item
```

여기서도 두 번의 루프를 돌게 되는데,  
`바깥 루프`에서는 <u>숫자들을 처음부터 순서대로 방문</u>하고, `안쪽 루프`에서는 <u>가장 작은 값을 찾아야</u> 한다.  
따라서 소요 시간의 상한은 O(n^2)이 된다.  
하한도 마찬가지로 Ω(n2)이로, 버블 정렬과 동일하다.  

## 6. 정렬 알고리즘의 실행시간
### (1) 실행시간의 상한
- O(n^2): 선택 정렬, 버블 정렬
- O(n log n)
- O(n): 선형 검색
- O(log n): 이진 검색
- O(1)

### (2) 실행시간의 하한
- Ω(n^2): 선택 정렬, 버블 정렬
- Ω(n log n)
- Ω(n)
- Ω(log n)
- Ω(1): 선형 검색, 이진 검색

여기서 `버블 정렬`을 조금 더 발전시킨다면,  
만약 <u>정렬이 모두 되어 있는 숫자 리스트</u>가 주어진다면, 원래는 아래의 코드와 같다.  

```bash
Repeat n–1 times

    For i from 0 to n–2

        If i'th and i+1'th elements out of order

            Swap them
```

여기서 <span style="color:royalblue">안쪽 루프에서 만약 교환이 일어나지 않는다면</span> <u>이미 정렬이 잘되어 있는</u> 상황이다.  
따라서 `바깥쪽 루프`를 "<span style="color:blue">교환이 일어나지 않을 때</span>"까지만 수행하도록 아래와 같이 바꿀 수 있다.  

```bash
Repeat until no swaps

    For i from 0 to n–2

        If i'th and i+1'th elements out of order

            Swap them
```

<!-- <span style="color:royalblue"> -->

<!-- ① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ Ω-->

<!-- ### 2. Link 넣기 

```

유형 1: (설명어를 입력) : [gunhee's coding blog](https://gunhee-jeong.github.io/)
유형 2: (URL 자동연결) : <https://gunhee-jeong.github.io/>
유형 3: (동일 파일 내 '문단으로 이동') : [1. Header로 이동](###-1-header)

```

유형 1: (설명어를 입력) : [gunhee's coding blog](https://gunhee-jeong.github.io/)
유형 2: (URL 자동연결) : <https://gunhee-jeong.github.io/>
유형 3: (동일 파일 내 '문단으로 이동') : [1. Header로 이동](#1-header)
유형 3의 방법

1. 특수문자를 제거
2. 스페이스는 -로 바꾸고
3. 대문자는 소문자로!
   그래서 ### 1. Header -> #1-header

## Link: [google][https://www.google.com/]

### 3. 수평선

```

---

```

---

### 4. 라인 바꾸기

```

스페이스바를 2번 눌러주면 다음칸으로
이동할 수 있어요!

```

---

스페이스바를 2번 눌러주면
다음칸으로 이동할 수 있어요!

### 5. list 만들기

```

1. 1번
2. 2번
3. 3번

- 순서없는 list
  - 순서없는 list
    - 순서없는 list

```

1. 1번
2. 2번
3. 3번

- 순서없는 list
  - 순서없는 list
    - 순서없는 list

---

### 6. font 관련

```

**진하게** -> 볼드
_기울여서_ -> 이탤릭체
~~취소선~~ -> 취소선

<ul>밑줄넣기</ul> -> 밑줄
<span style="color:red">빨간 글씨</span> -> 글자색
이것이 `인라인` 입니다 -> 인라인 코드
```

**진하게** -> 볼드
_기울여서_ -> 이탤릭체
~~취소선~~ -> 취소선
<u>밑줄넣기</u> -> 밑줄
<span style="color:red">빨간 글씨</span>
이것이 `인라인` 입니다 -> 인라인 코드

---

### 7. 인용구문

```
> coding
>
> > JavaScript
> >
> > > 내가 프짱!
```

> coding
>
> > JavaScript
> >
> > > 내가 프짱!

---

### 8. 이미지 삽입

```
유형1: ('사이즈를 조절' -> HTML 태그 사용) : <img src="https://gunhee-jeong.github.io/assets/images/blogLogo.png" width="500" height="200">
유형2: (이미지 삽입 후 -> 링크 걸기)
[![이미지](https://gunhee-jeong.github.io/assets/images/blogLogo/blogLogo.png)](https://gunhee-jeong.github.io/)
```
### 9. 표 만들기

```
||국어|영어|
| :--- | ---: | :--: |
|건희 | 100점 | 100점
|철수 | 100점 | 100점
```

|      |  국어 | 영어  |
| :--- | ----: | :---: |
| 건희 | 100점 | 100점 |
| 철수 | 100점 | 100점 |

> - header를 넣고 싶은 경우 ---을 사용하고 :을 이용하여 정렬에 사용함!

### 10. 토글 만들기

```
<details>
<summary>여기를 누르세요</summary>
<div markdown="1">
숨겨진 내용
</div>
</details>
```

<details>
<summary>여기를 누르세요</summary>
<div markdown="1">
숨겨진 내용
</div>
</details> -->
