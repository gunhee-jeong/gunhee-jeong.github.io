---
layout: single
title: "Front-end의 역사와 미래"
# categories: Git
categories:
  - web # HTML CSS JavaScript Server Algorithm Wecode Programmers CS vsCode
tag: [프론트엔드, teo, 역사, 미래] #tag는 여러개 가능함
toc: true #table of content 기능!
toc_sticky: true
author_profile: true #blog 글안에서는 author_profile이 따라다니지 않도록 설정함
# sidebar:
# nav: "docs" #네비게이션에 있는 docs를 의미함
---
teo님의 velog 글들을 보던 중 "프론트엔드 역사와 미래, 업무 분야 and 잘하는 프론테엔드 개발자란?"  
라는 글을 보고 다시 한 번 블로그에 정리한다.  
>teo.log : [프론트엔드 역사와 미래, 업무 분야 ... 그리고 잘하는 프론트엔드 개발자란?](https://velog.io/@teo/frontend)   

# Front-end 포지션의 탄생 이유  
## WEB 1.0  
### 문서를 공유하기 위하여 web이 만들어졌다(1990)  
이때 <u>가상의 공간에서 텍스트에 새로운 문서에 대한 링크</u>가 존재하는 '<span style="color:red">하이퍼텍스트</span>'가 탄생한다.  
그렇게 HTML의 첫 글자가 바로 -> Hypertext!  
<span style="color:red">web</span>은 그렇게 문서를 모든 사람이 `쉽게 만들고 또 공유하기 위해서` 탄생하게된다.   

### CGI(Common Gate Interface) 통신이 가능해진(1994)  
정적인 정보만 담고 있는 문서에 사용자가 <u>일정한 정보를 입력해서 전달하면</u> 그 정보를 바탕으로  
<span style="color:blue">서버에서 동적으로 페이지를 생성</span>할 수 있게 되었다.  
<u>PHP를 시작으로</u> 여러가지 서버 스크립트 언어가 만들어지면서 본격적인 홈페이지 서비스들이 만들어진다.   

### JavaScript의 탄생(1995)  
서버뿐만이 아니라 <u>브라우저에서 실행이 가능한 스크립트 언어</u>가 필요했고 -> <span style="color:red">자바스크립트</span>가 탄생한다.  
이렇게 <u>서버와 통신을 하기 전에 화면을 조작</u>하고 <span style="color:blue">서버에 데이터를 전달하기 전에 검증</span>을 하는 등의 기능이 가능해진 것이다.  

### 문서를 예쁘게! 웹 디자인의 발전(1996)  
HTML에 과도한 스타일이 작성되어 유지보수를 어렵게 하던 문제에서 <u>컨텐츠와 서식을 분리하자는</u> <span style="color:red">CSS</span>가 탄생한다.  
그리고 브라우저의 성능상의 한계로 표현하지 모하던 애니메이션 등을 해결한 FLASH가 탄생한다.  

### Internet Exploer의 대중화와 웹의 상업화(1995-2004)  
Windows가 대중화되고 Internet Exploer가 기본 탑재되면서 -> web은 기업에서는 기본적으로 가지고 있어야하는  
존재들이 되었고 이때 `남들의 주목을 끌기 위해서` <u>기능보다는 디자인으로 이목을</u> 끄는 편이 쉬웠기에  
수많은 디자이너가 생겨났고 홈페이지를 개발하는 웹 개발자가 생겨났다.  

## Web 2.0과 RIA(Rich Web Application)  
### Flash와 RIA(Rich Web Application)  
2000년대 초 닷컴 버블로 여러가지 웹 비즈니스가 재편되면서 `WEB2.0`이라는 용어가 생겨난다.  
여기에는 여러가지 개념들이 있지만 Front-end와 가장 밀접한 관계의 키워드는 <span style="color:blue">RIA</span>이다.   

기존의 정적인 문서 구조에서 벗어나 <span style="color:blue">사용자와 적극적으로 상호작용</span>하며 화면이 동적으로 변하는 방향으로 나아가고있었다.   
당시에는 이와 가장 적합한 도구가 바로 `Flash`였다.   
당시 Internet Exploer의 동적 스크립트 능력을 한없이 열악했으며 더 막강한 언어인 ActionScript로  
되어있는 Flash는 <u>디자인, 애니메이션, 사용자 인터렉션</u> 모두에서 월등했다.  
하지만 Flash는 HTML이 아니므로 검색엔진에 포함되지 않았다.  
문서라는 본질적인 측면에서는 Flash가 효과적이지 않다는 것을 알게 된다.  

### 구글 - 마이크로소프트의 대항마로 WEB을 선택하다   
검색엔진과 구글애드로 성공을 거둔 구글은 당시 IT의 1인자인 마이크로소프트를 넘오보고자 했었고  
자신들의 아이덴티디는 검색엔진이고 -> 웹을 맨 처음시작할 때 google로 시작한다면  
'웹이 하나의 OS가 되면 어떨까?'라는 생각으로 프로젝트를 시작하게 된다.  

### 웹 표준과 웹 접근성, 시맨틱... 크로스 브라우징  
Window, Internet Exploer, ActiveX 등이 독점적 지위로 인해 자체 표준이 되어버린  
상황에서 여러가지 브라우저 벤더를 포함 웹 종사자들이 다 같이 웹을 쓸 수 있도록 하는 `웹 표준`을 만들게 된다.  
<u>웹은 모두의 것이고</u> 특정 벤더에 의해 관리되지 않아야 하고 웹의 발전을 위해서는 최적의 것들을 표준으로  
만들어야 한다는 취지로 만들어지게 된다.  
<u>웹 표준을 지켜서 html, css, javascript를 만들면</u> <span style="color:blue">브라우저와 관계없이 동작할 수 있다</span>는 것을 의미한다.  

이때부터 웹 디자이너, 웹 개발자들에게는 <span style="color:red">웹 표준</span>에 맞게 작성을 해야하고 JavaScript나 CSS 등을 이용해서  
<u>동적으로 화면을 만드는 능력</u>을 요구받게 된다.  
또한 이때 웹표준과 함께 <span style="color:blue">시맨틱</span>이라는 요소가 함께 강조되면서 `검색에 유리한 구조`와 `의미를 부여`하는 식으로  
HTML과 CSS를 작성하고 `시각장애인`들과 같은 경우에도 웹을 사용할 수 있도록 하는 접근성에 대해서 강조가  
되면서 디자인보다 <u>Front-end에서 더 전문성을 요하는 부분들이 생겨나게</u>되었다.   

### 크롬브라우저와 V8 엔진  
<u>웹을 통한 OS와 웹 어플리케이션</u>을 다음 먹거리로 삼았던 <span style="color:blue">구글</span>은 `JavaScript의 성능 개선`이 중요한 과제가 되었다.  
그래서 JavaScript의 성능을 개선한 <span style="color:blue">V8 엔진</span>을 만들고 이것을 오픈소스로 공유하게 된다.  
그리고 <u>V8</u>와 당시 <u>apple의 safari 오픈소스 웹브라우저 엔진인 webkit</u>을 결합시킨 <span style="color:red">크롬 브라우저</span>가 탄생하게 된다.  

### Node와 npm  
V8의 오픈소스는 새로운 국면을 맞이하는데 -> <u>JavaScript를 가지고 서버사이드 환경을 개발</u>할 수 있는  
`Node가 탄생`했기 때문이다.  
그리고 Node에서 <u>module이라는 방법을 채택</u>하면서 JavaScript에도 <span style="color:blue">module 방식의 개념이 보편화</span>되는 계기가 된다.  
> module 개념이 중요한 것은 <u>파일을 쪼갬으로써</u> <span style="color:red">훨씬 더 덩치를 키울 수 있는 프로그램을</span> 만들 수 있기 때문이다.  
`자바스크립트는 모듈이 없다보니 한 파일에만 크게 작성을` 해야했고 여러 파일들을 쪼개서 불러오면 성능상의 이슈가  
발생헀기 때문에 JavaScript 덩치를 키우는게 쉽지 않았기 때문이다.  

이후 `npm`이라는 <u>module을 패키징해서 등록하고 관리</u>할 수 있는 도구가 생겨나면서  
JavaScript 생태계는 폭발적으로 성장하게 된다.  
이를 바탕으로 <u>webpack, babel, rollup</u>과 같은 Node를 기반으로 하는 dev-ops 영역이 활방해지면서  
그간 JavaScript 개발에 불편했던 영역들이 개선되기 시작한다.   

### 페이스북 - 연결의 가치(1분에 3테라의 데이터가 쌓인다)  
페이스북은 1분에 3테라의 데이터가 쌓일 만큼 성장하게 된다. -> 이를 위해서는 기존과는 완전히 다른 체계의  
서버 구상이 필요하게 된다.  
그리고 페이스북은 유래없이 단일 웹 서비스로 거대한 성공을 경험하고 -> 페이스북 역시도 하나의 OS의 역할을  
하길 원했고 -> 웹, 게임, 연결, 채팅, 메신저 등 많은 기능들이 Facebook에서 구동되기를 바랐다.  

### Back-end와 Front-end의 각자의 전문성의 분리(React의 탄생)  
지금까지 없었던 거대한 웹 사이트를 유지하고 관리한다는 것은 쉽지 않았다.  
Facebook은 Facebook을 개발하던 서버언어인 PHP를 확장시키고 싶었다.  
나중에 이것은 JavaScript의 개발경험을 바꾸는 것으로 이어졌고 JSX를 기본으로 하는 React Framework의  
탄생이기도 했다.   
> Front-end가 새로 생겼다기보다는 거대 웹 서비스의 등장과 웹 산업이 발전하는 과정에서 자연스레  
세분화된 것이다. Back-end는 이제 거대 데이터를 처리하기 위한 도구와 자동배포와 스케일링 등의  
새로운 과제를 맞이하게 되었고, Front-end 역시 화면을 동적으로 다루는 역할이 중요해지면서 더 필요한 역할을  
부여받게 되었다.  
특히 <u>React를 기점으로</u> Front-end 개발의 체계가 잡히면서 이러한 체계가 뚜렷해지기 시작한다.  

## 앞으로의 Front-end의 방향성  
### 보다 Serverless 하게(클라우드 서비스)  
Back-end의 로직의 영역은 점점 Front-end로 내려오고 있고 -> Back-end는 데이터를 교환하고 저장하고  
관리하는 인프라의 영역으로 확대되고 있다.  
<u>데이터를 다루는 로직은</u> `점점 Front-end가 담당`하게 되면서 <span style="color:red">클라우드를 통해 서버없이 작업을 하는 형태로</span>  
발전하고 있다.   

### 보다 실시간으로  
게시판에서, SNS, 메신저 등 점점 <span style="color:blue">데이터의 교환속도가 빨라지는 방향</span>으로 발전하고 있다.  
메타버스에서는 완전히 실시간으로 연결된 것들을 상상하고 있다.  
> 데이터를 실시간으로 다루는 형식으로 서비스들은 발전하고 있다.  
슬랙, 피그마, 노션, 게더타운 등을 떠올려보면 이해하기 쉽다.   

# Front-end 개발자의 업무 범위  
웹 서비스란 <u>사용자가 어떠한 입력을 하고</u> `입력을 통해 더 가치있는 데이터를 만들어` 사용자에게 잘 전달하는 것을  
의미한다. 이 과정에서 Front-end는 <span style="color:red">사용자와 서비스를 연결해주는 과정의 모든 것들을 구현하는 역할</span>을 하는 것이다. 
## 데이터를 잘 보여주기  
서버에서 내려오는 데이터를 적절히 HTML, CSS를 통해서 요구하는 디자인의 형태로 나타내야하는 영역이다.  

1. 디자인을 HTML + CSS로 만들어내는 작업  
2. 적절히 재사용이 가능한 형태로 디자인을 컴포넌트화 하는 작업  
3. 기기, 브라우저, 화면 등에 맞게 디자인이 제대로 보이기 위한 작업  
4. 시맨틱, 접근성, 검색엔진 최적화 등을 하기 위한 작업  
5. 초기 로딩 속도를 개선하기 위한 최적화 작업  
6. 서버의 데이터를 적절히 디자인 컨텐츠에 연결하여 데이터와 함께 출력하는 작업  

## 데이터(화면)를 조작하는 기능  
이미 만들어진 데이터에서 사용자의 입력을 받아서 적절히 다른 데이터(화면)로 변경하는 역할을 담당한다.  
대부분의 UI와 DOM, WEB API에 대한 이해와 View를 이루고 있는 데이터에 대한 깊은 이해를 요구한다.  

데이터의 관점으로 보았을 때는 `의미있는 데이터를 화면 내에서 만들려고 할수록` <span style="color:blue">어려워지고  
복잡해지고 중요해지는 경향</span>이 있다.  블로그의 글쓰기 에디터나 벨로그의 마크다운 글쓰기,  
구글 시트의 셀, 피그마의 기능과 같은 부분들을 떠올려볼 수 있다.  
1. 현재의 화면을 데이터로 구성한다.  
2. 사용자의 이벤트를 감지한다.  
3. 해당 이벤트를 적절한 행동으로 분류한다.  
4. 행동에 맞는 적절한 WEB API를 동작한다.  
5. 해당 API의 결과를 통해 새로운 데이터를 생성한다.  
6. 이 데이터를 기존의 데이터와 조립해서 원하는 데이터로 변경한다.  
7. 해당 데이터를 화먄에 출력한다.  


<!-- ### 2. Link 넣기

```

유형 1: (설명어를 입력) : [gunhee's coding blog](https://gunhee-jeong.github.io/)
유형 2: (URL 자동연결) : <https://gunhee-jeong.github.io/>
유형 3: (동일 파일 내 '문단으로 이동') : [1. Header로 이동](###-1-header)

```

유형 1: (설명어를 입력) : [gunhee's coding blog](https://gunhee-jeong.github.io/)
유형 2: (URL 자동연결) : <https://gunhee-jeong.github.io/>
유형 3: (동일 파일 내 '문단으로 이동') : [1. Header로 이동](#1-header)
유형 3의 방법

1. 특수문자를 제거
2. 스페이스는 -로 바꾸고
3. 대문자는 소문자로!
   그래서 ### 1. Header -> #1-header

## Link: [google][https://www.google.com/]

### 3. 수평선

```

---

```

---

### 4. 라인 바꾸기

```

스페이스바를 2번 눌러주면 다음칸으로
이동할 수 있어요!

```

---

스페이스바를 2번 눌러주면
다음칸으로 이동할 수 있어요!

### 5. list 만들기

```

1. 1번
2. 2번
3. 3번

- 순서없는 list
  - 순서없는 list
    - 순서없는 list

```

1. 1번
2. 2번
3. 3번

- 순서없는 list
  - 순서없는 list
    - 순서없는 list

---

### 6. font 관련

```

**진하게** -> 볼드
_기울여서_ -> 이탤릭체
~~취소선~~ -> 취소선

<ul>밑줄넣기</ul> -> 밑줄
<span style="color:red">빨간 글씨</span> -> 글자색
이것이 `인라인` 입니다 -> 인라인 코드
```

**진하게** -> 볼드
_기울여서_ -> 이탤릭체
~~취소선~~ -> 취소선
<u>밑줄넣기</u> -> 밑줄
<span style="color:red">빨간 글씨</span>
이것이 `인라인` 입니다 -> 인라인 코드

---

### 7. 인용구문

```
> coding
>
> > JavaScript
> >
> > > 내가 프짱!
```

> coding
>
> > JavaScript
> >
> > > 내가 프짱!

---

### 8. 이미지 삽입

```
유형1: ('사이즈를 조절' -> HTML 태그 사용) : <img src="https://gunhee-jeong.github.io/assets/images/blogLogo.png" width="300" height="200">
유형2: (이미지 삽입 후 -> 링크 걸기)
[![이미지](https://gunhee-jeong.github.io/assets/images/blogLogo/blogLogo.png)](https://gunhee-jeong.github.io/)
```

유형1: ('사이즈를 조절' -> HTML 태그 사용) : <img src="https://gunhee-jeong.github.io/assets/images/blogLogo.png" width="300" height="200">
유형2: (이미지 삽입 후 -> 링크 걸기)
[![이미지](https://gunhee-jeong.github.io/assets/images/blogLogo.png)](https://gunhee-jeong.github.io/)

### 9. 표 만들기

```
||국어|영어|
| :--- | ---: | :--: |
|건희 | 100점 | 100점
|철수 | 100점 | 100점
```

|      |  국어 | 영어  |
| :--- | ----: | :---: |
| 건희 | 100점 | 100점 |
| 철수 | 100점 | 100점 |

> - header를 넣고 싶은 경우 ---을 사용하고 :을 이용하여 정렬에 사용함!

### 10. 토글 만들기

```
<details>
<summary>여기를 누르세요</summary>
<div markdown="1">
숨겨진 내용
</div>
</details>
```

<details>
<summary>여기를 누르세요</summary>
<div markdown="1">
숨겨진 내용
</div>
</details> -->
