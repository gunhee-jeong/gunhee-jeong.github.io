---
layout: single
title: "모두를 위한 컴퓨터 과학 -> 6장 자료구조"
# categories: Git
categories:
  - Algorithm # HTML CSS JavaScript Server Algorithm Wecodes Programmers CS Github Blog
tag: [모두를 위한 컴퓨터 과학] #tag는 여러개 가능함
toc: true #table of content 기능!
toc_sticky: true
author_profile: true #blog 글안에서는 author_profile이 따라다니지 않도록 설정함
date: 2022-06-20T17:00:00+09:00
# sidebar:
# nav: "docs" #네비게이션에 있는 docs를 의미함
---
# 6장 자료구조
## 1. malloc와 포인터 복습
```c++
int main(void)
{
    int *x;
    int *y;

    x = malloc(sizeof(int));

    *x = 42;
    *y = 13;
}
```

위 코드에는 <u>버그가 하나 숨겨져</u> 있다.  
main 함수 안의 첫 두 줄에서는 포인터 x와 y를 선언한다.  
그리고 x에는 malloc 함수를 사용하여 int 자료형 크기에 해당하는 메모리를 할당해준다.  
그 다음에는 x와 y포인터가 가리키는 지점에 각각 42와 13을 저장하게 된다.  

여기서 <u>버그가 되는 코드는 *y = 13;</u>이다.  
<span style="color:royalblue">y는 포인터로만 선언되었을 뿐</span>, <span style="color:blue">어디를 가르킬지에 관해서는 정의되지 않았</span>기 때문이다.  
따라서 그 곳에 13이라는 값을 저장하는 것이 오류를 발생시키는 것이다.  

```c++
y = x;

*y = 13;
```

아래 코드와 같이 <span style="color:green">y = x;</span> 라는 코드를 더해주면, <u>y는 x가 가리키는 곳과 동일한 곳을 가리키게</u> 된다.  
그리고 <u>*y = 13;</u>으로 저장하면 <span style="color:blue">x 가 가리키는 곳에도 동일하게 13으로 저장</span>된다.  

## 2. 배열의 크기 조정하기
<u>일정한 크기의 배열</u>이 주어졌고, <span style="color:royalblue">그 크기를 키운다고 가정</span>했을 때  
단순하게 현재 배열이 저장되어 있는 메모리 위치의 <u>바로 옆에 일정 크기의 메모리를 덧붙이면 되겠지만</u>,  
<span style="color:blue">실제로는 다른 데이터가 저장되어 있을 확률이 높다</span>.  
따라서 안전하게 새로운 공간에, 큰 크기의 메모리를 다시 할당하고 <u>기존 배열의 값들을 하나씩 옮겨야</u> 한다.  
이런 작업은 <span style="color:blue">O(n)</span>, 즉 배열의 크기 n만큼의 실행 시간이 소요된다.  
이 과정을 아래의 코드로 나타낼 수 있다.  

```c++
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    //int 자료형 3개로 이루어진 list 라는 포인터를 선언하고 메모리 할당
    int *list = malloc(3 * sizeof(int));

    // 포인터가 잘 선언되었는지 확인
    if (list == NULL)
    {
        return 1;
    }

    // list 배열의 각 인덱스에 값 저장
    list[0] = 1;
    list[1] = 2;
    list[2] = 3;

    //int 자료형 4개 크기의 tmp 라는 포인터를 선언하고 메모리 할당
    int *tmp = malloc(4 * sizeof(int));

    if (tmp == NULL)
    {
        return 1;
    }

    // list의 값을 tmp로 복사
    for (int i = 0; i < 3; i++)
    {
        tmp[i] = list[i];
    }

    // tmp배열의 네 번째 값도 저장
    tmp[3] = 4;

    // list의 메모리를 초기화
    free(list);

    // list가 tmp와 같은 곳을 가리키도록 지정
    list = tmp;

    // 새로운 배열 list의 값 확인
    for (int i = 0; i < 4; i++)
    {
        printf("%i\n", list[i]);
    }

    // list의 메모리 초기화
    free(list);
}
```

위와 동일한 작업을 <span style="color:red">realloc</span> 이라는 함수를 이용해서 나타낼 수 있다.  
realloc()를 사용하여 <u>int 자료형 3개로 이루어진 배열 list</u>를 -> <span style="color:tomato">int 자료형 4개를 담을 수 있는 배열</span>로 확장했다.  

```c++
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    int *list = malloc(3 * sizeof(int));
    if (list == NULL)
    {
        return 1;
    }

    list[0] = 1;
    list[1] = 2;
    list[2] = 3;

    // tmp 포인터에 메모리를 할당하고 list의 값 복사
    int *tmp = realloc(list, 4 * sizeof(int));
    if (tmp == NULL)
    {
        return 1;
    }

    // list가 tmp와 같은 곳을 가리키도록 지정
    list = tmp;

    // 새로운 list의 네 번째 값 저장
    list[3] = 4;

    // list의 값 확인
    for (int i = 0; i < 4; i++)
    {
        printf("%i\n", list[i]);
    }

    //list 의 메모리 초기화
    free(list);
}
```

## 3. 연결 리스트 : 도입
데이터 구조는 우리가 컴퓨터 메모리를 더 효율적으로 관리하기 위해 새로 정의하는 구조체이다.  
(일종의 메모리 레이아웃, 또는 지도라고 생각할 수 있다.)  

<span style="color:red">배열</span>에서는 각 <span style="color:tomato">인덱스의 값이 메모리상에서 연이어 저장</span>된다.  
그러나 각 값이 메모리상의 여러 군데 나누어져 있다고 하더라도  
바로 다음 값의 메모리 주소를 기억하고 있다면, 값을 연이어서 읽을 수 있다.  
이를 "연결 리스트"라고 한다.  
아래의 그림과 같이 크기가 3인 연결 리스트는  
각 인덱스의 메모리 주소에서 자신의 값과 함께 다음 값의 주소(포인터)를 저장한다.  
<img src="https://user-images.githubusercontent.com/87808288/174578206-3a9c1b7d-720b-4b37-a2be-833fcccb67d6.png" width="500">  

연결 리스트의 가장 첫 번째 값인 1은 2의 메모리 주소를, 2는 3의 메모리 주소를 함께 저장하고 있다.  
3은 다음 값이 없기 때문에 NULL(\0: 즉 0으로 채워진 값을 의미)을 다음 값의 주소로 저장한다.  

연결 리스트는 아래의 코드와 같이 간단한 구조체로 정의할 수 있다.  

```c++
typedef struct node
{
    int number;
    struct node *next;
}
node;
```

<u>node 라는 이름의 구조체</u>는 <span style="color:red">number</span> 와 <span style="color:red">*next</span> 두 개의 필드가 함께 정의되어 있다.  
<span style="color:blue">number는 각 node가 가지는 값</span>, <span style="color:blue">*next 는 다음 node를 가지키는 포인터</span>가 된다.  
여기서 typedef struct 대신에 typedef struct node 라고 'node'를 함께 명시해 주는 것은,  
구조체 안에서 node를 사용하기 위함이다.  

## 4. 연결 리스트: 코딩
```c++
#include <stdio.h>
#include <stdlib.h>

//연결 리스트의 기본 단위가 되는 node 구조체를 정의합니다.
typedef struct node
{
    //node 안에서 정수형 값이 저장되는 변수를 name으로 지정합니다.
    int number; 

    //다음 node의 주소를 가리키는 포인터를  *next로 지정합니다.
    struct node *next;
}
node;

int main(void)
{
    // list라는 이름의 node 포인터를 정의합니다. 연결 리스트의 가장 첫 번째 node를 가리킬 것입니다. 
    // 이 포인터는 현재 아무 것도 가리키고 있지 않기 때문에 NULL 로 초기화합니다.
    node *list = NULL;

    // 새로운 node를 위해 메모리를 할당하고 포인터 *n으로 가리킵니다.
    // 이 부분은 결국, 한몸에 위에는 number를 아래에는 next를 가진 연결 리스트를 만들게 된 것이다.
    node *n = malloc(sizeof(node));
    if (n == NULL)
    {
        return 1;
    }

    // n의 number 필드에 1의 값을 저장합니다. “n->number”는 “(*n).numer”와 동일한 의미입니다. 
    // 즉, n이 가리키는 node의 number 필드를 의미하는 것입니다. 
    // 간단하게 화살표 표시 ‘->’로 쓸 수 있습니다. n의 number의 값을 1로 저장합니다.
    n->number = 1;

    // n 다음에 정의된 node가 없으므로 NULL로 초기화합니다.
    n->next = NULL;

    // 이제 첫번째 node를 정의했기 떄문에 list 포인터를 n 포인터로 바꿔 줍니다.
    list = n;

    // 리스트에 2를 넣는 코드
    // 이제 list에 다른 node를 더 연결하기 위해 n에 새로운 메모리를 다시 할당합니다.
    // n을 이용해서 임시 변수로 사용
    n = malloc(sizeof(node));
    if (n == NULL)
    {
        return 1;
    }

    // n의 number와 next의 값을 각각 저장합니다.
    n->number = 2;
    n->next = NULL;

    // list가 가리키는 것은 첫 번째 node입니다. 
    //이 node의 다음 node를 n 포인터로 지정합니다.
    list->next = n;

    // 다시 한 번 n 포인터에 새로운 메모리를 할당하고 number과 next의 값을 저장합니다.
    n = malloc(sizeof(node));
    if (n == NULL)
    {
        return 1;
    }

    n->number = 3;
    n->next = NULL;

    // 현재 list는 첫번째 node를 가리키고, 이는 두번째 node와 연결되어 있습니다. 
    // 따라서 세 번째 node를 더 연결하기 위해 첫 번째 node (list)의 
    // 다음 node(list->next)의 다음 node(list->next->next)를 n 포인터로 지정합니다.
    list->next->next = n;

    // 이제 list에 연결된 node를 처음부터 방문하면서 각 number 값을 출력합니다. 
    // 마지막 node의 next에는 NULL이 저장되어 있을 것이기 때문에 이 것이 for 루프의 종료 조건이 됩니다.
    for (node *tmp = list; tmp != NULL; tmp = tmp->next)
    {
        printf("%i\n", tmp->number);
    }

    // 메모리를 해제해주기 위해 list에 연결된 node들을 처음부터 방문하면서 free 해줍니다.
    while (list != NULL)
    {
        node *tmp = list->next;
        free(list);
        list = tmp;
    }
}
```

## 5. 연결 리스트: 시연
배열과 비교하면 연결 리스트는 새로운 값을 추가할 때 다시 메모리를 할당하지 않아도 된다는 장점이 있다.  
하지만 이런 장점의 대가로, 구조가 정적인 배열과 달리 연결 리스트는 임의 접근이 불가하다.  

연결 리스트에 값을 추가하거나 검색을 한다면,  
이를 위해서는 해당하는 위치까지 연결 리스트의 각 node를 따라 이동하게 된다.  
그러므로 `연결 리스트`의 크기가 n일 때 그 실행 시간은 <span style="color:red">O(n)</span>이 된다.  
<span style="color:red">배열</span>의 경우는 <span style="color:tomato">임의 접근이 가능</span>하기 때문에 `이진 검색`을 이용하면 <span style="color:blue">O(log)</span>의 실행 시간이 소요 되는 것에 비해 불리하다.  

## 6. 연결 리스트: 트리
트리는 연결리스트를 기반으로 한 새로운 데이터의 구조이다.  
연결 리스트에서의 각 노드(연결 리스트 내의 한 요소를 지칭)들의 연결이 1차원적으로 구성되어 있었다면,  
트리에서의 노드들의 연결은 2차원적으로 구성되어 있다.  

각 노드는 일정한 층에 속하고, 다음 층의 노드들을 가리키는 포인터를 가지게 된다.  
그림에서의 <u>가장 높은 층에서 트리</u>가 시작되고 이 <span style="color:red">노드를 '루트'</span>라고 한다.  
루트 노드는 다음 층의 노드들을 가리키고, 이를 '자식 노드'라고 한다.  
<img src="https://user-images.githubusercontent.com/87808288/174706029-30d6a935-5748-4478-9766-6ec48f183275.png" width="400">  

위의 그림에서 설명한 트리는 구체적으로는 '이진 트리'이다.  
각 노드가 구성되어 있는 구조를 살펴보면 일정한 규칙을 알 수 있는데,  
먼저 하나의 노드는 두 개의 자식 노드를 가지게 된다.  
그리고 왼쪽 자식 노드는 자신의 값보다 작고, 오른쪽 자식 노드는 자신의 값보다 크다.  
그러므로 위의 트리 구조는 이진 검색을 수행하는데 유리한 것이다.  

아래의 코드는 이진 검색 트리의 노드 구조체와 "50"을 재귀적으로 검색하는 이진 검색 함수를 구현했다.  

```c++
//이진 검색 트리의 노드 구조체
typedef struct node
{
    // 노드의 값
    int number;

    // 왼쪽 자식 노드
    struct node *left;
 
   // 오른쪽 자식 노드
    struct node *right;
} node;

// 이진 검색 함수 (*tree는 이진 검색 트리를 가리키는 포인터)
bool search(node *tree)
{
    // 트리가 비어있는 경우 ‘false’를 반환하고 함수 종료
    if (tree == NULL)
    {
        return false;
    }
    // 현재 노드의 값이 50보다 크면 왼쪽 노드 검색
    else if (50 < tree->number)
    {
        return search(tree->left);
    }
    // 현재 노드의 값이 50보다 작으면 오른쪽 노드 검색
    else if (50 > tree->number)
    {
        return search(tree->right);
    }
    // 위 모든 조건이 만족하지 않으면 노드의 값이 50이므로 ‘true’ 반환
    else {
        return true;
    }
}
```

## 7. 해시 테이블
`해시 테이블`은 "연결 리스트의 배열"이다.  
각 값들은 '<span style="color:red">해시 함수</span>'라는 맞춤형 함수를 통해서 어떤 바구니에 담기는 지가 결정된다.  
각 바구니에 담기는 값들은 그 바구니에서 새롭게 정의되는 연결 리스트로 이루어진다.  
이와 같이 <span style="color:blue">연결 리스트가 담긴 바구니가 여러 개가 있는 것</span>이 "<span style="color:tomato">연결 리스트의 배열</span>", 즉 "해시 테이블"이 된다.  

아래의 그림은 해시 함수 사람의 이름이 해시 테이블에 저장된다.  
아래의 해시 함수는 "이름의 가장 첫 글자"인 경우로 가정한다.  
그 경우 알파벳 개수에 해당하는 총 26개의 포인터들이 있을 수 있고,  
각 포인터는 해당 알파벳으로 시작하는 이름들을 저장하는 연결 리스트를 가지게 된다.  
<img src="https://user-images.githubusercontent.com/87808288/174710078-619b6245-a066-43cb-b5fe-e5edad8c58d1.png" width="400">  

만약 해시 함수가 이상적이라면, 각 바구니에는 단 하나의 값들만 담기게 된다.  
따라서 검색 시간은 0(1)이 된다.  
하지만 그렇지 않은 경우, 최악의 상황에는 단 하나의 바구니에 모든 값들이 담겨서 O(n)이 될 수도 있다.  
일반적으로는 최대한 많은 바구니를 만드는 해시 함수를 사용하기 때문에 O(1)에 가깝다.  

## 8. 트라이
<span style="color:red">트라이</span>는 기본적으로 <span style="color:blue">트리 형태</span>의 자료구조를 갖는다.  
특이한 점은 각 노드가 "배열"로 이루어져있다는 것이다.  
<u>알파벳으로 된 문자열 값을 저장</u>한다고 하면 이 <span style="color:red">노드는 a부터 z까지의 값을 가지는 배열</span>이 된다.  
그리고 배열의 각 요소, 즉 알파벳은 다음 층의 노드(a-z 배열)을 가리킨다.  

아래의 그림과 같이 Hermione, Harry, Hagrid 세 문자열을 트라이에 저장한다면  
루트 노드를 시작으로 각 화살표가 가리키는 알파벳을 따라가면서 노드를 이어주게 된다.  
<img src="https://user-images.githubusercontent.com/87808288/174713478-d2328d9b-451b-4492-834a-22f84e3df069.png" width="800">  

위와 같이 트라이에서 값을 검색하는데 걸리는 시간은 "문자열의 길이"에 의해 한정된다.  
단순히 문자열의 각 문자를 보며 트리를 탐색해나가기만 하면 되기 때문이다.  

일반적인 영어 이름의 길이를 n이라고 했을 때, 검색 시간은 O(n)이 되지만,  
대부분의 이름은 그리 크지 않은 상수값(20자 이내)이기 때문에 O(1)이나 마찬가지라고 볼 수 있다.  

## 9. 스택, 큐, 딕셔너리
### (1) 큐
<span style="color:red">큐</span>는 값이 아래로 쌓이는 구조이다.  
값을 넣고 뺄 때 "<span style="color:tomato">선입선출: FIFO</span>"라는 방식을 따르게 된다.  
가장 먼저 들어온 값이 가장 먼저 나가게 되는 것이다.  
이는 배열이나 연결 리스트를 사용해 구현이 가능하다.  

### (2) 스택
스택은 큐와는 반대로 값이 위로 쌓이는 구조를 나타낸다.  
따라서 값을 넣고 뺄 때는 "후입 선출: LIFO"라는 방식을 따르게 된다.  
가장 나중에 들어온 값이 가장 먼저 나가는 것이다.  
스택 역시 배열이나 연결 리스트를 사용해 구현할 수 있다.  

### (3) 딕셔너리
딕셔너리는 "키"와 "값"이라는 요소로 이루어져 있다.  
"키"에 해당하는 "값"을 저장하고 읽어오는 것이다.  
이것은 마치 학교에서 "학번"에 따라서 "학생"이 결정되는 것과 동일하다.  
일반적인 의미에서는 "해시 테이블"과 동일한 개념이라고 볼 수 있다.  

이렇게 `자료구조`를 구현함에 있어서  
<span style="color:red">시간 복잡도</span>, <span style="color:red">공간 복잡도</span>, <span style="color:red">데이터의 양</span>을 고려해야한다.  

<!-- <span style="color:royalblue"> -->

<!-- ① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ Ω-->

<!-- ### 2. Link 넣기 

```

유형 1: (설명어를 입력) : [gunhee's coding blog](https://gunhee-jeong.github.io/)
유형 2: (URL 자동연결) : <https://gunhee-jeong.github.io/>
유형 3: (동일 파일 내 '문단으로 이동') : [1. Header로 이동](###-1-header)

```

유형 1: (설명어를 입력) : [gunhee's coding blog](https://gunhee-jeong.github.io/)
유형 2: (URL 자동연결) : <https://gunhee-jeong.github.io/>
유형 3: (동일 파일 내 '문단으로 이동') : [1. Header로 이동](#1-header)
유형 3의 방법

1. 특수문자를 제거
2. 스페이스는 -로 바꾸고
3. 대문자는 소문자로!
   그래서 ### 1. Header -> #1-header

## Link: [google][https://www.google.com/]

### 3. 수평선

```

---

```

---

### 4. 라인 바꾸기

```

스페이스바를 2번 눌러주면 다음칸으로
이동할 수 있어요!

```

---

스페이스바를 2번 눌러주면
다음칸으로 이동할 수 있어요!

### 5. list 만들기

```

1. 1번
2. 2번
3. 3번

- 순서없는 list
  - 순서없는 list
    - 순서없는 list

```

1. 1번
2. 2번
3. 3번

- 순서없는 list
  - 순서없는 list
    - 순서없는 list

---

### 6. font 관련

```

**진하게** -> 볼드
_기울여서_ -> 이탤릭체
~~취소선~~ -> 취소선

<ul>밑줄넣기</ul> -> 밑줄
<span style="color:red">빨간 글씨</span> -> 글자색
이것이 `인라인` 입니다 -> 인라인 코드
```

**진하게** -> 볼드
_기울여서_ -> 이탤릭체
~~취소선~~ -> 취소선
<u>밑줄넣기</u> -> 밑줄
<span style="color:red">빨간 글씨</span>
이것이 `인라인` 입니다 -> 인라인 코드

---

### 7. 인용구문

```
> coding
>
> > JavaScript
> >
> > > 내가 프짱!
```

> coding
>
> > JavaScript
> >
> > > 내가 프짱!

---

### 8. 이미지 삽입

```
유형1: ('사이즈를 조절' -> HTML 태그 사용) : <img src="https://gunhee-jeong.github.io/assets/images/blogLogo.png" width="500" height="200">
유형2: (이미지 삽입 후 -> 링크 걸기)
[![이미지](https://gunhee-jeong.github.io/assets/images/blogLogo/blogLogo.png)](https://gunhee-jeong.github.io/)
```
### 9. 표 만들기

```
||국어|영어|
| :--- | ---: | :--: |
|건희 | 100점 | 100점
|철수 | 100점 | 100점
```

|      |  국어 | 영어  |
| :--- | ----: | :---: |
| 건희 | 100점 | 100점 |
| 철수 | 100점 | 100점 |

> - header를 넣고 싶은 경우 ---을 사용하고 :을 이용하여 정렬에 사용함!

### 10. 토글 만들기

```
<details>
<summary>여기를 누르세요</summary>
<div markdown="1">
숨겨진 내용
</div>
</details>
```

<details>
<summary>여기를 누르세요</summary>
<div markdown="1">
숨겨진 내용
</div>
</details> -->
